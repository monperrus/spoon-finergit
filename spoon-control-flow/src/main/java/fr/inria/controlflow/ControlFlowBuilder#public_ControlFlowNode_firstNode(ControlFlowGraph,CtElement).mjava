/** 
 * Returns the first graph node representing the statement s construction. <p/> Usually an statement is represented by many blocks and branches. This method returns the first of those blocks/branches.
 * @param g         Graph in which the bloc is to be found
 * @param statement Statement for which the first block is needed
 * @return
 */
public
static
ControlFlowNode
firstNode
(
ControlFlowGraph
g
,
CtElement
statement
)
throws
NotFoundException
{
if
(
statement
==
null
)
{
throw
new
NotFoundException
(
"statement null"
)
;
}
if
(
statement
instanceof
CtFor
)
{
CtFor
ctFor
=
(
CtFor
)
statement
;
if
(
ctFor
.
getForInit
(
)
.
size
(
)
>
0
)
{
return
g
.
findNode
(
ctFor
.
getForInit
(
)
.
get
(
0
)
)
;
}
else
{
return
g
.
findNode
(
ctFor
.
getExpression
(
)
)
;
}
}
else
if
(
statement
instanceof
CtForEach
)
{
return
g
.
findNode
(
(
(
CtForEach
)
statement
)
.
getVariable
(
)
)
;
}
else
if
(
statement
instanceof
CtWhile
)
{
return
g
.
findNode
(
(
(
CtWhile
)
statement
)
.
getLoopingExpression
(
)
)
;
}
else
if
(
statement
instanceof
CtDo
)
{
ControlFlowNode
n
=
g
.
findNode
(
(
(
CtDo
)
statement
)
.
getLoopingExpression
(
)
)
;
ControlFlowNode
n1
=
null
;
for
(
ControlFlowEdge
e
:
g
.
outgoingEdgesOf
(
n
)
)
{
if
(
e
.
isBackEdge
(
)
)
{
n1
=
e
.
getTargetNode
(
)
;
break
;
}
}
if
(
n
==
n1
||
n1
==
null
)
{
throw
new
NotFoundException
(
"cannot find initial node of do while loop"
)
;
}
return
n1
;
}
else
if
(
statement
instanceof
CtIf
)
{
return
g
.
findNode
(
(
(
CtIf
)
statement
)
.
getCondition
(
)
)
;
}
else
if
(
statement
instanceof
CtSwitch
)
{
return
g
.
findNode
(
(
(
CtSwitch
)
statement
)
.
getSelector
(
)
)
;
}
else
if
(
statement
instanceof
CtBlock
)
{
return
g
.
findNode
(
(
(
CtBlock
)
statement
)
.
getStatement
(
0
)
)
;
}
else
{
return
g
.
findNode
(
statement
)
;
}
}
