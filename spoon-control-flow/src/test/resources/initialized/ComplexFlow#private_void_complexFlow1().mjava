/** 
 * Status: Not solved
 */
private
void
complexFlow1
(
)
{
int
pp
=
p
-
1
;
int
iter
=
0
;
double
eps
=
Math
.
pow
(
2.0
,
-
52.0
)
;
double
tiny
=
Math
.
pow
(
2.0
,
-
966.0
)
;
while
(
p
>
0
)
{
int
k
,
kase
;
for
(
k
=
p
-
2
;
k
>=
-
1
;
k
--
)
{
if
(
k
==
-
1
)
break
;
if
(
Math
.
abs
(
e
.
get
(
k
)
)
<=
tiny
+
eps
*
(
Math
.
abs
(
s
.
get
(
k
)
)
+
Math
.
abs
(
s
.
get
(
k
+
1
)
)
)
)
{
e
.
set
(
k
,
0.0
)
;
break
;
}
}
if
(
k
==
p
-
2
)
{
kase
=
4
;
}
else
{
int
ks
;
for
(
ks
=
p
-
1
;
ks
>=
k
;
ks
--
)
{
if
(
ks
==
k
)
break
;
double
t
=
(
ks
!=
p
?
Math
.
abs
(
e
.
get
(
ks
)
)
:
0.
)
+
(
ks
!=
k
+
1
?
Math
.
abs
(
e
.
get
(
ks
-
1
)
)
:
0.
)
;
if
(
Math
.
abs
(
s
.
get
(
ks
)
)
<=
tiny
+
eps
*
t
)
{
s
.
set
(
ks
,
0.0
)
;
break
;
}
}
if
(
ks
==
k
)
{
kase
=
3
;
}
else
if
(
ks
==
p
-
1
)
{
kase
=
1
;
}
else
{
kase
=
2
;
k
=
ks
;
}
}
k
++
;
switch
(
kase
)
{
case
1
:
{
double
f
=
e
.
get
(
p
-
2
)
;
e
.
set
(
p
-
2
,
0.0
)
;
for
(
int
j
=
p
-
2
;
j
>=
k
;
j
--
)
{
double
sj
=
s
.
get
(
j
)
;
double
t
=
Math
.
hypot
(
sj
,
f
)
;
double
cs
=
sj
/
t
;
double
sn
=
f
/
t
;
s
.
set
(
j
,
j
,
t
)
;
if
(
j
!=
k
)
{
f
=
-
sn
*
e
.
get
(
j
-
1
)
;
e
.
set
(
j
-
1
,
cs
*
e
.
get
(
j
-
1
)
)
;
}
for
(
int
i
=
0
;
i
<
cc
;
i
++
)
{
t
=
cs
*
v
.
get
(
i
,
j
)
+
sn
*
v
.
get
(
i
,
p
-
1
)
;
v
.
set
(
i
,
p
-
1
,
-
sn
*
v
.
get
(
i
,
j
)
+
cs
*
v
.
get
(
i
,
p
-
1
)
)
;
v
.
set
(
i
,
j
,
t
)
;
}
}
}
break
;
case
2
:
{
double
f
=
e
.
get
(
k
-
1
)
;
e
.
set
(
k
-
1
,
0.0
)
;
for
(
int
j
=
k
;
j
<
p
;
j
++
)
{
double
sj
=
s
.
get
(
j
)
;
double
t
=
Math
.
hypot
(
sj
,
f
)
;
double
cs
=
sj
/
t
;
double
sn
=
f
/
t
;
s
.
set
(
j
,
j
,
t
)
;
f
=
-
sn
*
e
.
get
(
j
)
;
e
.
set
(
j
,
cs
*
e
.
get
(
j
)
)
;
for
(
int
i
=
0
;
i
<
rc
;
i
++
)
{
t
=
cs
*
u
.
get
(
i
,
j
)
+
sn
*
u
.
get
(
i
,
k
-
1
)
;
u
.
set
(
i
,
k
-
1
,
-
sn
*
u
.
get
(
i
,
j
)
+
cs
*
u
.
get
(
i
,
k
-
1
)
)
;
u
.
set
(
i
,
j
,
t
)
;
}
}
}
break
;
case
3
:
{
double
scale
=
Math
.
max
(
Math
.
max
(
Math
.
max
(
Math
.
max
(
Math
.
abs
(
s
.
get
(
p
-
1
)
)
,
Math
.
abs
(
s
.
get
(
p
-
2
)
)
)
,
Math
.
abs
(
e
.
get
(
p
-
2
)
)
)
,
Math
.
abs
(
s
.
get
(
k
)
)
)
,
Math
.
abs
(
e
.
get
(
k
)
)
)
;
double
sp
=
s
.
get
(
p
-
1
)
/
scale
;
double
spm1
=
s
.
get
(
p
-
2
)
/
scale
;
double
epm1
=
e
.
get
(
p
-
2
)
/
scale
;
double
sk
=
s
.
get
(
k
)
/
scale
;
double
ek
=
e
.
get
(
k
)
/
scale
;
double
b
=
(
(
spm1
+
sp
)
*
(
spm1
-
sp
)
+
epm1
*
epm1
)
/
2.0
;
double
c
=
(
sp
*
epm1
)
*
(
sp
*
epm1
)
;
double
shift
=
0.0
;
if
(
(
b
!=
0.0
)
|
(
c
!=
0.0
)
)
{
shift
=
Math
.
sqrt
(
b
*
b
+
c
)
;
if
(
b
<
0.0
)
{
shift
=
-
shift
;
}
shift
=
c
/
(
b
+
shift
)
;
}
double
f
=
(
sk
+
sp
)
*
(
sk
-
sp
)
+
shift
;
double
g
=
sk
*
ek
;
for
(
int
j
=
k
;
j
<
p
-
1
;
j
++
)
{
double
t
=
Math
.
hypot
(
f
,
g
)
;
double
cs
=
f
/
t
;
double
sn
=
g
/
t
;
if
(
j
!=
k
)
{
e
.
set
(
j
-
1
,
t
)
;
}
double
sj
=
s
.
get
(
j
)
;
f
=
cs
*
sj
+
sn
*
e
.
get
(
j
)
;
e
.
set
(
j
,
cs
*
e
.
get
(
j
)
-
sn
*
sj
)
;
g
=
sn
*
s
.
get
(
j
+
1
)
;
s
.
set
(
j
+
1
,
cs
*
s
.
get
(
j
+
1
)
)
;
for
(
int
i
=
0
;
i
<
cc
;
i
++
)
{
t
=
cs
*
v
.
get
(
i
,
j
)
+
sn
*
v
.
get
(
i
,
j
+
1
)
;
v
.
set
(
i
,
j
+
1
,
-
sn
*
v
.
get
(
i
,
j
)
+
cs
*
v
.
get
(
i
,
j
+
1
)
)
;
v
.
set
(
i
,
j
,
t
)
;
}
t
=
Math
.
hypot
(
f
,
g
)
;
cs
=
f
/
t
;
sn
=
g
/
t
;
s
.
set
(
j
,
t
)
;
f
=
cs
*
e
.
get
(
j
)
+
sn
*
s
.
get
(
j
+
1
)
;
s
.
set
(
j
+
1
,
-
sn
*
e
.
get
(
j
)
+
cs
*
s
.
get
(
j
+
1
)
)
;
g
=
sn
*
e
.
get
(
j
+
1
)
;
e
.
set
(
j
+
1
,
e
.
get
(
j
+
1
)
*
(
cs
)
)
;
if
(
j
<
rc
-
1
)
{
for
(
int
i
=
0
;
i
<
rc
;
i
++
)
{
t
=
cs
*
u
.
get
(
i
,
j
)
+
sn
*
u
.
get
(
i
,
j
+
1
)
;
u
.
set
(
i
,
j
+
1
,
-
sn
*
u
.
get
(
i
,
j
)
+
cs
*
u
.
get
(
i
,
j
+
1
)
)
;
u
.
set
(
i
,
j
,
t
)
;
}
}
}
e
.
set
(
p
-
2
,
f
)
;
iter
=
iter
+
1
;
}
break
;
case
4
:
{
double
skk
=
s
.
get
(
k
)
;
if
(
skk
<=
0.0
)
{
s
.
set
(
k
,
-
skk
)
;
for
(
int
i
=
0
;
i
<=
pp
;
i
++
)
{
v
.
set
(
i
,
k
,
-
v
.
get
(
i
,
k
)
)
;
}
}
while
(
k
<
pp
)
{
if
(
s
.
get
(
k
)
>=
s
.
get
(
k
+
1
)
)
break
;
double
t
=
s
.
get
(
k
)
;
s
.
set
(
k
,
s
.
get
(
k
+
1
)
)
;
s
.
set
(
k
+
1
,
t
)
;
if
(
k
<
cc
-
1
)
{
v
.
set
(
k
,
(
double
)
k
+
1
)
;
}
if
(
k
<
rc
-
1
)
{
u
.
set
(
k
,
(
double
)
k
+
1
)
;
}
k
++
;
}
iter
=
0
;
p
--
;
}
break
;
}
}
}
