/** 
 * Calculates the value of the binary operation.
 */
private
Expr
calcBinaryOperator
(
Expr
leftValue
,
CtTypeReference
<
?
>
leftType
,
Expr
rightValue
,
CtTypeReference
<
?
>
rightType
,
BinaryOperatorKind
kind
)
{
final
boolean
compareReferences
=
(
kind
==
BinaryOperatorKind
.
EQ
||
kind
==
BinaryOperatorKind
.
NE
)
&&
!
leftType
.
isPrimitive
(
)
&&
!
rightType
.
isPrimitive
(
)
;
if
(
!
compareReferences
)
{
if
(
!
isCalculable
(
leftType
)
||
leftValue
==
null
)
{
return
isBooleanOperatorKind
(
kind
)
?
context
.
mkFreshConst
(
""
,
context
.
getBoolSort
(
)
)
:
null
;
}
if
(
!
leftType
.
isPrimitive
(
)
)
{
leftValue
=
memory
.
read
(
leftType
.
unbox
(
)
,
(
IntExpr
)
leftValue
)
;
}
}
if
(
!
compareReferences
)
{
if
(
!
isCalculable
(
rightType
)
||
rightValue
==
null
)
{
return
isBooleanOperatorKind
(
kind
)
?
context
.
mkFreshConst
(
""
,
context
.
getBoolSort
(
)
)
:
null
;
}
if
(
!
rightType
.
isPrimitive
(
)
)
{
rightValue
=
memory
.
read
(
rightType
.
unbox
(
)
,
(
IntExpr
)
rightValue
)
;
}
}
if
(
!
compareReferences
)
{
if
(
leftValue
instanceof
BitVecExpr
&&
rightValue
instanceof
BitVecExpr
)
{
Expr
[
]
result
=
promoteNumericValues
(
context
,
leftValue
,
leftType
,
rightValue
,
rightType
)
;
leftValue
=
result
[
0
]
;
rightValue
=
result
[
1
]
;
}
}
switch
(
kind
)
{
case
AND
:
return
context
.
mkAnd
(
(
BoolExpr
)
leftValue
,
(
BoolExpr
)
rightValue
)
;
case
OR
:
return
context
.
mkOr
(
(
BoolExpr
)
leftValue
,
(
BoolExpr
)
rightValue
)
;
case
BITOR
:
if
(
leftValue
instanceof
BitVecExpr
&&
rightValue
instanceof
BitVecExpr
)
{
return
context
.
mkBVOR
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
}
else
{
return
context
.
mkOr
(
(
BoolExpr
)
leftValue
,
(
BoolExpr
)
rightValue
)
;
}
case
BITXOR
:
if
(
leftValue
instanceof
BitVecExpr
&&
rightValue
instanceof
BitVecExpr
)
{
return
context
.
mkBVXOR
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
}
else
{
return
context
.
mkDistinct
(
leftValue
,
rightValue
)
;
}
case
BITAND
:
if
(
leftValue
instanceof
BitVecExpr
&&
rightValue
instanceof
BitVecExpr
)
{
return
context
.
mkBVAND
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
}
else
{
return
context
.
mkAnd
(
(
BoolExpr
)
leftValue
,
(
BoolExpr
)
rightValue
)
;
}
case
EQ
:
return
context
.
mkEq
(
leftValue
,
rightValue
)
;
case
NE
:
return
context
.
mkDistinct
(
leftValue
,
rightValue
)
;
case
LT
:
return
context
.
mkBVSLT
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
case
LE
:
return
context
.
mkBVSLE
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
case
GT
:
return
context
.
mkBVSGT
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
case
GE
:
return
context
.
mkBVSGE
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
case
SL
:
return
context
.
mkBVSHL
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
case
SR
:
return
context
.
mkBVASHR
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
case
USR
:
return
context
.
mkBVLSHR
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
case
PLUS
:
return
context
.
mkBVAdd
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
case
MINUS
:
return
context
.
mkBVSub
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
case
MUL
:
return
context
.
mkBVMul
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
case
DIV
:
return
context
.
mkBVSDiv
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
case
MOD
:
return
context
.
mkBVSRem
(
(
BitVecExpr
)
leftValue
,
(
BitVecExpr
)
rightValue
)
;
default
:
throw
new
RuntimeException
(
"Unexpected binary operator"
)
;
}
}
