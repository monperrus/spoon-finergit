private
void
visitMethod
(
CtElement
body
,
List
<
CtParameter
<
?
>
>
parameters
)
{
solver
.
push
(
)
;
Map
<
CtReference
,
Expr
>
oldValues
=
new
HashMap
<
>
(
variablesMap
)
;
Memory
oldMemory
=
new
Memory
(
memory
)
;
BoolExpr
oldConditions
=
currentConditions
;
CtReference
oldReturnFlagReference
=
returnFlagReference
;
CtReference
oldBreakFlagReference
=
breakFlagReference
;
CtReference
oldContinueFlagReference
=
continueFlagReference
;
CtReference
oldThrowFlagReference
=
throwFlagReference
;
currentResult
=
null
;
currentConditions
=
null
;
returnFlagReference
=
FlagReference
.
makeFreshReturnReference
(
)
;
variablesMap
.
put
(
returnFlagReference
,
context
.
mkFalse
(
)
)
;
breakFlagReference
=
FlagReference
.
makeFreshBreakReference
(
)
;
variablesMap
.
put
(
breakFlagReference
,
context
.
mkFalse
(
)
)
;
continueFlagReference
=
FlagReference
.
makeFreshContinueReference
(
)
;
variablesMap
.
put
(
continueFlagReference
,
context
.
mkFalse
(
)
)
;
throwFlagReference
=
FlagReference
.
makeFreshThrowReference
(
)
;
variablesMap
.
put
(
throwFlagReference
,
context
.
mkFalse
(
)
)
;
for
(
CtParameter
<
?
>
parameter
:
parameters
)
{
if
(
parameter
.
getType
(
)
.
isPrimitive
(
)
)
{
Sort
sort
=
TypeUtils
.
getTypeSort
(
context
,
parameter
.
getType
(
)
)
;
variablesMap
.
put
(
parameter
.
getReference
(
)
,
context
.
mkFreshConst
(
""
,
sort
)
)
;
}
else
{
Expr
address
=
context
.
mkFreshConst
(
""
,
context
.
getIntSort
(
)
)
;
variablesMap
.
put
(
parameter
.
getReference
(
)
,
address
)
;
}
}
scan
(
body
)
;
variablesMap
=
oldValues
;
memory
=
oldMemory
;
currentConditions
=
oldConditions
;
returnFlagReference
=
oldReturnFlagReference
;
breakFlagReference
=
oldBreakFlagReference
;
continueFlagReference
=
oldContinueFlagReference
;
throwFlagReference
=
oldThrowFlagReference
;
solver
.
pop
(
)
;
}
