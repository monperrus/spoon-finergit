@Override
public
<
S
>
void
visitCtSwitch
(
CtSwitch
<
S
>
switchStatement
)
{
Expr
breakExpr
=
variablesMap
.
get
(
breakFlagReference
)
;
CtExpression
<
S
>
selector
=
switchStatement
.
getSelector
(
)
;
CtTypeReference
<
?
>
selectorType
=
getActualType
(
selector
)
;
scan
(
selector
)
;
Expr
selectorValue
=
currentResult
;
if
(
!
getActualType
(
selector
)
.
isPrimitive
(
)
)
{
selectorValue
=
memory
.
read
(
getActualType
(
selector
)
.
unbox
(
)
,
(
IntExpr
)
selectorValue
)
;
}
BoolExpr
commonConditionExpr
=
null
;
List
<
CtCase
<
?
S
>
>
cases
=
switchStatement
.
getCases
(
)
;
for
(
CtCase
<
?
S
>
aCase
:
cases
)
{
CtExpression
<
?
>
caseExpression
=
aCase
.
getCaseExpression
(
)
;
BoolExpr
branchExpr
;
if
(
caseExpression
==
null
)
{
branchExpr
=
(
commonConditionExpr
==
null
)
?
context
.
mkTrue
(
)
:
context
.
mkNot
(
commonConditionExpr
)
;
}
else
{
CtTypeReference
<
?
>
caseType
=
getActualType
(
caseExpression
)
;
scan
(
caseExpression
)
;
Expr
caseValue
=
currentResult
;
if
(
selectorValue
instanceof
BitVecExpr
&&
caseValue
instanceof
BitVecExpr
)
{
Expr
[
]
result
=
promoteNumericValues
(
context
,
selectorValue
,
selectorType
,
caseValue
,
caseType
)
;
selectorValue
=
result
[
0
]
;
caseValue
=
result
[
1
]
;
}
BoolExpr
conditionExpr
=
context
.
mkEq
(
selectorValue
,
caseValue
)
;
caseExpression
.
putMetadata
(
"value"
,
conditionExpr
)
;
checkCondition
(
caseExpression
,
false
)
;
commonConditionExpr
=
(
commonConditionExpr
==
null
)
?
conditionExpr
:
context
.
mkOr
(
commonConditionExpr
,
conditionExpr
)
;
branchExpr
=
context
.
mkAnd
(
commonConditionExpr
,
context
.
mkNot
(
getBreakExpr
(
)
)
)
;
}
BranchData
thenBranchData
=
visitBranch
(
branchExpr
,
aCase
)
;
BranchData
elseBranchData
=
new
BranchData
(
variablesMap
,
memory
)
;
mergeBranches
(
branchExpr
,
thenBranchData
,
elseBranchData
)
;
}
variablesMap
.
put
(
breakFlagReference
,
breakExpr
)
;
}
