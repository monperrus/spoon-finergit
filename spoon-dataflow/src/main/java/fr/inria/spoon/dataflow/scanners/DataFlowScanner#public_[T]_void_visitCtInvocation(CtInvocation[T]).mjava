@Override
public
<
T
>
void
visitCtInvocation
(
CtInvocation
<
T
>
invocation
)
{
List
<
CtExpression
<
?
>
>
arguments
=
invocation
.
getArguments
(
)
;
for
(
CtExpression
<
?
>
argument
:
arguments
)
{
scan
(
argument
)
;
Expr
argumentExpr
=
currentResult
;
if
(
argumentExpr
!=
null
)
{
CtTypeReference
<
?
>
argumentType
=
getActualType
(
argument
)
;
if
(
!
argumentType
.
isPrimitive
(
)
&&
!
isImmutable
(
argumentType
)
)
{
memory
.
resetObject
(
argumentType
,
(
IntExpr
)
argumentExpr
)
;
}
}
}
CtExpression
<
?
>
target
=
invocation
.
getTarget
(
)
;
Expr
targetExpr
=
null
;
boolean
dereferenceTarget
=
false
;
if
(
target
!=
null
)
{
scan
(
target
)
;
targetExpr
=
currentResult
;
if
(
targetExpr
!=
null
)
{
CtTypeReference
<
?
>
targetType
=
getActualType
(
target
)
;
if
(
!
(
target
instanceof
CtTypeAccess
)
)
{
dereferenceTarget
=
true
;
if
(
!
isImmutable
(
targetType
)
)
{
memory
.
resetObject
(
targetType
,
(
IntExpr
)
targetExpr
)
;
}
}
}
}
CtTypeReference
<
?
>
returnType
=
invocation
.
getType
(
)
;
if
(
!
isVoid
(
returnType
)
)
{
Expr
returnValue
=
makeFreshConstFromType
(
context
,
returnType
)
;
currentResult
=
applyCasts
(
returnValue
,
returnType
,
invocation
.
getTypeCasts
(
)
)
;
invocation
.
putMetadata
(
"value"
,
currentResult
)
;
}
checkInvocation
(
invocation
)
;
if
(
dereferenceTarget
)
{
visitDereference
(
targetExpr
)
;
}
}
