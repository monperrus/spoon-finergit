@Override
public
<
T
>
void
visitCtUnaryOperator
(
CtUnaryOperator
<
T
>
operator
)
{
scan
(
operator
.
getOperand
(
)
)
;
Expr
operandValue
=
currentResult
;
UnaryOperatorKind
kind
=
operator
.
getKind
(
)
;
CtTypeReference
<
?
>
operandType
=
getActualType
(
operator
.
getOperand
(
)
)
;
if
(
!
isCalculable
(
operandType
)
||
operandValue
==
null
)
{
currentResult
=
isBooleanOperatorKind
(
kind
)
?
context
.
mkFreshConst
(
""
,
context
.
getBoolSort
(
)
)
:
null
;
operator
.
putMetadata
(
"value"
,
currentResult
)
;
return
;
}
if
(
operandValue
instanceof
BitVecExpr
)
{
operandValue
=
promoteNumericValue
(
context
,
operandValue
,
operandType
)
;
}
if
(
!
operandType
.
isPrimitive
(
)
)
{
operandValue
=
memory
.
read
(
operandType
.
unbox
(
)
,
(
IntExpr
)
operandValue
)
;
}
switch
(
kind
)
{
case
NOT
:
currentResult
=
context
.
mkNot
(
(
BoolExpr
)
operandValue
)
;
break
;
case
NEG
:
currentResult
=
context
.
mkBVNeg
(
(
BitVecExpr
)
operandValue
)
;
break
;
case
POS
:
currentResult
=
operandValue
;
break
;
case
COMPL
:
int
size
=
TypeUtils
.
isLong
(
operandType
)
?
64
:
32
;
currentResult
=
context
.
mkBVSub
(
context
.
mkBVNeg
(
(
BitVecExpr
)
operandValue
)
,
context
.
mkBV
(
1
,
size
)
)
;
break
;
case
POSTINC
:
case
PREINC
:
case
POSTDEC
:
case
PREDEC
:
CtExpression
<
T
>
operand
=
operator
.
getOperand
(
)
;
Expr
prevExpr
;
if
(
operand
instanceof
CtArrayWrite
)
{
IntExpr
targetExpr
=
getTargetValue
(
context
,
variablesMap
,
memory
,
(
(
CtArrayWrite
<
T
>
)
operand
)
.
getTarget
(
)
)
;
CtExpression
<
Integer
>
index
=
(
(
CtArrayWrite
<
T
>
)
operand
)
.
getIndexExpression
(
)
;
CtTypeReference
<
?
>
indexType
=
getActualType
(
index
)
;
Expr
indexExpr
=
(
Expr
)
index
.
getMetadata
(
"value"
)
;
indexExpr
=
promoteNumericValue
(
context
,
indexExpr
,
indexType
)
;
CtTypeReference
<
?
>
arrayType
=
(
(
CtArrayWrite
<
T
>
)
operand
)
.
getTarget
(
)
.
getType
(
)
;
prevExpr
=
memory
.
readArray
(
(
CtArrayTypeReference
)
arrayType
,
targetExpr
,
indexExpr
)
;
}
else
{
CtVariableReference
<
?
>
variable
=
(
(
CtVariableWrite
<
?
>
)
operand
)
.
getVariable
(
)
;
prevExpr
=
variablesMap
.
get
(
variable
)
;
}
Expr
literalValue
=
makeLiteral
(
1
)
;
boolean
isIncrement
=
kind
==
UnaryOperatorKind
.
POSTINC
||
kind
==
UnaryOperatorKind
.
PREINC
;
BinaryOperatorKind
binOpKind
=
isIncrement
?
BinaryOperatorKind
.
PLUS
:
BinaryOperatorKind
.
MINUS
;
Expr
resExpr
=
calcBinaryOperator
(
prevExpr
,
operandType
,
literalValue
,
factory
.
Type
(
)
.
INTEGER_PRIMITIVE
,
binOpKind
)
;
CtTypeReference
<
?
>
opType
=
operand
.
getType
(
)
.
unbox
(
)
;
visitAssignment
(
operand
,
operandValue
,
operandType
,
resExpr
,
opType
)
;
if
(
kind
==
UnaryOperatorKind
.
POSTINC
||
kind
==
UnaryOperatorKind
.
POSTDEC
)
{
currentResult
=
prevExpr
;
}
break
;
default
:
throw
new
RuntimeException
(
"Unexpected unary operator"
)
;
}
currentResult
=
applyCasts
(
currentResult
,
operator
.
getType
(
)
,
operator
.
getTypeCasts
(
)
)
;
operator
.
putMetadata
(
"value"
,
currentResult
)
;
}
