/** 
 * Default Constructor for SpoonClassFileTransformer
 * @param classNameFilter Filter for classname. If classeNameFilter.test(className) returns false,the class will be loaded without decompilation nor transformation. If null, a default filter will filter out typical jvm classes (starting with java* or sun*) Note @{SpoonClassFileTransformer.defaultFilter} may be used in conjunction of custom filter with `defaultFilter.and(classNameFilter)`.
 * @param typeTransformer Transformation to apply on loaded types.
 * @param pathToDecompiled path to directory in which to put decompiled sources.
 * @param pathToCache path to cache directory for IncrementalLauncher
 * @param pathToRecompile path to recompiled classes
 * @param decompiler Decompiler to use on classFile before building Spoon model. If null, default compiler (cfr) will be used.
 */
public
SpoonClassFileTransformer
(
Predicate
<
String
>
classNameFilter
,
TypeTransformer
typeTransformer
,
String
pathToDecompiled
,
String
pathToCache
,
String
pathToRecompile
,
Decompiler
decompiler
)
{
if
(
classNameFilter
==
null
)
{
this
.
classNameFilter
=
defaultFilter
;
}
else
{
this
.
classNameFilter
=
classNameFilter
;
}
String
classPathSeparator
=
System
.
getProperty
(
"path.separator"
,
":"
)
;
String
[
]
classPathAr
=
System
.
getProperty
(
"java.class.path"
)
.
split
(
classPathSeparator
)
;
classPath
=
new
HashSet
<
>
(
Arrays
.
asList
(
classPathAr
)
)
;
this
.
pathToDecompiled
=
pathToDecompiled
;
recompileDir
=
new
File
(
pathToRecompile
)
;
cache
=
new
File
(
pathToCache
)
;
inputSources
=
new
HashSet
<
>
(
)
;
inputSources
.
add
(
new
File
(
pathToDecompiled
)
)
;
this
.
transformer
=
typeTransformer
;
if
(
decompiler
==
null
)
{
this
.
decompiler
=
new
CFRDecompiler
(
)
;
}
else
{
this
.
decompiler
=
decompiler
;
}
}
