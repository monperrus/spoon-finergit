/** 
 * checks that for all elements, the path can be obtained, parsed, and give the same element when evaluated 
 */
public
void
checkElementToPathToElementEquivalence
(
)
{
_rootPackage
.
getPackage
(
"spoon"
)
.
getElements
(
e
->
true
)
.
parallelStream
(
)
.
forEach
(
element
->
{
CtPath
path
=
element
.
getPath
(
)
;
String
pathStr
=
path
.
toString
(
)
;
try
{
CtPath
pathRead
=
new
CtPathStringBuilder
(
)
.
fromString
(
pathStr
)
;
assertEquals
(
pathStr
,
pathRead
.
toString
(
)
)
;
Collection
<
CtElement
>
returnedElements
=
pathRead
.
evaluateOn
(
_rootPackage
)
;
assertEquals
(
1
,
returnedElements
.
size
(
)
)
;
CtElement
actualElement
=
(
CtElement
)
returnedElements
.
toArray
(
)
[
0
]
;
assertSame
(
element
,
actualElement
)
;
}
catch
(
CtPathException
e
)
{
throw
new
AssertionError
(
"Path "
+
pathStr
+
" is either incorrectly generated or incorrectly read"
,
e
)
;
}
catch
(
AssertionError
e
)
{
throw
new
AssertionError
(
"Path "
+
pathStr
+
" detection failed on "
+
element
.
getClass
(
)
.
getSimpleName
(
)
+
": "
+
element
.
toString
(
)
,
e
)
;
}
}
)
;
}
