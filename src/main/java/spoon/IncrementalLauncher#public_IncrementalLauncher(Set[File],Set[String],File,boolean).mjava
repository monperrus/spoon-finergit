/** 
 * Creates a  {@link Launcher} for incremental build.
 * @param inputResources Resources to be parsed to build the spoon model.
 * @param sourceClasspath Source classpath of the spoon model.
 * @param cacheDirectory The directory to store all incremental information. If it's empty, full rebuild will be performed.
 * @param forceRebuild Force to perform full rebuild, ignoring incremental cache.
 * @throws IllegalArgumentException
 * @throws SpoonException
 */
public
IncrementalLauncher
(
Set
<
File
>
inputResources
,
Set
<
String
>
sourceClasspath
,
File
cacheDirectory
,
boolean
forceRebuild
)
{
if
(
cacheDirectory
==
null
)
{
throw
new
IllegalArgumentException
(
"unable to create incremental launcher with null cache directory"
)
;
}
mInputSources
=
getAllJavaFiles
(
inputResources
)
;
mSourceClasspath
=
new
HashSet
<
>
(
sourceClasspath
)
;
mIncrementalCacheDirectory
=
cacheDirectory
;
mModelFile
=
new
File
(
cacheDirectory
,
"model"
)
;
mCacheInfoFile
=
new
File
(
cacheDirectory
,
"cache-info"
)
;
mClassFilesDir
=
new
File
(
cacheDirectory
,
"class-files"
)
;
if
(
!
mIncrementalCacheDirectory
.
exists
(
)
||
!
mModelFile
.
exists
(
)
||
!
mCacheInfoFile
.
exists
(
)
||
!
mClassFilesDir
.
exists
(
)
)
{
forceRebuild
=
true
;
}
else
{
try
{
mCacheInfo
=
loadCacheInfo
(
mCacheInfoFile
)
;
}
catch
(
InvalidClassException
|
SpoonException
e
)
{
forceRebuild
=
true
;
}
}
if
(
!
mIncrementalCacheDirectory
.
exists
(
)
&&
!
mIncrementalCacheDirectory
.
mkdirs
(
)
)
{
throw
new
SpoonException
(
"unable to create cache directory"
)
;
}
if
(
!
mClassFilesDir
.
exists
(
)
&&
!
mClassFilesDir
.
mkdirs
(
)
)
{
throw
new
SpoonException
(
"unable to create class files directory"
)
;
}
if
(
forceRebuild
)
{
factory
=
createFactory
(
)
;
processArguments
(
)
;
mInputSources
.
forEach
(
f
->
addInputResource
(
f
.
getPath
(
)
)
)
;
mChangesPresent
=
true
;
setBinaryOutputDirectory
(
mClassFilesDir
)
;
}
else
{
Factory
oldFactory
=
loadFactory
(
mModelFile
)
;
oldFactory
.
getModel
(
)
.
setBuildModelIsFinished
(
false
)
;
mRemovedSources
=
new
HashSet
<
File
>
(
CollectionUtils
.
subtract
(
mCacheInfo
.
inputSourcesMap
.
keySet
(
)
,
mInputSources
)
)
;
mAddedSources
=
new
HashSet
<
File
>
(
CollectionUtils
.
subtract
(
mInputSources
,
mCacheInfo
.
inputSourcesMap
.
keySet
(
)
)
)
;
mCommonSources
=
new
HashSet
<
File
>
(
CollectionUtils
.
intersection
(
mCacheInfo
.
inputSourcesMap
.
keySet
(
)
,
mInputSources
)
)
;
Set
<
File
>
incrementalSources
=
new
HashSet
<
>
(
mAddedSources
)
;
for
(
File
e
:
mCommonSources
)
{
if
(
e
.
lastModified
(
)
>=
mCacheInfo
.
lastBuildTime
)
{
incrementalSources
.
add
(
e
)
;
}
}
List
<
CtType
<
?
>
>
oldTypes
=
oldFactory
.
Type
(
)
.
getAll
(
)
;
Set
<
CtType
<
?
>
>
changedTypes
=
new
HashSet
<
>
(
)
;
for
(
CtType
<
?
>
type
:
oldTypes
)
{
File
typeFile
=
type
.
getPosition
(
)
.
getFile
(
)
;
if
(
incrementalSources
.
contains
(
typeFile
)
)
{
changedTypes
.
add
(
type
)
;
}
}
for
(
CtType
<
?
>
type
:
oldTypes
)
{
File
typeFile
=
type
.
getPosition
(
)
.
getFile
(
)
;
if
(
mRemovedSources
.
contains
(
typeFile
)
)
{
type
.
delete
(
)
;
continue
;
}
for
(
CtType
<
?
>
changedType
:
changedTypes
)
{
if
(
type
.
getReferencedTypes
(
)
.
contains
(
changedType
.
getReference
(
)
)
)
{
incrementalSources
.
add
(
typeFile
)
;
type
.
delete
(
)
;
}
}
}
try
{
mSourceClasspath
.
add
(
mClassFilesDir
.
getCanonicalPath
(
)
)
;
}
catch
(
IOException
e2
)
{
throw
new
SpoonException
(
"unable to locate class files dir: "
+
mClassFilesDir
)
;
}
Collection
<
CtPackage
>
oldPackages
=
oldFactory
.
Package
(
)
.
getAll
(
)
;
for
(
CtPackage
pkg
:
oldPackages
)
{
if
(
pkg
.
getTypes
(
)
.
isEmpty
(
)
&&
pkg
.
getPackages
(
)
.
isEmpty
(
)
&&
!
pkg
.
isUnnamedPackage
(
)
)
{
pkg
.
delete
(
)
;
}
}
factory
=
oldFactory
;
processArguments
(
)
;
incrementalSources
.
forEach
(
f
->
addInputResource
(
f
.
getPath
(
)
)
)
;
mChangesPresent
=
!
mRemovedSources
.
isEmpty
(
)
||
!
mAddedSources
.
isEmpty
(
)
||
!
incrementalSources
.
isEmpty
(
)
;
setBinaryOutputDirectory
(
mClassFilesDir
)
;
}
getEnvironment
(
)
.
setSourceClasspath
(
mSourceClasspath
.
toArray
(
new
String
[
]
)
)
;
}
