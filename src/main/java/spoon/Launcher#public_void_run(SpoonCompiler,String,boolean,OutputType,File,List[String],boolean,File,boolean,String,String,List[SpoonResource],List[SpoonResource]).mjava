/** 
 * Runs Spoon using the given compiler, with the given run options. A Spoon run will perform the following tasks: <ol> <li>Pre-compilation (optional): {@link SpoonCompiler#compileInputSources()}.</li> <li>Source model building in the given compiler: {@link SpoonCompiler#build()}.</li> <li>Template model building in the given factory (if any template source is given):  {@link SpoonCompiler#build()}.</li> <li>Model processing with the list of given processors if any: {@link SpoonCompiler#process(List)}.</li> <li>Processed Source code printing and generation (can be disabled with {@link OutputType#NO_OUTPUT}): {@link SpoonCompiler#generateProcessedSourceFiles(OutputType)}.</li> <li>Processed source code compilation (optional): {@link SpoonCompiler#compile()}.</li> </ol>
 * @param compiler the compiler to be used, with a properly initialized factory and environment
 * @param encoding the encoding to be used (null to use the default system encoding)
 * @param precompile precompile the source code before processing to make sure that the input source classes will be available in the classpath
 * @param outputType sets type of source code output
 * @param outputDirectory the output directory of the generated source files
 * @param processorTypes the list of processors to be applied to the built model
 * @param compile compile the source code to bytecode once generated
 * @param destinationDirectory the destination directory of the compiled bytecode
 * @param buildOnlyOutdatedFiles build and compile the files that has been modified since the last build/compilation (requires  {@code !nooutput} and{@code compile} with a correctly set{@code destinationDirectory})
 * @param sourceClasspath the classpath to build and compile the input sources, given as a string
 * @param templateClasspath the classpath to build the template sources, given as a string
 * @param inputSources a list of resources containing the input sources
 * @param templateSources a list of resources containing the template sources (can contain zip or jar files)
 * @throws Exception in case something bad happens
 */
public
void
run
(
SpoonCompiler
compiler
,
String
encoding
,
boolean
precompile
,
OutputType
outputType
,
File
outputDirectory
,
List
<
String
>
processorTypes
,
boolean
compile
,
File
destinationDirectory
,
boolean
buildOnlyOutdatedFiles
,
String
sourceClasspath
,
String
templateClasspath
,
List
<
SpoonResource
>
inputSources
,
List
<
SpoonResource
>
templateSources
)
throws
Exception
{
Environment
env
=
compiler
.
getFactory
(
)
.
getEnvironment
(
)
;
env
.
reportProgressMessage
(
"running Spoon..."
)
;
if
(
env
.
isUsingSourceCodeFragments
(
)
)
{
env
.
reportProgressMessage
(
"running in 'fragments' mode: AST changes will be ignored"
)
;
}
env
.
reportProgressMessage
(
"start processing..."
)
;
long
t
=
System
.
currentTimeMillis
(
)
;
long
tstart
=
t
;
compiler
.
setBuildOnlyOutdatedFiles
(
outputType
!=
OutputType
.
NO_OUTPUT
&&
buildOnlyOutdatedFiles
)
;
compiler
.
setDestinationDirectory
(
destinationDirectory
)
;
compiler
.
setOutputDirectory
(
outputDirectory
)
;
if
(
sourceClasspath
!=
null
)
{
compiler
.
setSourceClasspath
(
sourceClasspath
.
split
(
System
.
getProperty
(
"path.separator"
)
)
)
;
}
compiler
.
setTemplateClasspath
(
templateClasspath
)
;
env
.
debugMessage
(
"output: "
+
compiler
.
getOutputDirectory
(
)
)
;
env
.
debugMessage
(
"destination: "
+
compiler
.
getDestinationDirectory
(
)
)
;
env
.
debugMessage
(
"source classpath: "
+
Arrays
.
toString
(
compiler
.
getSourceClasspath
(
)
)
)
;
env
.
debugMessage
(
"template classpath: "
+
Arrays
.
toString
(
compiler
.
getTemplateClasspath
(
)
)
)
;
try
{
for
(
SpoonResource
f
:
inputSources
)
{
env
.
debugMessage
(
"add input source: "
+
f
)
;
compiler
.
addInputSource
(
f
)
;
}
for
(
SpoonResource
f
:
templateSources
)
{
env
.
debugMessage
(
"add template source: "
+
f
)
;
compiler
.
addTemplateSource
(
f
)
;
}
}
catch
(
Exception
e
)
{
env
.
report
(
null
,
Severity
.
ERROR
,
"Error while loading resource : "
+
e
.
getMessage
(
)
)
;
if
(
env
.
isDebug
(
)
)
{
logger
.
debug
(
e
.
getMessage
(
)
,
e
)
;
}
}
if
(
precompile
)
{
t
=
System
.
currentTimeMillis
(
)
;
compiler
.
compileInputSources
(
)
;
env
.
debugMessage
(
"pre-compiled input sources in "
+
(
System
.
currentTimeMillis
(
)
-
t
)
+
" ms"
)
;
}
t
=
System
.
currentTimeMillis
(
)
;
compiler
.
build
(
)
;
env
.
debugMessage
(
"model built in "
+
(
System
.
currentTimeMillis
(
)
-
t
)
+
" ms"
)
;
t
=
System
.
currentTimeMillis
(
)
;
compiler
.
process
(
processorTypes
)
;
env
.
debugMessage
(
"model processed in "
+
(
System
.
currentTimeMillis
(
)
-
t
)
+
" ms"
)
;
t
=
System
.
currentTimeMillis
(
)
;
compiler
.
generateProcessedSourceFiles
(
outputType
)
;
env
.
debugMessage
(
"source generated in "
+
(
System
.
currentTimeMillis
(
)
-
t
)
+
" ms"
)
;
if
(
env
.
isCopyResources
(
)
)
{
t
=
System
.
currentTimeMillis
(
)
;
for
(
SpoonResource
dirInputSource
:
inputSources
)
{
if
(
dirInputSource
.
toFile
(
)
.
isDirectory
(
)
)
{
final
Collection
resources
=
FileUtils
.
listFiles
(
dirInputSource
.
toFile
(
)
,
RESOURCES_FILE_FILTER
,
ALL_DIR_FILTER
)
;
for
(
Object
resource
:
resources
)
{
final
String
resourceParentPath
=
(
(
File
)
resource
)
.
getParent
(
)
;
final
String
packageDir
=
resourceParentPath
.
substring
(
dirInputSource
.
getPath
(
)
.
length
(
)
)
;
final
String
targetDirectory
=
compiler
.
getOutputDirectory
(
)
+
packageDir
;
FileUtils
.
copyFileToDirectory
(
(
File
)
resource
,
new
File
(
targetDirectory
)
)
;
}
}
}
env
.
debugMessage
(
"resources generated in "
+
(
System
.
currentTimeMillis
(
)
-
t
)
+
" ms"
)
;
}
t
=
System
.
currentTimeMillis
(
)
;
if
(
compile
)
{
compiler
.
compile
(
)
;
env
.
debugMessage
(
"generated bytecode in "
+
(
System
.
currentTimeMillis
(
)
-
t
)
+
" ms"
)
;
}
t
=
System
.
currentTimeMillis
(
)
;
env
.
debugMessage
(
"program spooning done in "
+
(
t
-
tstart
)
+
" ms"
)
;
env
.
reportEnd
(
)
;
}
