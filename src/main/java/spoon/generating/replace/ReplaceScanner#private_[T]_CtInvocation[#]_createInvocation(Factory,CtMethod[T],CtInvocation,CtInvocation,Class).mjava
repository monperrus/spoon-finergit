private
<
T
>
CtInvocation
<
?
>
createInvocation
(
Factory
factory
,
CtMethod
<
T
>
candidate
,
CtInvocation
current
,
CtInvocation
getter
,
Class
getterTypeClass
)
{
CtInvocation
<
?
>
invocation
;
Type
type
;
if
(
getterTypeClass
.
equals
(
Collection
.
class
)
||
getterTypeClass
.
equals
(
List
.
class
)
)
{
invocation
=
factory
.
Code
(
)
.
createInvocation
(
null
,
this
.
list
,
current
.
getArguments
(
)
)
;
type
=
Type
.
LIST
;
}
else
if
(
getterTypeClass
.
equals
(
Map
.
class
)
)
{
invocation
=
factory
.
Code
(
)
.
createInvocation
(
null
,
this
.
map
,
current
.
getArguments
(
)
)
;
type
=
Type
.
MAP
;
}
else
if
(
getterTypeClass
.
equals
(
Set
.
class
)
)
{
invocation
=
factory
.
Code
(
)
.
createInvocation
(
null
,
this
.
set
,
current
.
getArguments
(
)
)
;
type
=
Type
.
SET
;
}
else
{
invocation
=
factory
.
Code
(
)
.
createInvocation
(
null
,
this
.
element
,
current
.
getArguments
(
)
)
;
type
=
Type
.
ELEMENT
;
}
final
String
name
=
getter
.
getExecutable
(
)
.
getSimpleName
(
)
.
substring
(
3
)
;
final
String
listenerName
=
getter
.
getExecutable
(
)
.
getDeclaringType
(
)
.
getSimpleName
(
)
+
name
+
"ReplaceListener"
;
CtClass
listener
;
if
(
listeners
.
containsKey
(
listenerName
)
)
{
listener
=
listeners
.
get
(
listenerName
)
;
}
else
{
final
CtTypeReference
getterType
=
getGetterType
(
factory
,
getter
)
;
listener
=
createListenerClass
(
factory
,
listenerName
,
getterType
,
type
)
;
final
CtMethod
setter
=
getSetter
(
name
,
getter
.
getTarget
(
)
.
getType
(
)
.
getDeclaration
(
)
)
;
final
CtField
field
=
updateField
(
listener
,
setter
.
getDeclaringType
(
)
.
getReference
(
)
)
;
updateConstructor
(
listener
,
setter
.
getDeclaringType
(
)
.
getReference
(
)
)
;
updateSetter
(
factory
,
(
CtMethod
<
?
>
)
listener
.
getMethodsByName
(
"set"
)
.
get
(
0
)
,
getterType
,
field
,
setter
)
;
listeners
.
put
(
listenerName
,
listener
)
;
}
invocation
.
addArgument
(
getConstructorCall
(
listener
,
factory
.
Code
(
)
.
createVariableRead
(
candidate
.
getParameters
(
)
.
get
(
0
)
.
getReference
(
)
,
false
)
)
)
;
return
invocation
;
}
