private
void
handleConflict
(
ConflictResolutionMode
conflictMode
,
RootNode
oldNode
,
RootNode
newNode
,
Consumer
<
RootNode
>
applyNewNode
)
{
if
(
oldNode
!=
newNode
)
{
if
(
conflictMode
==
ConflictResolutionMode
.
APPEND
)
{
if
(
oldNode
instanceof
ListOfNodes
==
false
)
{
oldNode
=
new
ListOfNodes
(
new
ArrayList
<
>
(
Arrays
.
asList
(
oldNode
)
)
)
;
}
if
(
newNode
instanceof
ListOfNodes
)
{
(
(
ListOfNodes
)
oldNode
)
.
getNodes
(
)
.
addAll
(
(
(
ListOfNodes
)
newNode
)
.
getNodes
(
)
)
;
}
else
{
(
(
ListOfNodes
)
oldNode
)
.
getNodes
(
)
.
add
(
newNode
)
;
}
explicitNodes
.
add
(
oldNode
)
;
explicitNodes
.
add
(
newNode
)
;
applyNewNode
.
accept
(
oldNode
)
;
return
;
}
if
(
explicitNodes
.
contains
(
oldNode
)
)
{
if
(
conflictMode
==
ConflictResolutionMode
.
FAIL
)
{
throw
new
SpoonException
(
"Can't replace once assigned Node "
+
oldNode
+
" by a "
+
newNode
)
;
}
if
(
conflictMode
==
ConflictResolutionMode
.
KEEP_OLD_NODE
)
{
return
;
}
}
explicitNodes
.
remove
(
oldNode
)
;
explicitNodes
.
add
(
newNode
)
;
applyNewNode
.
accept
(
newNode
)
;
}
}
