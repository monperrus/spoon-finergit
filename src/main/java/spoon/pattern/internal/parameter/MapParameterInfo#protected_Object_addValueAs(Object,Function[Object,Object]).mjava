@Override
protected
Object
addValueAs
(
Object
container
,
Function
<
Object
,
Object
>
merger
)
{
ImmutableMap
parameters
=
castTo
(
container
,
ImmutableMap
.
class
)
;
if
(
name
==
null
)
{
Object
newValue
=
merger
.
apply
(
null
)
;
if
(
newValue
==
null
)
{
return
parameters
;
}
if
(
newValue
==
NO_MERGE
)
{
return
NO_MERGE
;
}
if
(
newValue
instanceof
Map
.
Entry
<
?
,
?
>
)
{
Map
.
Entry
<
?
,
?
>
newEntry
=
(
Map
.
Entry
<
?
,
?
>
)
newValue
;
String
newEntryKey
=
(
String
)
newEntry
.
getKey
(
)
;
Object
existingValue
=
parameters
.
getValue
(
newEntryKey
)
;
Object
newEntryValue
=
merge
(
existingValue
,
newEntry
.
getValue
(
)
)
;
if
(
newEntryValue
==
NO_MERGE
)
{
return
NO_MERGE
;
}
if
(
existingValue
==
newEntryValue
)
{
return
parameters
;
}
return
parameters
.
putValue
(
newEntryKey
,
newEntryValue
)
;
}
if
(
newValue
instanceof
Map
)
{
Map
<
String
,
Object
>
newMap
=
(
Map
)
newValue
;
for
(
Map
.
Entry
<
String
,
Object
>
newEntry
:
newMap
.
entrySet
(
)
)
{
String
newEntryKey
=
newEntry
.
getKey
(
)
;
Object
existingValue
=
parameters
.
getValue
(
newEntryKey
)
;
Object
newEntryValue
=
merge
(
existingValue
,
newEntry
.
getValue
(
)
)
;
if
(
newEntryValue
==
NO_MERGE
)
{
return
NO_MERGE
;
}
if
(
existingValue
!=
newEntryValue
)
{
parameters
=
parameters
.
putValue
(
newEntryKey
,
newEntryValue
)
;
}
}
return
parameters
;
}
return
NO_MERGE
;
}
Object
existingValue
=
parameters
.
getValue
(
name
)
;
Object
newValue
=
merger
.
apply
(
existingValue
)
;
if
(
newValue
==
NO_MERGE
)
{
return
NO_MERGE
;
}
if
(
existingValue
==
newValue
)
{
return
parameters
;
}
return
parameters
.
putValue
(
name
,
newValue
)
;
}
