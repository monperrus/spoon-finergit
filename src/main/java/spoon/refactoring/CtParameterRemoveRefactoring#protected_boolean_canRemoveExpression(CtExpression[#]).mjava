/** 
 * Detects whether `toBeRemovedExpression` can be safely removed during the refactoring
 * @param toBeRemovedExpression the {@link CtExpression}, which will be removed by this refactoring
 * @return true if the expression used to deliver argument of removed parameter can be removedfalse if cannot be removed and this refactoring has to be avoided.
 */
protected
boolean
canRemoveExpression
(
CtExpression
<
?
>
toBeRemovedExpression
)
{
class
Context
{
boolean
canBeRemoved
=
false
;
}
final
Context
context
=
new
Context
(
)
;
toBeRemovedExpression
.
accept
(
new
CtAbstractVisitor
(
)
{
@Override
public
<
T
>
void
visitCtVariableRead
(
CtVariableRead
<
T
>
variableRead
)
{
context
.
canBeRemoved
=
true
;
}
@Override
public
<
T
>
void
visitCtArrayRead
(
CtArrayRead
<
T
>
arrayRead
)
{
context
.
canBeRemoved
=
true
;
}
@Override
public
<
T
>
void
visitCtFieldRead
(
CtFieldRead
<
T
>
fieldRead
)
{
context
.
canBeRemoved
=
true
;
}
@Override
public
<
T
>
void
visitCtParameterReference
(
CtParameterReference
<
T
>
reference
)
{
context
.
canBeRemoved
=
true
;
}
@Override
public
<
T
>
void
visitCtLiteral
(
CtLiteral
<
T
>
literal
)
{
context
.
canBeRemoved
=
true
;
}
@Override
public
<
T
>
void
visitCtNewArray
(
CtNewArray
<
T
>
newArray
)
{
context
.
canBeRemoved
=
true
;
}
@Override
public
<
T
>
void
visitCtAnnotationFieldAccess
(
CtAnnotationFieldAccess
<
T
>
annotationFieldAccess
)
{
context
.
canBeRemoved
=
true
;
}
@Override
public
<
T
>
void
visitCtThisAccess
(
CtThisAccess
<
T
>
thisAccess
)
{
context
.
canBeRemoved
=
true
;
}
}
)
;
return
context
.
canBeRemoved
;
}
