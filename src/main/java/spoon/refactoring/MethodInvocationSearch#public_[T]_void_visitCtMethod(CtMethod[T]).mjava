@Override
public
<
T
>
void
visitCtMethod
(
CtMethod
<
T
>
method
)
{
if
(
!
method
.
getPosition
(
)
.
isValidPosition
(
)
)
{
return
;
}
final
CtExecutable
<
?
>
transformedMethod
;
if
(
method
instanceof
CtLambda
)
{
transformedMethod
=
method
.
getParent
(
CtExecutable
.
class
)
;
}
else
{
transformedMethod
=
method
;
}
List
<
CtInvocation
<
?
>
>
invocations
=
method
.
getElements
(
new
TypeFilter
<
>
(
CtInvocation
.
class
)
)
;
List
<
CtConstructorCall
<
?
>
>
constructors
=
method
.
getElements
(
new
TypeFilter
<
>
(
CtConstructorCall
.
class
)
)
;
if
(
!
invocationsOfMethod
.
containsKey
(
method
)
&&
!
method
.
isImplicit
(
)
&&
!
(
method
instanceof
CtLambdaImpl
)
)
{
invocationsOfMethod
.
put
(
method
,
Collections
.
emptyList
(
)
)
;
}
invocations
.
stream
(
)
.
filter
(
v
->
!
v
.
isImplicit
(
)
)
.
map
(
v
->
v
.
getExecutable
(
)
.
getExecutableDeclaration
(
)
)
.
filter
(
Objects
::
nonNull
)
.
filter
(
v
->
v
.
getPosition
(
)
.
isValidPosition
(
)
)
.
forEach
(
v
->
invocationsOfMethod
.
merge
(
v
,
new
HashSet
<
>
(
Arrays
.
asList
(
transformedMethod
)
)
,
(
o1
,
o2
)
->
Stream
.
concat
(
o1
.
stream
(
)
,
o2
.
stream
(
)
)
.
collect
(
Collectors
.
toCollection
(
HashSet
::
new
)
)
)
)
;
constructors
.
stream
(
)
.
filter
(
v
->
!
v
.
isImplicit
(
)
)
.
map
(
v
->
v
.
getExecutable
(
)
.
getExecutableDeclaration
(
)
)
.
filter
(
Objects
::
nonNull
)
.
forEach
(
v
->
invocationsOfMethod
.
merge
(
v
,
new
HashSet
<
>
(
Arrays
.
asList
(
transformedMethod
)
)
,
(
o1
,
o2
)
->
Stream
.
concat
(
o1
.
stream
(
)
,
o2
.
stream
(
)
)
.
collect
(
Collectors
.
toCollection
(
HashSet
::
new
)
)
)
)
;
super
.
visitCtMethod
(
method
)
;
}
