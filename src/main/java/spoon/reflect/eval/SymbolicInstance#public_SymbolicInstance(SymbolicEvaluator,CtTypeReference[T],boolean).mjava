/** 
 * Creates a new abstract instance (logical value).
 * @param evaluator the evaluator
 * @param concreteType the type of the instance
 * @param isType tells if it is a type instance or a regular instance
 */
public
SymbolicInstance
(
SymbolicEvaluator
evaluator
,
CtTypeReference
<
T
>
concreteType
,
boolean
isType
)
{
this
.
concreteType
=
concreteType
;
CtSimpleType
<
T
>
type
=
concreteType
.
getDeclaration
(
)
;
if
(
!
concreteType
.
isPrimitive
(
)
&&
type
!=
null
)
{
for
(
CtFieldReference
<
?
>
fr
:
concreteType
.
getAllFields
(
)
)
{
CtField
<
?
>
f
=
fr
.
getDeclaration
(
)
;
if
(
f
==
null
)
continue
;
if
(
isType
&&
f
.
hasModifier
(
ModifierKind
.
STATIC
)
)
{
SymbolicInstance
<
?
>
r
=
evaluator
.
evaluate
(
f
.
getDefaultExpression
(
)
)
;
fields
.
put
(
fr
,
r
==
null
?
null
:
r
.
getId
(
)
)
;
}
if
(
!
isType
&&
!
f
.
hasModifier
(
ModifierKind
.
STATIC
)
)
{
SymbolicInstance
<
?
>
r
=
evaluator
.
evaluate
(
f
.
getDefaultExpression
(
)
)
;
fields
.
put
(
fr
,
r
==
null
?
null
:
r
.
getId
(
)
)
;
}
}
}
else
{
isExternal
=
true
;
if
(
!
isType
)
{
for
(
CtTypeReference
<
?
>
t
:
evaluator
.
getStatefullExternals
(
)
)
{
if
(
t
.
isAssignableFrom
(
concreteType
)
)
{
for
(
Method
m
:
RtHelper
.
getAllMethods
(
concreteType
.
getActualClass
(
)
)
)
{
if
(
m
.
getName
(
)
.
startsWith
(
"get"
)
&&
m
.
getParameterTypes
(
)
.
length
==
0
)
{
CtFieldReference
<
?
>
f
=
concreteType
.
getFactory
(
)
.
Field
(
)
.
createReference
(
concreteType
,
concreteType
.
getFactory
(
)
.
Type
(
)
.
createReference
(
m
.
getReturnType
(
)
)
,
m
.
getName
(
)
.
substring
(
3
)
)
;
fields
.
put
(
f
,
null
)
;
}
}
}
}
}
}
if
(
isType
)
{
this
.
symbolName
=
"type"
;
}
else
{
this
.
symbolName
=
""
+
getNextId
(
)
;
}
}
