/** 
 * Gets the symbolic evaluation paths of the program, as calculated by {@link spoon.reflect.eval.SymbolicEvaluator}.
 * @param entryPoints the entry point methods
 * @return a map containing the paths for each entry point
 */
@SuppressWarnings("unchecked")
public
void
evaluate
(
Collection
<
CtMethod
<
Void
>
>
entryPoints
,
SymbolicEvaluatorObserver
...
observers
)
{
for
(
CtMethod
<
?
>
m
:
entryPoints
)
{
SymbolicEvaluator
evaluator
=
createSymbolicEvaluator
(
)
;
evaluator
.
addObservers
(
Arrays
.
asList
(
observers
)
)
;
List
<
SymbolicInstance
<
?
>
>
args
=
new
ArrayList
<
SymbolicInstance
<
?
>
>
(
)
;
for
(
CtParameter
<
?
>
p
:
m
.
getParameters
(
)
)
{
SymbolicInstance
arg
=
createSymbolicInstance
(
evaluator
,
p
.
getType
(
)
,
false
)
;
evaluator
.
getHeap
(
)
.
store
(
arg
)
;
args
.
add
(
arg
)
;
}
SymbolicInstance
target
=
createSymbolicInstance
(
evaluator
,
m
.
getDeclaringType
(
)
.
getReference
(
)
,
m
.
getModifiers
(
)
.
contains
(
ModifierKind
.
STATIC
)
)
;
CtType
<
?
>
targetType
=
m
.
getDeclaringType
(
)
;
for
(
CtField
field
:
targetType
.
getFields
(
)
)
{
if
(
!
field
.
getModifiers
(
)
.
contains
(
ModifierKind
.
STATIC
)
&&
m
.
getModifiers
(
)
.
contains
(
ModifierKind
.
STATIC
)
)
{
continue
;
}
CtVariableReference
<
?
>
fref
=
field
.
getReference
(
)
;
SymbolicInstance
si
=
createSymbolicInstance
(
evaluator
,
fref
.
getType
(
)
,
false
)
;
target
.
setFieldValue
(
evaluator
.
getHeap
(
)
,
fref
,
si
)
;
}
evaluator
.
getHeap
(
)
.
store
(
target
)
;
try
{
evaluator
.
invoke
(
target
,
m
,
args
)
;
}
catch
(
Throwable
th
)
{
th
.
printStackTrace
(
)
;
}
}
}
