/** 
 * Gets a created type from its qualified name if source in the source classpath. `TypeFactory#get(String)` returns null if the class is not in the source classpath (even if it is in the binary classpath). `TypeFactory#get(Class)` returns null if the class is neither in the source classpath nor in the binary classpath, and returns a [shadow class](http://spoon.gforge.inria.fr/reflection.html) if it is only in the binary classpath. Note that a shadow class has empty method bodies, if you need a shadow class with method bodies, see [spoon-decompiler](https://github.com/INRIA/spoon/tree/master/spoon-decompiler))
 * @return a type if source in the source classpath or null if does not exist
 */
@SuppressWarnings("unchecked")
public
<
T
>
CtType
<
T
>
get
(
final
String
qualifiedName
)
{
int
packageIndex
=
qualifiedName
.
lastIndexOf
(
CtPackage
.
PACKAGE_SEPARATOR
)
;
CtPackage
pack
;
if
(
packageIndex
>
0
)
{
pack
=
factory
.
Package
(
)
.
get
(
qualifiedName
.
substring
(
0
,
packageIndex
)
)
;
}
else
{
pack
=
factory
.
Package
(
)
.
getRootPackage
(
)
;
}
if
(
pack
!=
null
)
{
CtType
<
T
>
type
=
pack
.
getType
(
qualifiedName
.
substring
(
packageIndex
+
1
)
)
;
if
(
type
!=
null
)
{
return
type
;
}
}
int
inertTypeIndex
=
qualifiedName
.
lastIndexOf
(
CtType
.
INNERTTYPE_SEPARATOR
)
;
if
(
inertTypeIndex
>
0
)
{
String
s
=
qualifiedName
.
substring
(
0
,
inertTypeIndex
)
;
CtType
<
T
>
t
=
factory
.
Type
(
)
.
get
(
s
)
;
if
(
t
==
null
)
{
return
null
;
}
String
className
=
qualifiedName
.
substring
(
inertTypeIndex
+
1
)
;
final
CtTypeReference
<
T
>
reference
=
t
.
getReference
(
)
;
if
(
reference
.
isLocalType
(
)
)
{
final
List
<
CtClass
<
T
>
>
enclosingClasses
=
t
.
getElements
(
new
TypeFilter
<
CtClass
<
T
>
>
(
CtClass
.
class
)
{
@Override
public
boolean
matches
(
CtClass
<
T
>
element
)
{
return
super
.
matches
(
element
)
&&
element
.
getQualifiedName
(
)
.
equals
(
qualifiedName
)
;
}
}
)
;
if
(
enclosingClasses
.
isEmpty
(
)
)
{
return
null
;
}
return
enclosingClasses
.
get
(
0
)
;
}
if
(
isNumber
(
className
)
)
{
return
getFromCache
(
t
,
className
,
(
)
->
{
Integer
.
parseInt
(
className
)
;
final
List
<
CtNewClass
>
anonymousClasses
=
t
.
getElements
(
new
TypeFilter
<
CtNewClass
>
(
CtNewClass
.
class
)
{
@Override
public
boolean
matches
(
CtNewClass
element
)
{
return
super
.
matches
(
element
)
&&
element
.
getAnonymousClass
(
)
.
getQualifiedName
(
)
.
equals
(
qualifiedName
)
;
}
}
)
;
if
(
anonymousClasses
.
isEmpty
(
)
)
{
return
null
;
}
return
anonymousClasses
.
get
(
0
)
.
getAnonymousClass
(
)
;
}
)
;
}
else
{
return
t
.
getNestedType
(
className
)
;
}
}
return
null
;
}
