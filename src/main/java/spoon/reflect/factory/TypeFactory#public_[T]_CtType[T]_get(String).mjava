/** 
 * Gets a created type from its qualified name.
 * @return a found type or null if does not exist
 */
@SuppressWarnings("unchecked")
public
<
T
>
CtType
<
T
>
get
(
final
String
qualifiedName
)
{
int
inertTypeIndex
=
qualifiedName
.
lastIndexOf
(
CtType
.
INNERTTYPE_SEPARATOR
)
;
if
(
inertTypeIndex
>
0
)
{
String
s
=
qualifiedName
.
substring
(
0
,
inertTypeIndex
)
;
CtType
<
T
>
t
=
factory
.
Type
(
)
.
get
(
s
)
;
if
(
t
==
null
)
{
return
null
;
}
String
className
=
qualifiedName
.
substring
(
inertTypeIndex
+
1
)
;
final
CtTypeReference
<
T
>
reference
=
t
.
getReference
(
)
;
if
(
reference
.
isLocalType
(
)
)
{
final
List
<
CtClass
<
T
>
>
enclosingClasses
=
t
.
getElements
(
new
TypeFilter
<
CtClass
<
T
>
>
(
CtClass
.
class
)
{
@Override
public
boolean
matches
(
CtClass
<
T
>
element
)
{
return
super
.
matches
(
element
)
&&
element
.
getQualifiedName
(
)
.
equals
(
qualifiedName
)
;
}
}
)
;
if
(
enclosingClasses
.
size
(
)
==
0
)
{
return
null
;
}
return
enclosingClasses
.
get
(
0
)
;
}
try
{
Integer
.
parseInt
(
className
)
;
final
List
<
CtNewClass
>
anonymousClasses
=
t
.
getElements
(
new
TypeFilter
<
CtNewClass
>
(
CtNewClass
.
class
)
{
@Override
public
boolean
matches
(
CtNewClass
element
)
{
return
super
.
matches
(
element
)
&&
element
.
getAnonymousClass
(
)
.
getQualifiedName
(
)
.
equals
(
qualifiedName
)
;
}
}
)
;
if
(
anonymousClasses
.
size
(
)
==
0
)
{
return
null
;
}
return
anonymousClasses
.
get
(
0
)
.
getAnonymousClass
(
)
;
}
catch
(
NumberFormatException
e
)
{
return
t
.
getNestedType
(
className
)
;
}
}
int
packageIndex
=
qualifiedName
.
lastIndexOf
(
CtPackage
.
PACKAGE_SEPARATOR
)
;
CtPackage
pack
;
if
(
packageIndex
>
0
)
{
pack
=
factory
.
Package
(
)
.
get
(
qualifiedName
.
substring
(
0
,
packageIndex
)
)
;
}
else
{
pack
=
factory
.
Package
(
)
.
getRootPackage
(
)
;
}
if
(
pack
==
null
)
{
return
null
;
}
return
(
CtType
<
T
>
)
pack
.
getType
(
qualifiedName
.
substring
(
packageIndex
+
1
)
)
;
}
