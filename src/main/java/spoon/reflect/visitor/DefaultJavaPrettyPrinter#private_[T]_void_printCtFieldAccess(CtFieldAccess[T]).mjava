private
<
T
>
void
printCtFieldAccess
(
CtFieldAccess
<
T
>
f
)
{
enterCtExpression
(
f
)
;
try
(
Writable
_context
=
context
.
modify
(
)
)
{
if
(
f
.
getVariable
(
)
.
isStatic
(
)
&&
f
.
getTarget
(
)
instanceof
CtTypeAccess
)
{
_context
.
ignoreGenerics
(
true
)
;
}
CtExpression
<
?
>
target
=
f
.
getTarget
(
)
;
if
(
target
!=
null
)
{
boolean
isInitializeStaticFinalField
=
isInitializeStaticFinalField
(
f
.
getTarget
(
)
)
;
boolean
isStaticField
=
f
.
getVariable
(
)
.
isStatic
(
)
;
boolean
isImportedField
=
importsContext
.
isImported
(
f
.
getVariable
(
)
)
;
if
(
!
isInitializeStaticFinalField
&&
!
(
isStaticField
&&
isImportedField
)
)
{
if
(
target
.
isImplicit
(
)
&&
!
(
f
.
getVariable
(
)
.
getFieldDeclaration
(
)
==
null
&&
this
.
env
.
getNoClasspath
(
)
)
)
{
final
CtField
<
?
>
field
=
f
.
getVariable
(
)
.
getFieldDeclaration
(
)
;
if
(
field
==
null
)
{
throw
new
SpoonException
(
"The reference to field named \""
+
f
.
getVariable
(
)
.
getSimpleName
(
)
+
"\" is invalid, because there is no field with such name on path:"
+
getPath
(
f
)
)
;
}
final
String
fieldName
=
field
.
getSimpleName
(
)
;
CtVariable
<
?
>
var
=
f
.
getVariable
(
)
.
map
(
new
PotentialVariableDeclarationFunction
(
fieldName
)
)
.
first
(
)
;
if
(
var
!=
field
)
{
target
.
setImplicit
(
false
)
;
}
}
printer
.
snapshotLength
(
)
;
scan
(
target
)
;
if
(
printer
.
hasNewContent
(
)
)
{
printer
.
write
(
"."
)
;
}
}
_context
.
ignoreStaticAccess
(
true
)
;
}
scan
(
f
.
getVariable
(
)
)
;
}
exitCtExpression
(
f
)
;
}
