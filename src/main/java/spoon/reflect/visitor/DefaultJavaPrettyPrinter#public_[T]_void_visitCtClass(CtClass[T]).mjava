public
<
T
>
void
visitCtClass
(
CtClass
<
T
>
ctClass
)
{
SortedList
<
CtElement
>
lst
=
new
SortedList
<
>
(
new
CtLineElementComparator
(
)
)
;
if
(
ctClass
.
getSimpleName
(
)
!=
null
&&
!
CtType
.
NAME_UNKNOWN
.
equals
(
ctClass
.
getSimpleName
(
)
)
&&
!
ctClass
.
isAnonymous
(
)
)
{
visitCtType
(
ctClass
)
;
if
(
ctClass
.
isLocalType
(
)
)
{
write
(
"class "
+
ctClass
.
getSimpleName
(
)
.
replaceAll
(
"^[0-9]*"
,
""
)
)
;
}
else
{
write
(
"class "
+
ctClass
.
getSimpleName
(
)
)
;
}
writeFormalTypeParameters
(
ctClass
.
getFormalTypeParameters
(
)
)
;
writeExtendsClause
(
ctClass
)
;
writeImplementsClause
(
ctClass
)
;
for
(
CtConstructor
<
T
>
c
:
ctClass
.
getConstructors
(
)
)
{
if
(
!
c
.
isImplicit
(
)
)
{
lst
.
add
(
c
)
;
}
}
}
lst
.
addAll
(
ctClass
.
getAnonymousExecutables
(
)
)
;
lst
.
addAll
(
ctClass
.
getNestedTypes
(
)
)
;
lst
.
addAll
(
ctClass
.
getFields
(
)
)
;
lst
.
addAll
(
ctClass
.
getMethods
(
)
)
;
lst
.
addAll
(
getComments
(
ctClass
,
CommentOffset
.
INSIDE
)
)
;
CtElement
parent
;
try
{
parent
=
ctClass
.
getParent
(
)
;
}
catch
(
ParentNotInitializedException
e
)
{
parent
=
null
;
}
if
(
(
ctClass
.
getSimpleName
(
)
==
null
||
ctClass
.
getSimpleName
(
)
.
isEmpty
(
)
)
&&
parent
!=
null
&&
parent
instanceof
CtNewClass
)
{
context
.
currentThis
.
push
(
(
(
CtNewClass
<
?
>
)
parent
)
.
getType
(
)
)
;
}
else
{
context
.
currentThis
.
push
(
ctClass
.
getReference
(
)
)
;
}
write
(
" {"
)
.
incTab
(
)
;
for
(
CtElement
el
:
lst
)
{
writeln
(
)
.
writeTabs
(
)
.
scan
(
el
)
;
if
(
!
env
.
isPreserveLineNumbers
(
)
)
{
writeln
(
)
;
}
}
decTab
(
)
.
writeTabs
(
)
.
write
(
"}"
)
;
context
.
currentThis
.
pop
(
)
;
}
