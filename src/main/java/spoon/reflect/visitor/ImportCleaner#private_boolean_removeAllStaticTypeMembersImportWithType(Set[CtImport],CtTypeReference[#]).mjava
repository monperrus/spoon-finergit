/** 
 * removes all static type member imports with the same type from `imports`
 * @return true if at least one import with the same type exists
 */
private
boolean
removeAllStaticTypeMembersImportWithType
(
Set
<
CtImport
>
imports
,
CtTypeReference
<
?
>
typeRef
)
{
ClassTypingContext
contextOfTypeRef
=
new
ClassTypingContext
(
typeRef
)
;
Iterator
<
CtImport
>
iter
=
imports
.
iterator
(
)
;
class
Visitor
extends
CtAbstractImportVisitor
{
boolean
found
=
false
;
@Override
public
<
T
>
void
visitFieldImport
(
CtFieldReference
<
T
>
fieldReference
)
{
checkType
(
fieldReference
.
getDeclaringType
(
)
)
;
}
@Override
public
<
T
>
void
visitMethodImport
(
CtExecutableReference
<
T
>
executableReference
)
{
checkType
(
executableReference
.
getDeclaringType
(
)
)
;
}
void
checkType
(
CtTypeReference
<
?
>
importTypeRef
)
{
if
(
contextOfTypeRef
.
isSubtypeOf
(
importTypeRef
)
)
{
found
=
true
;
if
(
canRemoveImports
)
{
iter
.
remove
(
)
;
}
}
}
}
Visitor
visitor
=
new
Visitor
(
)
;
while
(
iter
.
hasNext
(
)
)
{
iter
.
next
(
)
.
accept
(
visitor
)
;
}
return
visitor
.
found
;
}
