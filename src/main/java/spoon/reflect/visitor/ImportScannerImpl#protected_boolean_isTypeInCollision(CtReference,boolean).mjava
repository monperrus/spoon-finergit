/** 
 * Test if the reference can be imported, i.e. test if the importation could lead to a collision.
 * @param ref
 * @return true if the ref should be imported.
 */
protected
boolean
isTypeInCollision
(
CtReference
ref
,
boolean
fqnMode
)
{
if
(
targetType
!=
null
&&
targetType
.
getSimpleName
(
)
.
equals
(
ref
.
getSimpleName
(
)
)
&&
!
targetType
.
equals
(
ref
)
)
{
return
true
;
}
try
{
CtElement
parent
;
if
(
ref
instanceof
CtTypeReference
)
{
parent
=
ref
.
getParent
(
)
;
}
else
{
parent
=
ref
;
}
if
(
parent
instanceof
CtLiteral
)
{
return
false
;
}
Set
<
String
>
localVariablesOfBlock
=
new
HashSet
<
>
(
)
;
if
(
parent
instanceof
CtField
)
{
this
.
fieldAndMethodsNames
.
add
(
(
(
CtField
)
parent
)
.
getSimpleName
(
)
)
;
}
else
if
(
parent
instanceof
CtMethod
)
{
this
.
fieldAndMethodsNames
.
add
(
(
(
CtMethod
)
parent
)
.
getSimpleName
(
)
)
;
}
else
{
localVariablesOfBlock
=
this
.
lookForLocalVariables
(
parent
)
;
}
while
(
!
(
parent
instanceof
CtPackage
)
)
{
if
(
(
parent
instanceof
CtFieldReference
)
||
(
parent
instanceof
CtExecutableReference
)
||
(
parent
instanceof
CtInvocation
)
)
{
CtReference
parentType
;
if
(
parent
instanceof
CtInvocation
)
{
parentType
=
(
(
CtInvocation
)
parent
)
.
getExecutable
(
)
;
}
else
{
parentType
=
(
CtReference
)
parent
;
}
LinkedList
<
String
>
qualifiedNameTokens
=
new
LinkedList
<
>
(
)
;
if
(
parentType
!=
parent
)
{
qualifiedNameTokens
.
add
(
parentType
.
getSimpleName
(
)
)
;
}
CtTypeReference
typeReference
;
if
(
parent
instanceof
CtFieldReference
)
{
typeReference
=
(
(
CtFieldReference
)
parent
)
.
getDeclaringType
(
)
;
}
else
if
(
parent
instanceof
CtExecutableReference
)
{
typeReference
=
(
(
CtExecutableReference
)
parent
)
.
getDeclaringType
(
)
;
}
else
{
typeReference
=
(
(
CtInvocation
)
parent
)
.
getExecutable
(
)
.
getDeclaringType
(
)
;
}
if
(
typeReference
!=
null
)
{
qualifiedNameTokens
.
addFirst
(
typeReference
.
getSimpleName
(
)
)
;
if
(
typeReference
.
getPackage
(
)
!=
null
)
{
StringTokenizer
token
=
new
StringTokenizer
(
typeReference
.
getPackage
(
)
.
getSimpleName
(
)
,
CtPackage
.
PACKAGE_SEPARATOR
)
;
int
index
=
0
;
while
(
token
.
hasMoreElements
(
)
)
{
qualifiedNameTokens
.
add
(
index
,
token
.
nextToken
(
)
)
;
index
++
;
}
}
}
if
(
!
qualifiedNameTokens
.
isEmpty
(
)
)
{
if
(
fieldAndMethodsNames
.
contains
(
qualifiedNameTokens
.
getFirst
(
)
)
||
localVariablesOfBlock
.
contains
(
qualifiedNameTokens
.
getFirst
(
)
)
)
{
qualifiedNameTokens
.
removeFirst
(
)
;
if
(
fqnMode
)
{
if
(
ref
instanceof
CtTypeReference
)
{
if
(
qualifiedNameTokens
.
isEmpty
(
)
)
{
return
true
;
}
for
(
int
i
=
0
;
i
<
qualifiedNameTokens
.
size
(
)
;
i
++
)
{
String
testedToken
=
qualifiedNameTokens
.
get
(
i
)
;
if
(
!
fieldAndMethodsNames
.
contains
(
testedToken
)
&&
!
localVariablesOfBlock
.
contains
(
testedToken
)
)
{
return
true
;
}
}
return
false
;
}
else
{
return
true
;
}
}
else
{
for
(
int
i
=
0
;
i
<
qualifiedNameTokens
.
size
(
)
;
i
++
)
{
String
testedToken
=
qualifiedNameTokens
.
get
(
i
)
;
if
(
!
fieldAndMethodsNames
.
contains
(
testedToken
)
&&
!
localVariablesOfBlock
.
contains
(
testedToken
)
)
{
return
false
;
}
}
return
true
;
}
}
}
}
parent
=
parent
.
getParent
(
)
;
}
}
catch
(
ParentNotInitializedException
e
)
{
return
false
;
}
return
false
;
}
