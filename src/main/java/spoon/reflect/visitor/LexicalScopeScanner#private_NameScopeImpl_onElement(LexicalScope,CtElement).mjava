/** 
 * Call it for each visited CtElement
 * @param parent the parent ConflictFinder
 * @param target an element
 * @return new {@link NameScopeImpl} if `target` element declares new naming scope or null if there is no new scope
 */
private
NameScopeImpl
onElement
(
LexicalScope
parent
,
CtElement
target
)
{
class
Visitor
extends
CtAbstractVisitor
{
NameScopeImpl
finder
=
null
;
@Override
public
void
visitCtCompilationUnit
(
CtCompilationUnit
compilationUnit
)
{
}
@Override
public
<
T
>
void
visitCtClass
(
CtClass
<
T
>
ctClass
)
{
finder
=
new
TypeNameScope
(
parent
,
ctClass
)
;
}
@Override
public
<
T
>
void
visitCtInterface
(
CtInterface
<
T
>
intrface
)
{
finder
=
new
TypeNameScope
(
parent
,
intrface
)
;
}
@Override
public
<
T
extends
Enum
<
?
>
>
void
visitCtEnum
(
CtEnum
<
T
>
ctEnum
)
{
finder
=
new
TypeNameScope
(
parent
,
ctEnum
)
;
}
@Override
public
<
A
extends
Annotation
>
void
visitCtAnnotationType
(
CtAnnotationType
<
A
>
annotationType
)
{
finder
=
new
TypeNameScope
(
parent
,
annotationType
)
;
}
@Override
public
<
T
>
void
visitCtMethod
(
CtMethod
<
T
>
m
)
{
finder
=
new
NameScopeImpl
(
parent
,
m
,
m
.
getParameters
(
)
)
;
}
@Override
public
<
T
>
void
visitCtConstructor
(
CtConstructor
<
T
>
c
)
{
finder
=
new
NameScopeImpl
(
parent
,
c
,
c
.
getParameters
(
)
)
;
}
@Override
public
<
T
>
void
visitCtLambda
(
CtLambda
<
T
>
lambda
)
{
finder
=
new
NameScopeImpl
(
parent
,
lambda
,
lambda
.
getParameters
(
)
)
;
}
@Override
public
void
visitCtCatch
(
CtCatch
catchBlock
)
{
finder
=
new
NameScopeImpl
(
parent
,
catchBlock
)
.
addNamedElement
(
catchBlock
.
getParameter
(
)
)
;
}
@Override
public
<
R
>
void
visitCtBlock
(
CtBlock
<
R
>
block
)
{
finder
=
new
NameScopeImpl
(
parent
,
block
)
;
}
@Override
public
<
T
>
void
visitCtLocalVariable
(
CtLocalVariable
<
T
>
localVariable
)
{
parent
.
addNamedElement
(
localVariable
)
;
}
}
;
Visitor
scanner
=
new
Visitor
(
)
;
target
.
accept
(
scanner
)
;
return
scanner
.
finder
;
}
