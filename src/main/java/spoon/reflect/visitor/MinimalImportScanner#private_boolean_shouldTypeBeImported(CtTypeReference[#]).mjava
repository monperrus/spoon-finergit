/** 
 * Test if the reference should be imported by looking if there is a name conflict
 * @param ref
 * @return true if the ref should be imported.
 */
private
boolean
shouldTypeBeImported
(
CtTypeReference
<
?
>
ref
)
{
if
(
ref
.
equals
(
targetType
)
)
{
return
true
;
}
try
{
CtElement
parent
=
ref
.
getParent
(
)
;
if
(
parent
instanceof
CtNamedElement
)
{
namedElements
.
add
(
(
(
CtNamedElement
)
parent
)
.
getSimpleName
(
)
)
;
}
while
(
!
(
parent
instanceof
CtPackage
)
)
{
if
(
parent
instanceof
CtFieldReference
)
{
CtFieldReference
parentType
=
(
CtFieldReference
)
parent
;
Set
<
String
>
qualifiedNameTokens
=
new
HashSet
<
>
(
)
;
qualifiedNameTokens
.
add
(
parentType
.
getSimpleName
(
)
)
;
CtTypeReference
typeReference
=
parentType
.
getDeclaringType
(
)
;
qualifiedNameTokens
.
add
(
typeReference
.
getSimpleName
(
)
)
;
if
(
typeReference
.
getPackage
(
)
!=
null
)
{
CtPackage
ctPackage
=
typeReference
.
getPackage
(
)
.
getDeclaration
(
)
;
while
(
ctPackage
!=
null
)
{
qualifiedNameTokens
.
add
(
ctPackage
.
getSimpleName
(
)
)
;
CtElement
packParent
=
ctPackage
.
getParent
(
)
;
if
(
packParent
.
getParent
(
)
!=
null
)
{
ctPackage
=
(
CtPackage
)
packParent
;
}
else
{
ctPackage
=
null
;
}
}
for
(
String
token
:
qualifiedNameTokens
)
{
if
(
namedElements
.
contains
(
token
)
)
{
return
true
;
}
}
}
}
parent
=
parent
.
getParent
(
)
;
}
}
catch
(
ParentNotInitializedException
e
)
{
return
false
;
}
return
false
;
}
