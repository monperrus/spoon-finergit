private
void
addCompilationUnitNames
(
CtCompilationUnit
compilationUnit
)
{
CtType
<
?
>
type
=
(
CtType
<
?
>
)
getScopeElement
(
)
;
CtTypeReference
<
?
>
typeRef
=
type
.
getReference
(
)
;
compilationUnit
.
getImports
(
)
.
stream
(
)
.
sorted
(
importComparator
)
.
forEach
(
aImport
->
{
aImport
.
accept
(
new
CtImportVisitor
(
)
{
@Override
public
<
T
>
void
visitTypeImport
(
CtTypeReference
<
T
>
typeReference
)
{
putType
(
typeReference
.
getTypeDeclaration
(
)
)
;
}
@Override
public
<
T
>
void
visitMethodImport
(
CtExecutableReference
<
T
>
executableReference
)
{
putIfNotExists
(
methodsByName
,
executableReference
.
getExecutableDeclaration
(
)
)
;
}
@Override
public
<
T
>
void
visitFieldImport
(
CtFieldReference
<
T
>
fieldReference
)
{
putIfNotExists
(
fieldsByName
,
fieldReference
.
getFieldDeclaration
(
)
)
;
}
@Override
public
void
visitAllTypesImport
(
CtPackageReference
packageReference
)
{
CtPackage
pack
=
packageReference
.
getDeclaration
(
)
;
if
(
pack
!=
null
)
{
for
(
CtType
<
?
>
type
:
pack
.
getTypes
(
)
)
{
putType
(
type
)
;
}
}
}
@Override
public
<
T
>
void
visitAllStaticMembersImport
(
CtTypeMemberWildcardImportReference
typeReference
)
{
CtType
<
?
>
type
=
typeReference
.
getDeclaration
(
)
;
type
.
map
(
new
AllTypeMembersFunction
(
)
.
setMode
(
AllTypeMembersFunction
.
Mode
.
SKIP_PRIVATE
)
)
.
forEach
(
(
CtTypeMember
typeMember
)
->
{
if
(
typeMember
.
isStatic
(
)
&&
typeRef
.
canAccess
(
typeMember
)
)
{
if
(
typeMember
instanceof
CtField
)
{
putIfNotExists
(
fieldsByName
,
typeMember
)
;
}
else
if
(
typeMember
instanceof
CtMethod
)
{
putIfNotExists
(
methodsByName
,
typeMember
)
;
}
}
}
)
;
}
}
)
;
}
)
;
CtPackage
pack
=
compilationUnit
.
getDeclaredPackage
(
)
;
if
(
pack
!=
null
)
{
for
(
CtType
<
?
>
packageType
:
pack
.
getTypes
(
)
)
{
if
(
packageType
!=
getScopeElement
(
)
&&
!
typesByName
.
containsKey
(
packageType
.
getSimpleName
(
)
)
)
{
typesByName
.
put
(
packageType
.
getSimpleName
(
)
,
packageType
)
;
}
}
}
}
