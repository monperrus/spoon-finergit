/** 
 * JVM implementations reports exception in call of lambda in different way. A) the to be called lambda expression whose input parameters are invalid is on top of stack trace B) the to be called lambda expression whose input parameters are invalid is NOT in stack trace at all This method detects actual behavior of JVM, so the code, which decides whether ClassCastException is expected (part of filtering process) or unexpected - thrown by clients wrong code works on all JVM implementations
 */
private
static
int
getIndexOfCallerInStackOfLambda
(
)
{
CtConsumer
<
CtType
<
?
>
>
f
=
(
CtType
<
?
>
t
)
->
{
}
;
CtConsumer
<
Object
>
unchecked
=
(
CtConsumer
)
f
;
Object
obj
=
new
Integer
(
1
)
;
try
{
unchecked
.
accept
(
obj
)
;
throw
new
SpoonException
(
"The lambda expression with input type CtType must throw ClassCastException when input type is Integer. Basic CtQuery contract is violated by JVM!"
)
;
}
catch
(
ClassCastException
e
)
{
StackTraceElement
[
]
stack
=
e
.
getStackTrace
(
)
;
for
(
int
i
=
0
;
i
<
stack
.
length
;
i
++
)
{
if
(
"getIndexOfCallerInStackOfLambda"
.
equals
(
stack
[
i
]
.
getMethodName
(
)
)
)
{
Class
<
?
>
detectectedClass
=
detectTargetClassFromCCE
(
e
,
obj
)
;
if
(
CtType
.
class
.
equals
(
detectectedClass
)
==
false
)
{
return
-
1
;
}
return
i
;
}
}
throw
new
SpoonException
(
"Spoon cannot detect index of caller of lambda expression in stack trace."
,
e
)
;
}
}
