@Override
public
void
apply
(
final
CtExecutable
<
?
>
targetExecutable
,
final
CtConsumer
<
Object
>
outputConsumer
)
{
final
LambdaFilter
lambdaFilter
=
new
LambdaFilter
(
)
;
final
CtQuery
lambdaQuery
=
targetExecutable
.
getFactory
(
)
.
getModel
(
)
.
getRootPackage
(
)
.
filterChildren
(
lambdaFilter
)
;
CtMethod
<
?
>
targetMethod
;
if
(
targetExecutable
instanceof
CtLambda
)
{
if
(
includingSelf
&&
includingLambdas
)
{
outputConsumer
.
accept
(
targetExecutable
)
;
if
(
query
.
isTerminated
(
)
)
{
return
;
}
}
targetMethod
=
(
(
CtLambda
<
?
>
)
targetExecutable
)
.
getOverriddenMethod
(
)
;
outputConsumer
.
accept
(
targetMethod
)
;
if
(
query
.
isTerminated
(
)
)
{
return
;
}
lambdaQuery
.
select
(
new
Filter
<
CtLambda
<
?
>
>
(
)
{
@Override
public
boolean
matches
(
CtLambda
<
?
>
lambda
)
{
return
targetExecutable
!=
lambda
;
}
}
)
;
}
else
if
(
targetExecutable
instanceof
CtMethod
)
{
if
(
includingSelf
)
{
outputConsumer
.
accept
(
targetExecutable
)
;
if
(
query
.
isTerminated
(
)
)
{
return
;
}
}
targetMethod
=
(
CtMethod
<
?
>
)
targetExecutable
;
}
else
{
if
(
includingSelf
)
{
outputConsumer
.
accept
(
targetExecutable
)
;
}
return
;
}
final
List
<
CtMethod
<
?
>
>
targetMethods
=
new
ArrayList
<
>
(
)
;
targetMethods
.
add
(
targetMethod
)
;
CtType
<
?
>
declaringType
=
targetMethod
.
getDeclaringType
(
)
;
lambdaFilter
.
addImplementingInterface
(
declaringType
)
;
class
Context
{
boolean
haveToSearchForSubtypes
;
}
final
Context
context
=
new
Context
(
)
;
context
.
haveToSearchForSubtypes
=
true
;
final
SubInheritanceHierarchyResolver
subHierarchyFnc
=
new
SubInheritanceHierarchyResolver
(
declaringType
.
getFactory
(
)
.
getModel
(
)
.
getRootPackage
(
)
)
;
subHierarchyFnc
.
addSuperType
(
declaringType
)
;
Set
<
String
>
typesCheckedForRootType
=
new
HashSet
<
>
(
)
;
final
List
<
CtType
<
?
>
>
toBeCheckedSubTypes
=
new
ArrayList
<
>
(
)
;
toBeCheckedSubTypes
.
add
(
declaringType
)
;
while
(
toBeCheckedSubTypes
.
size
(
)
>
0
)
{
for
(
CtType
<
?
>
subType
:
toBeCheckedSubTypes
)
{
ClassTypingContext
ctc
=
new
ClassTypingContext
(
subType
)
;
targetMethod
=
getTargetMethodOfHierarchy
(
targetMethods
,
ctc
)
;
forEachOverridenMethod
(
ctc
,
targetMethod
,
typesCheckedForRootType
,
new
CtConsumer
<
CtMethod
<
?
>
>
(
)
{
@Override
public
void
accept
(
CtMethod
<
?
>
overriddenMethod
)
{
targetMethods
.
add
(
overriddenMethod
)
;
outputConsumer
.
accept
(
overriddenMethod
)
;
CtType
<
?
>
type
=
overriddenMethod
.
getDeclaringType
(
)
;
lambdaFilter
.
addImplementingInterface
(
type
)
;
subHierarchyFnc
.
addSuperType
(
type
)
;
context
.
haveToSearchForSubtypes
=
true
;
}
}
)
;
if
(
query
.
isTerminated
(
)
)
{
return
;
}
}
toBeCheckedSubTypes
.
clear
(
)
;
if
(
context
.
haveToSearchForSubtypes
)
{
context
.
haveToSearchForSubtypes
=
false
;
subHierarchyFnc
.
forEachSubTypeInPackage
(
new
CtConsumer
<
CtType
<
?
>
>
(
)
{
@Override
public
void
accept
(
CtType
<
?
>
type
)
{
toBeCheckedSubTypes
.
add
(
type
)
;
}
}
)
;
}
}
if
(
includingLambdas
)
{
lambdaQuery
.
forEach
(
outputConsumer
)
;
}
}
