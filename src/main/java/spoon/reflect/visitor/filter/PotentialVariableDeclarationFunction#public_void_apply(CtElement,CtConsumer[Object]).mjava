@Override
public
void
apply
(
CtElement
input
,
CtConsumer
<
Object
>
outputConsumer
)
{
isTypeOnTheWay
=
false
;
CtQuery
siblingsQuery
=
input
.
getFactory
(
)
.
createQuery
(
)
.
map
(
new
SiblingsFunction
(
)
.
mode
(
SiblingsFunction
.
Mode
.
PREVIOUS
)
)
.
select
(
new
TypeFilter
<
>
(
CtVariable
.
class
)
)
;
if
(
variableName
!=
null
)
{
siblingsQuery
=
siblingsQuery
.
select
(
new
NamedElementFilter
<
>
(
CtNamedElement
.
class
,
variableName
)
)
;
}
CtElement
scopeElement
=
input
;
while
(
scopeElement
!=
null
&&
!
(
scopeElement
instanceof
CtPackage
)
&&
scopeElement
.
isParentInitialized
(
)
)
{
CtElement
parent
=
scopeElement
.
getParent
(
)
;
if
(
parent
instanceof
CtType
<
?
>
)
{
isTypeOnTheWay
=
true
;
Collection
<
CtFieldReference
<
?
>
>
allFields
=
(
(
CtType
<
?
>
)
parent
)
.
getAllFields
(
)
;
for
(
CtFieldReference
<
?
>
fieldReference
:
allFields
)
{
if
(
sendToOutput
(
fieldReference
.
getFieldDeclaration
(
)
,
outputConsumer
)
)
{
return
;
}
}
}
else
if
(
parent
instanceof
CtBodyHolder
||
parent
instanceof
CtStatementList
)
{
siblingsQuery
.
setInput
(
scopeElement
)
.
forEach
(
outputConsumer
)
;
if
(
query
.
isTerminated
(
)
)
{
return
;
}
if
(
parent
instanceof
CtCatch
)
{
CtCatch
ctCatch
=
(
CtCatch
)
parent
;
if
(
sendToOutput
(
ctCatch
.
getParameter
(
)
,
outputConsumer
)
)
{
return
;
}
}
else
if
(
parent
instanceof
CtExecutable
)
{
CtExecutable
<
?
>
exec
=
(
CtExecutable
<
?
>
)
parent
;
for
(
CtParameter
<
?
>
param
:
exec
.
getParameters
(
)
)
{
if
(
sendToOutput
(
param
,
outputConsumer
)
)
{
return
;
}
}
}
}
scopeElement
=
parent
;
}
}
