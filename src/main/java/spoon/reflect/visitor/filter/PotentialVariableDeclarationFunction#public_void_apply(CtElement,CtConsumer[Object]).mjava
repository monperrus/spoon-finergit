@Override
public
void
apply
(
CtElement
input
,
CtConsumer
<
Object
>
outputConsumer
)
{
isTypeOnTheWay
=
false
;
isInStaticScope
=
false
;
CtQuery
siblingsQuery
=
input
.
getFactory
(
)
.
createQuery
(
)
.
map
(
new
SiblingsFunction
(
)
.
mode
(
SiblingsFunction
.
Mode
.
PREVIOUS
)
)
.
select
(
new
TypeFilter
<
>
(
CtVariable
.
class
)
)
;
if
(
variableName
!=
null
)
{
siblingsQuery
=
siblingsQuery
.
select
(
new
NamedElementFilter
<
>
(
CtNamedElement
.
class
,
variableName
)
)
;
}
CtElement
scopeElement
=
input
;
while
(
scopeElement
!=
null
&&
!
(
scopeElement
instanceof
CtPackage
)
&&
scopeElement
.
isParentInitialized
(
)
)
{
CtElement
parent
=
scopeElement
.
getParent
(
)
;
if
(
parent
instanceof
CtType
<
?
>
)
{
isTypeOnTheWay
=
true
;
CtQuery
q
=
parent
.
map
(
new
AllTypeMembersFunction
(
CtField
.
class
)
)
;
q
.
forEach
(
(
CtField
<
?
>
field
)
->
{
if
(
isInStaticScope
&&
field
.
hasModifier
(
ModifierKind
.
STATIC
)
==
false
)
{
return
;
}
if
(
sendToOutput
(
field
,
outputConsumer
)
)
{
q
.
terminate
(
)
;
}
}
)
;
if
(
query
.
isTerminated
(
)
)
{
return
;
}
}
else
if
(
parent
instanceof
CtBodyHolder
||
parent
instanceof
CtStatementList
)
{
siblingsQuery
.
setInput
(
scopeElement
)
.
forEach
(
outputConsumer
)
;
if
(
query
.
isTerminated
(
)
)
{
return
;
}
if
(
parent
instanceof
CtCatch
)
{
CtCatch
ctCatch
=
(
CtCatch
)
parent
;
if
(
sendToOutput
(
ctCatch
.
getParameter
(
)
,
outputConsumer
)
)
{
return
;
}
}
else
if
(
parent
instanceof
CtExecutable
)
{
CtExecutable
<
?
>
exec
=
(
CtExecutable
<
?
>
)
parent
;
for
(
CtParameter
<
?
>
param
:
exec
.
getParameters
(
)
)
{
if
(
sendToOutput
(
param
,
outputConsumer
)
)
{
return
;
}
}
}
}
if
(
parent
instanceof
CtModifiable
)
{
isInStaticScope
=
isInStaticScope
||
(
(
CtModifiable
)
parent
)
.
hasModifier
(
ModifierKind
.
STATIC
)
;
}
scopeElement
=
parent
;
}
}
