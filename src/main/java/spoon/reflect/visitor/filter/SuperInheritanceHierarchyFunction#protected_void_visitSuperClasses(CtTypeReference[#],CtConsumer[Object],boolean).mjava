/** 
 * calls `outputConsumer.accept(superClass)` for all super classes of superType.
 * @param includingInterfaces if true then all superInterfaces of each type are sent to `outputConsumer` too.
 */
protected
void
visitSuperClasses
(
CtTypeReference
<
?
>
superTypeRef
,
CtConsumer
<
Object
>
outputConsumer
,
boolean
includingInterfaces
)
{
if
(
Object
.
class
.
getName
(
)
.
equals
(
superTypeRef
.
getQualifiedName
(
)
)
)
{
return
;
}
if
(
includingInterfaces
)
{
visitSuperInterfaces
(
superTypeRef
,
outputConsumer
)
;
if
(
query
.
isTerminated
(
)
)
{
return
;
}
}
CtTypeReference
<
?
>
superClassRef
=
superTypeRef
.
getSuperclass
(
)
;
if
(
superClassRef
==
null
)
{
CtType
<
?
>
superType
;
try
{
superType
=
superTypeRef
.
getTypeDeclaration
(
)
;
}
catch
(
SpoonClassNotFoundException
e
)
{
if
(
failOnClassNotFound
)
{
throw
e
;
}
return
;
}
if
(
superType
instanceof
CtClass
)
{
superClassRef
=
superTypeRef
.
getFactory
(
)
.
Type
(
)
.
OBJECT
;
}
else
{
return
;
}
}
ScanningMode
mode
=
enter
(
superClassRef
)
;
if
(
mode
==
SKIP_ALL
)
{
return
;
}
sendResult
(
superClassRef
,
outputConsumer
)
;
if
(
mode
==
NORMAL
&&
query
.
isTerminated
(
)
==
false
)
{
visitSuperClasses
(
superClassRef
,
outputConsumer
,
includingInterfaces
)
;
}
exit
(
superClassRef
)
;
}
