/** 
 * calls `outputConsumer.accept(superClass)` all super classes of superType.
 * @param includingInterfaces if true then all superInterfaces of each type are sent to `outputConsumer` too.
 */
protected
void
visitSuperClasses
(
CtType
<
?
>
superType
,
CtConsumer
<
Object
>
outputConsumer
,
boolean
includingInterfaces
)
{
while
(
true
)
{
if
(
includingInterfaces
)
{
if
(
visitSuperInterfaces
(
superType
,
outputConsumer
)
==
false
)
{
return
;
}
}
CtTypeReference
<
?
>
superClassRef
=
superType
.
getSuperclass
(
)
;
if
(
superClassRef
==
null
)
{
if
(
superType
instanceof
CtClass
)
{
superType
=
superType
.
getFactory
(
)
.
Type
(
)
.
get
(
Object
.
class
)
;
if
(
canVisitType
(
Object
.
class
.
getName
(
)
)
)
{
outputConsumer
.
accept
(
superType
)
;
}
}
return
;
}
if
(
canVisitType
(
superClassRef
.
getQualifiedName
(
)
)
==
false
)
{
return
;
}
try
{
superType
=
superClassRef
.
getTypeDeclaration
(
)
;
}
catch
(
SpoonClassNotFoundException
e
)
{
if
(
failOnClassNotFound
)
{
throw
e
;
}
}
outputConsumer
.
accept
(
superType
)
;
if
(
query
.
isTerminated
(
)
)
{
return
;
}
}
}
