/** 
 * Takes the class given as parameter, pretty-prints it, get the JDT'ast and the corrspondong Spoon AST and finally replace all children of initialClass by the the fresh ones. This results that all snippets are now full-fledged ASTs.
 */
public
static
void
compileAndReplaceSnippetsIn
(
CtType
<
?
>
initialClass
)
{
Map
<
CtPath
,
CtElement
>
elements2before
=
new
HashMap
<
>
(
)
;
Map
<
CtPath
,
CtElement
>
elements2after
=
new
HashMap
<
>
(
)
;
for
(
Object
o
:
initialClass
.
filterChildren
(
new
TypeFilter
<
>
(
CtCodeSnippet
.
class
)
)
.
list
(
)
)
{
CtElement
el
=
(
CtElement
)
o
;
elements2before
.
put
(
el
.
getPath
(
)
,
el
)
;
}
Factory
f
=
initialClass
.
getFactory
(
)
;
Set
<
ModifierKind
>
backup
=
EnumSet
.
noneOf
(
ModifierKind
.
class
)
;
backup
.
addAll
(
initialClass
.
getModifiers
(
)
)
;
initialClass
.
removeModifier
(
ModifierKind
.
PUBLIC
)
;
initialClass
.
delete
(
)
;
try
{
build
(
f
,
"package "
+
initialClass
.
getPackage
(
)
.
getQualifiedName
(
)
+
";"
+
initialClass
.
toString
(
)
)
;
}
finally
{
initialClass
.
setModifiers
(
backup
)
;
}
CtType
<
?
>
newClass
=
f
.
Type
(
)
.
get
(
initialClass
.
getQualifiedName
(
)
)
;
for
(
CtPath
p
:
elements2before
.
keySet
(
)
)
{
elements2after
.
put
(
p
,
p
.
evaluateOn
(
f
.
getModel
(
)
.
getRootPackage
(
)
)
.
iterator
(
)
.
next
(
)
)
;
}
newClass
.
replace
(
initialClass
)
;
for
(
Map
.
Entry
<
CtPath
,
CtElement
>
ctPath
:
elements2before
.
entrySet
(
)
)
{
CtElement
toReplace
=
ctPath
.
getValue
(
)
;
toReplace
.
replace
(
elements2after
.
get
(
ctPath
.
getKey
(
)
)
)
;
}
}
