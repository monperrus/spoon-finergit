public
CompilationUnitDeclaration
[
]
getUnits
(
List
<
SpoonFile
>
files
)
{
startTime
=
System
.
currentTimeMillis
(
)
;
INameEnvironment
environment
=
this
.
jdtCompiler
.
environment
;
if
(
environment
==
null
)
{
environment
=
getLibraryAccess
(
)
;
}
CompilerOptions
compilerOptions
=
new
CompilerOptions
(
this
.
options
)
;
compilerOptions
.
parseLiteralExpressionsAsConstants
=
false
;
TreeBuilderCompiler
treeBuilderCompiler
=
new
TreeBuilderCompiler
(
environment
,
getHandlingPolicy
(
)
,
compilerOptions
,
this
.
jdtCompiler
.
requestor
,
getProblemFactory
(
)
,
this
.
out
,
null
)
;
if
(
jdtCompiler
.
getEnvironment
(
)
.
getNoClasspath
(
)
)
{
treeBuilderCompiler
.
lookupEnvironment
.
mayTolerateMissingType
=
true
;
}
CompilationUnitDeclaration
[
]
units
=
treeBuilderCompiler
.
buildUnits
(
getCompilationUnits
(
files
)
)
;
for
(
int
i
=
0
;
i
<
units
.
length
;
i
++
)
{
CompilationUnitDeclaration
unit
=
units
[
i
]
;
CommentRecorderParser
parser
=
new
CommentRecorderParser
(
new
ProblemReporter
(
DefaultErrorHandlingPolicies
.
proceedWithAllProblems
(
)
,
compilerOptions
,
new
DefaultProblemFactory
(
Locale
.
getDefault
(
)
)
)
,
false
)
;
ICompilationUnit
sourceUnit
=
new
CompilationUnit
(
getCompilationUnits
(
)
[
i
]
.
getContents
(
)
,
""
,
compilerOptions
.
defaultEncoding
)
;
final
CompilationResult
compilationResult
=
new
CompilationResult
(
sourceUnit
,
0
,
0
,
compilerOptions
.
maxProblemsPerUnit
)
;
CompilationUnitDeclaration
compilationUnitDeclaration
=
parser
.
dietParse
(
sourceUnit
,
compilationResult
)
;
unit
.
comments
=
compilationUnitDeclaration
.
comments
;
}
return
units
;
}
