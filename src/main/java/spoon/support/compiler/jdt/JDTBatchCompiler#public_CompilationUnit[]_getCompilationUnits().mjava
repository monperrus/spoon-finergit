/** 
 * This method returns the compilation units that will be processed and/or compiled by JDT. Note that this method also process the CUs to associate the right module information. Warning: this method cannot be replaced by a call to its supermethod as we manage the CUs differently in Spoon. We might indeed have CUs coming from virtual files or ignored CU due to the configuration. The the CUs are created from the  {@link FileCompilerConfig}.
 */
@Override
public
CompilationUnit
[
]
getCompilationUnits
(
)
{
Map
<
String
,
CompilationUnit
>
pathToModCU
=
new
HashMap
<
>
(
)
;
for
(
int
round
=
0
;
round
<
2
;
round
++
)
{
for
(
CompilationUnit
compilationUnit
:
this
.
compilationUnits
)
{
char
[
]
charName
=
compilationUnit
.
getFileName
(
)
;
boolean
isModuleInfo
=
CharOperation
.
endsWith
(
charName
,
TypeConstants
.
MODULE_INFO_FILE_NAME
)
;
if
(
isModuleInfo
==
(
round
==
0
)
)
{
String
fileName
=
new
String
(
charName
)
;
if
(
isModuleInfo
)
{
int
lastSlash
=
CharOperation
.
lastIndexOf
(
File
.
separatorChar
,
charName
)
;
if
(
lastSlash
!=
-
1
)
{
char
[
]
modulePath
=
CharOperation
.
subarray
(
charName
,
0
,
lastSlash
)
;
pathToModCU
.
put
(
String
.
valueOf
(
modulePath
)
,
compilationUnit
)
;
lastSlash
=
CharOperation
.
lastIndexOf
(
File
.
separatorChar
,
modulePath
)
;
if
(
lastSlash
==
-
1
)
{
lastSlash
=
0
;
}
else
{
lastSlash
=
1
;
}
compilationUnit
.
module
=
CharOperation
.
subarray
(
modulePath
,
lastSlash
,
modulePath
.
length
)
;
}
}
else
{
for
(
Map
.
Entry
<
String
,
CompilationUnit
>
entry
:
pathToModCU
.
entrySet
(
)
)
{
if
(
fileName
.
startsWith
(
entry
.
getKey
(
)
)
)
{
compilationUnit
.
setModule
(
entry
.
getValue
(
)
)
;
break
;
}
}
}
}
}
}
return
compilationUnits
;
}
