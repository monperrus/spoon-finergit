/** 
 * Inserts the comment into the AST.
 * @param comment the comment to insert
 */
private
void
insertCommentInAST
(
final
CtComment
comment
)
{
CtElement
commentParent
=
findCommentParent
(
comment
)
;
if
(
commentParent
==
null
)
{
File
file
=
spoonUnit
.
getFile
(
)
;
if
(
file
!=
null
&&
file
.
getName
(
)
.
equals
(
DefaultJavaPrettyPrinter
.
JAVA_PACKAGE_DECLARATION
)
)
{
spoonUnit
.
getDeclaredPackage
(
)
.
addComment
(
comment
)
;
}
else
if
(
file
!=
null
&&
file
.
getName
(
)
.
equals
(
DefaultJavaPrettyPrinter
.
JAVA_MODULE_DECLARATION
)
)
{
spoonUnit
.
getDeclaredModule
(
)
.
addComment
(
comment
)
;
}
else
{
comment
.
setCommentType
(
CtComment
.
CommentType
.
FILE
)
;
addCommentToNear
(
comment
,
new
ArrayList
<
CtElement
>
(
spoonUnit
.
getDeclaredTypes
(
)
)
)
;
}
return
;
}
CtInheritanceScanner
insertionVisitor
=
new
CtInheritanceScanner
(
)
{
private
boolean
isScanned
=
false
;
@Override
public
void
scan
(
CtElement
e
)
{
if
(
e
==
null
)
{
return
;
}
if
(
!
isScanned
)
{
isScanned
=
true
;
if
(
e
.
getPosition
(
)
.
getSourceStart
(
)
==
comment
.
getPosition
(
)
.
getSourceStart
(
)
)
{
e
.
addComment
(
comment
)
;
return
;
}
super
.
scan
(
e
)
;
}
}
@Override
public
<
R
>
void
visitCtStatementList
(
CtStatementList
e
)
{
addCommentToNear
(
comment
,
new
ArrayList
<
CtElement
>
(
e
.
getStatements
(
)
)
)
;
try
{
comment
.
getParent
(
)
;
}
catch
(
ParentNotInitializedException
ex
)
{
e
.
addStatement
(
comment
)
;
}
}
@Override
public
<
T
>
void
visitCtMethod
(
CtMethod
<
T
>
e
)
{
e
.
addComment
(
comment
)
;
}
@Override
public
<
T
>
void
visitCtConstructor
(
CtConstructor
<
T
>
e
)
{
e
.
addComment
(
comment
)
;
}
@Override
public
<
T
>
void
visitCtConditional
(
CtConditional
<
T
>
e
)
{
List
<
CtElement
>
elements
=
new
ArrayList
<
>
(
)
;
elements
.
add
(
e
.
getElseExpression
(
)
)
;
elements
.
add
(
e
.
getThenExpression
(
)
)
;
elements
.
add
(
e
.
getCondition
(
)
)
;
addCommentToNear
(
comment
,
elements
)
;
}
@Override
public
<
T
>
void
visitCtBinaryOperator
(
CtBinaryOperator
<
T
>
e
)
{
List
<
CtElement
>
elements
=
new
ArrayList
<
>
(
)
;
elements
.
add
(
e
.
getLeftHandOperand
(
)
)
;
elements
.
add
(
e
.
getRightHandOperand
(
)
)
;
addCommentToNear
(
comment
,
elements
)
;
}
@Override
public
<
T
>
void
visitCtClass
(
CtClass
<
T
>
e
)
{
if
(
comment
.
getPosition
(
)
.
getSourceEnd
(
)
<
(
(
BodyHolderSourcePosition
)
e
.
getPosition
(
)
)
.
getBodyStart
(
)
)
{
e
.
addComment
(
comment
)
;
return
;
}
final
List
<
CtElement
>
elements
=
new
ArrayList
<
>
(
)
;
for
(
CtTypeMember
typeMember
:
e
.
getTypeMembers
(
)
)
{
if
(
typeMember
instanceof
CtField
||
typeMember
instanceof
CtMethod
||
typeMember
instanceof
CtConstructor
)
{
elements
.
add
(
typeMember
)
;
}
}
addCommentToNear
(
comment
,
elements
)
;
try
{
comment
.
getParent
(
)
;
}
catch
(
ParentNotInitializedException
ex
)
{
e
.
addComment
(
comment
)
;
}
}
@Override
public
<
T
>
void
visitCtInterface
(
CtInterface
<
T
>
e
)
{
final
List
<
CtElement
>
elements
=
new
ArrayList
<
>
(
)
;
for
(
CtTypeMember
typeMember
:
e
.
getTypeMembers
(
)
)
{
if
(
typeMember
instanceof
CtField
||
typeMember
instanceof
CtMethod
)
{
elements
.
add
(
typeMember
)
;
}
}
addCommentToNear
(
comment
,
elements
)
;
try
{
comment
.
getParent
(
)
;
}
catch
(
ParentNotInitializedException
ex
)
{
e
.
addComment
(
comment
)
;
}
}
@Override
public
<
T
>
void
visitCtField
(
CtField
<
T
>
e
)
{
e
.
addComment
(
comment
)
;
}
@Override
public
<
E
>
void
visitCtSwitch
(
CtSwitch
<
E
>
e
)
{
List
<
CtCase
<
?
E
>
>
cases
=
e
.
getCases
(
)
;
CtCase
previous
=
null
;
for
(
int
i
=
0
;
i
<
cases
.
size
(
)
;
i
++
)
{
CtCase
<
?
E
>
ctCase
=
cases
.
get
(
i
)
;
if
(
previous
==
null
)
{
if
(
comment
.
getPosition
(
)
.
getSourceStart
(
)
<
ctCase
.
getPosition
(
)
.
getSourceStart
(
)
&&
e
.
getPosition
(
)
.
getSourceStart
(
)
<
comment
.
getPosition
(
)
.
getSourceStart
(
)
)
{
ctCase
.
addComment
(
comment
)
;
return
;
}
}
else
{
if
(
previous
.
getPosition
(
)
.
getSourceEnd
(
)
<
comment
.
getPosition
(
)
.
getSourceStart
(
)
&&
ctCase
.
getPosition
(
)
.
getSourceStart
(
)
>
comment
.
getPosition
(
)
.
getSourceStart
(
)
)
{
addCommentToNear
(
comment
,
new
ArrayList
<
CtElement
>
(
previous
.
getStatements
(
)
)
)
;
try
{
comment
.
getParent
(
)
;
}
catch
(
ParentNotInitializedException
ex
)
{
previous
.
addStatement
(
comment
)
;
}
return
;
}
}
previous
=
ctCase
;
}
if
(
previous
.
getPosition
(
)
.
getSourceEnd
(
)
<
comment
.
getPosition
(
)
.
getSourceStart
(
)
)
{
addCommentToNear
(
comment
,
new
ArrayList
<
CtElement
>
(
previous
.
getStatements
(
)
)
)
;
try
{
comment
.
getParent
(
)
;
}
catch
(
ParentNotInitializedException
ex
)
{
previous
.
addStatement
(
comment
)
;
}
return
;
}
try
{
comment
.
getParent
(
)
;
}
catch
(
ParentNotInitializedException
ex
)
{
e
.
addComment
(
comment
)
;
}
}
@Override
public
void
visitCtIf
(
CtIf
e
)
{
if
(
!
(
e
.
getThenStatement
(
)
instanceof
CtBlock
)
)
{
if
(
comment
.
getPosition
(
)
.
getSourceEnd
(
)
<=
e
.
getThenStatement
(
)
.
getPosition
(
)
.
getSourceStart
(
)
)
{
e
.
getThenStatement
(
)
.
addComment
(
comment
)
;
return
;
}
}
if
(
e
.
getElseStatement
(
)
!=
null
)
{
SourcePosition
thenPosition
=
e
.
getThenStatement
(
)
.
getPosition
(
)
.
isValidPosition
(
)
==
false
?
(
(
CtBlock
)
e
.
getThenStatement
(
)
)
.
getStatement
(
0
)
.
getPosition
(
)
:
e
.
getThenStatement
(
)
.
getPosition
(
)
;
SourcePosition
elsePosition
=
e
.
getElseStatement
(
)
.
getPosition
(
)
.
isValidPosition
(
)
==
false
?
(
(
CtBlock
)
e
.
getElseStatement
(
)
)
.
getStatement
(
0
)
.
getPosition
(
)
:
e
.
getElseStatement
(
)
.
getPosition
(
)
;
if
(
comment
.
getPosition
(
)
.
getSourceStart
(
)
>
thenPosition
.
getSourceEnd
(
)
&&
comment
.
getPosition
(
)
.
getSourceEnd
(
)
<
elsePosition
.
getSourceStart
(
)
)
{
e
.
getElseStatement
(
)
.
addComment
(
comment
)
;
}
}
try
{
comment
.
getParent
(
)
;
}
catch
(
ParentNotInitializedException
ex
)
{
e
.
addComment
(
comment
)
;
}
}
@Override
public
void
scanCtStatement
(
CtStatement
s
)
{
if
(
!
(
s
instanceof
CtStatementList
||
s
instanceof
CtSwitch
)
)
{
s
.
addComment
(
comment
)
;
}
}
@Override
public
void
visitCtAnonymousExecutable
(
CtAnonymousExecutable
e
)
{
e
.
addComment
(
comment
)
;
}
@Override
public
<
T
>
void
visitCtNewArray
(
CtNewArray
<
T
>
e
)
{
addCommentToNear
(
comment
,
new
ArrayList
<
CtElement
>
(
e
.
getElements
(
)
)
)
;
try
{
comment
.
getParent
(
)
;
}
catch
(
ParentNotInitializedException
ex
)
{
e
.
addComment
(
comment
)
;
}
}
@Override
public
<
T
>
void
visitCtParameter
(
CtParameter
<
T
>
e
)
{
e
.
addComment
(
comment
)
;
}
@Override
public
void
visitCtCatch
(
CtCatch
e
)
{
if
(
comment
.
getPosition
(
)
.
getLine
(
)
<=
e
.
getPosition
(
)
.
getLine
(
)
)
{
e
.
addComment
(
comment
)
;
return
;
}
}
@Override
public
void
visitCtModule
(
CtModule
module
)
{
addCommentToNear
(
comment
,
new
ArrayList
<
>
(
module
.
getModuleDirectives
(
)
)
)
;
}
}
;
insertionVisitor
.
scan
(
commentParent
)
;
try
{
comment
.
getParent
(
)
;
}
catch
(
ParentNotInitializedException
e
)
{
LOGGER
.
error
(
comment
+
" is not added into the AST"
,
e
)
;
}
}
