/** 
 * Builds a type reference from a qualified name when a type specified in the name isn't available.
 * @param tokens Qualified name.
 * @param receiverType Last type in the qualified name.
 * @param enclosingType Enclosing type of the type name.
 * @param listener Listener to know if we must build the type reference.
 * @return a type reference.
 */
private
<
T
>
CtTypeReference
<
T
>
getQualifiedTypeReference
(
char
[
]
[
]
tokens
,
TypeBinding
receiverType
,
ReferenceBinding
enclosingType
,
OnAccessListener
listener
)
{
if
(
enclosingType
!=
null
&&
Collections
.
disjoint
(
Arrays
.
asList
(
ModifierKind
.
PUBLIC
,
ModifierKind
.
PROTECTED
)
,
getModifiers
(
enclosingType
.
modifiers
)
)
)
{
String
access
=
""
;
int
i
=
0
;
for
(
;
i
<
tokens
.
length
;
i
++
)
{
final
char
[
]
[
]
qualified
=
Arrays
.
copyOfRange
(
tokens
,
0
,
i
+
1
)
;
if
(
!
isPackage
(
qualified
)
)
{
access
=
CharOperation
.
toString
(
qualified
)
;
break
;
}
}
if
(
!
access
.
contains
(
CtPackage
.
PACKAGE_SEPARATOR
)
)
{
access
=
hasTypeInImports
(
access
)
;
}
final
TypeBinding
accessBinding
=
searchTypeBinding
(
access
)
;
if
(
accessBinding
!=
null
&&
listener
.
onAccess
(
tokens
,
i
)
)
{
final
TypeBinding
superClassBinding
=
searchTypeBinding
(
accessBinding
.
superclass
(
)
,
CharOperation
.
charToString
(
tokens
[
i
+
1
]
)
)
;
if
(
superClassBinding
!=
null
)
{
return
references
.
getTypeReference
(
superClassBinding
.
clone
(
accessBinding
)
)
;
}
else
{
return
references
.
getTypeReference
(
receiverType
)
;
}
}
else
{
return
references
.
getTypeReference
(
receiverType
)
;
}
}
return
null
;
}
