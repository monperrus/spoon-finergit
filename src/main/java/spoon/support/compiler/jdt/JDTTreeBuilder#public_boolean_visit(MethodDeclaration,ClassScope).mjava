@Override
public
boolean
visit
(
MethodDeclaration
methodDeclaration
,
ClassScope
scope
)
{
CtMethod
<
Object
>
m
=
factory
.
Core
(
)
.
createMethod
(
)
;
m
.
setSimpleName
(
new
String
(
methodDeclaration
.
selector
)
)
;
m
.
setType
(
buildTypeReference
(
methodDeclaration
.
returnType
,
scope
)
)
;
m
.
setModifiers
(
getModifiers
(
methodDeclaration
.
modifiers
)
)
;
m
.
setDefaultMethod
(
methodDeclaration
.
isDefaultMethod
(
)
)
;
context
.
enter
(
m
,
methodDeclaration
)
;
if
(
methodDeclaration
.
thrownExceptions
!=
null
)
{
for
(
TypeReference
r
:
methodDeclaration
.
thrownExceptions
)
{
CtTypeReference
<
Throwable
>
throwType
=
buildTypeReference
(
r
,
scope
)
;
m
.
addThrownType
(
throwType
)
;
}
}
if
(
methodDeclaration
.
typeParameters
(
)
!=
null
)
{
for
(
TypeParameter
typeParameter
:
methodDeclaration
.
typeParameters
(
)
)
{
typeParameter
.
traverse
(
this
,
scope
)
;
}
}
if
(
scope
!=
null
)
{
m
.
setDocComment
(
getJavaDoc
(
methodDeclaration
.
javadoc
,
scope
.
referenceCompilationUnit
(
)
)
)
;
}
else
if
(
methodDeclaration
.
scope
!=
null
)
{
m
.
setDocComment
(
getJavaDoc
(
methodDeclaration
.
javadoc
,
methodDeclaration
.
scope
.
referenceCompilationUnit
(
)
)
)
;
}
else
{
}
if
(
methodDeclaration
.
annotations
!=
null
)
{
for
(
Annotation
a
:
methodDeclaration
.
annotations
)
{
a
.
traverse
(
this
,
methodDeclaration
.
scope
)
;
substituteAnnotation
(
m
,
a
,
CtAnnotatedElementType
.
TYPE_USE
)
;
}
}
if
(
methodDeclaration
.
arguments
!=
null
)
{
for
(
Argument
a
:
methodDeclaration
.
arguments
)
{
a
.
traverse
(
this
,
methodDeclaration
.
scope
)
;
}
}
if
(
!
methodDeclaration
.
isAbstract
(
)
&&
(
methodDeclaration
.
modifiers
&
ClassFileConstants
.
AccNative
)
==
0
)
{
CtBlock
<
?
>
b
=
factory
.
Core
(
)
.
createBlock
(
)
;
context
.
enter
(
b
,
methodDeclaration
)
;
}
if
(
methodDeclaration
.
statements
!=
null
)
{
for
(
Statement
s
:
methodDeclaration
.
statements
)
{
s
.
traverse
(
this
,
methodDeclaration
.
scope
)
;
}
}
return
false
;
}
