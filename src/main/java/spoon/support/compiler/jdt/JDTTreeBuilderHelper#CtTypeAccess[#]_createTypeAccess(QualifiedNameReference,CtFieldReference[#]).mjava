/** 
 * Creates a type access from its qualified name and with a field reference.
 * @param qualifiedNameReference Used to update the field reference if necessary.
 * @param fieldReference Used to get its declaring class and to put it in the type access.
 * @return a type access.
 */
CtTypeAccess
<
?
>
createTypeAccess
(
QualifiedNameReference
qualifiedNameReference
,
CtFieldReference
<
?
>
fieldReference
)
{
final
TypeBinding
receiverType
=
qualifiedNameReference
.
actualReceiverType
;
if
(
receiverType
!=
null
)
{
final
CtTypeReference
<
Object
>
qualifiedRef
=
jdtTreeBuilder
.
getReferencesBuilder
(
)
.
getQualifiedTypeReference
(
qualifiedNameReference
.
tokens
,
receiverType
,
qualifiedNameReference
.
fieldBinding
(
)
.
declaringClass
.
enclosingType
(
)
,
new
JDTTreeBuilder
.
OnAccessListener
(
)
{
@Override
public
boolean
onAccess
(
char
[
]
[
]
tokens
,
int
index
)
{
return
!
CharOperation
.
equals
(
tokens
[
index
+
1
]
,
tokens
[
tokens
.
length
-
1
]
)
;
}
}
)
;
if
(
qualifiedRef
!=
null
)
{
fieldReference
.
setDeclaringType
(
qualifiedRef
)
;
}
else
{
fieldReference
.
setDeclaringType
(
jdtTreeBuilder
.
getReferencesBuilder
(
)
.
getTypeReference
(
receiverType
)
)
;
}
}
CtTypeAccess
<
?
>
typeAccess
=
jdtTreeBuilder
.
getFactory
(
)
.
Code
(
)
.
createTypeAccess
(
fieldReference
.
getDeclaringType
(
)
)
;
if
(
qualifiedNameReference
.
indexOfFirstFieldBinding
>
1
)
{
long
[
]
positions
=
qualifiedNameReference
.
sourcePositions
;
typeAccess
.
setPosition
(
jdtTreeBuilder
.
getPositionBuilder
(
)
.
buildPosition
(
qualifiedNameReference
.
sourceStart
(
)
,
(
int
)
(
positions
[
qualifiedNameReference
.
indexOfFirstFieldBinding
-
1
]
>>>
32
)
-
2
)
)
;
handleImplicit
(
qualifiedNameReference
.
actualReceiverType
.
getPackage
(
)
,
qualifiedNameReference
,
fieldReference
.
getSimpleName
(
)
,
typeAccess
.
getAccessedType
(
)
)
;
}
else
{
typeAccess
.
setImplicit
(
qualifiedNameReference
.
isImplicitThis
(
)
)
;
}
return
typeAccess
;
}
