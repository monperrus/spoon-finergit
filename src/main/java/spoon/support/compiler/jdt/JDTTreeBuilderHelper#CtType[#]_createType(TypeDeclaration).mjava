/** 
 * Creates a class, an enum, an interface or a annotation type.
 * @return a type.
 */
CtType
<
?
>
createType
(
TypeDeclaration
typeDeclaration
)
{
CtType
<
?
>
type
;
if
(
(
typeDeclaration
.
modifiers
&
ClassFileConstants
.
AccAnnotation
)
!=
0
)
{
type
=
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
.
createAnnotationType
(
)
;
}
else
if
(
(
typeDeclaration
.
modifiers
&
ClassFileConstants
.
AccEnum
)
!=
0
)
{
type
=
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
.
createEnum
(
)
;
}
else
if
(
(
typeDeclaration
.
modifiers
&
ClassFileConstants
.
AccInterface
)
!=
0
)
{
type
=
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
.
createInterface
(
)
;
}
else
{
type
=
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
.
createClass
(
)
;
}
jdtTreeBuilder
.
getContextBuilder
(
)
.
enter
(
type
,
typeDeclaration
)
;
if
(
typeDeclaration
.
superInterfaces
!=
null
)
{
for
(
TypeReference
ref
:
typeDeclaration
.
superInterfaces
)
{
final
CtTypeReference
superInterface
=
jdtTreeBuilder
.
references
.
buildTypeReference
(
ref
,
null
)
;
type
.
addSuperInterface
(
superInterface
)
;
}
}
if
(
type
instanceof
CtClass
)
{
if
(
typeDeclaration
.
superclass
!=
null
&&
typeDeclaration
.
superclass
.
resolvedType
!=
null
&&
typeDeclaration
.
enclosingType
!=
null
&&
!
new
String
(
typeDeclaration
.
superclass
.
resolvedType
.
qualifiedPackageName
(
)
)
.
equals
(
new
String
(
typeDeclaration
.
binding
.
qualifiedPackageName
(
)
)
)
)
{
List
<
ModifierKind
>
modifiers
=
Arrays
.
asList
(
ModifierKind
.
PUBLIC
,
ModifierKind
.
PROTECTED
)
;
final
TypeBinding
resolvedType
=
typeDeclaration
.
superclass
.
resolvedType
;
if
(
(
resolvedType
instanceof
MemberTypeBinding
||
resolvedType
instanceof
BinaryTypeBinding
)
&&
resolvedType
.
enclosingType
(
)
!=
null
&&
typeDeclaration
.
enclosingType
.
superclass
!=
null
&&
Collections
.
disjoint
(
modifiers
,
getModifiers
(
resolvedType
.
enclosingType
(
)
.
modifiers
)
)
)
{
typeDeclaration
.
superclass
.
resolvedType
=
jdtTreeBuilder
.
new
SpoonReferenceBinding
(
typeDeclaration
.
superclass
.
resolvedType
.
sourceName
(
)
,
(
ReferenceBinding
)
typeDeclaration
.
enclosingType
.
superclass
.
resolvedType
)
;
}
}
if
(
typeDeclaration
.
superclass
!=
null
)
{
(
(
CtClass
)
type
)
.
setSuperclass
(
jdtTreeBuilder
.
references
.
buildTypeReference
(
typeDeclaration
.
superclass
,
typeDeclaration
.
scope
)
)
;
}
if
(
typeDeclaration
.
binding
.
isAnonymousType
(
)
||
(
typeDeclaration
.
binding
instanceof
LocalTypeBinding
&&
typeDeclaration
.
binding
.
enclosingMethod
(
)
!=
null
)
)
{
type
.
setSimpleName
(
computeAnonymousName
(
typeDeclaration
.
binding
.
constantPoolName
(
)
)
)
;
}
else
{
type
.
setSimpleName
(
new
String
(
typeDeclaration
.
name
)
)
;
}
}
else
{
type
.
setSimpleName
(
new
String
(
typeDeclaration
.
name
)
)
;
}
type
.
setModifiers
(
getModifiers
(
typeDeclaration
.
modifiers
)
)
;
return
type
;
}
