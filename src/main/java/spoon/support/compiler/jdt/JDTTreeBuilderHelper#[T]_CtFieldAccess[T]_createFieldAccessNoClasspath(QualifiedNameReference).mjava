/** 
 * In no classpath mode, when we build a field access, we have a binding typed by ProblemBinding. We try to get all information we can get from this binding.
 * @param qualifiedNameReference Used to get the problem binding of the field access and the name of the declaring type.
 * @return a field access.
 */
<
T
>
CtFieldAccess
<
T
>
createFieldAccessNoClasspath
(
QualifiedNameReference
qualifiedNameReference
)
{
boolean
fromAssignment
=
isLhsAssignment
(
jdtTreeBuilder
.
getContextBuilder
(
)
,
qualifiedNameReference
)
;
CtFieldAccess
<
T
>
fieldAccess
=
createFieldAccess
(
jdtTreeBuilder
.
getReferencesBuilder
(
)
.
getVariableReference
(
(
ProblemBinding
)
qualifiedNameReference
.
binding
)
,
null
,
fromAssignment
)
;
final
char
[
]
[
]
declaringClass
=
CharOperation
.
subarray
(
qualifiedNameReference
.
tokens
,
0
,
qualifiedNameReference
.
tokens
.
length
-
1
)
;
final
MissingTypeBinding
declaringType
=
jdtTreeBuilder
.
getContextBuilder
(
)
.
compilationunitdeclaration
.
scope
.
environment
.
createMissingType
(
null
,
declaringClass
)
;
final
CtTypeReference
<
T
>
declaringRef
=
jdtTreeBuilder
.
getReferencesBuilder
(
)
.
getTypeReference
(
declaringType
)
;
fieldAccess
.
getVariable
(
)
.
setDeclaringType
(
declaringRef
)
;
fieldAccess
.
getVariable
(
)
.
setStatic
(
true
)
;
fieldAccess
.
setTarget
(
jdtTreeBuilder
.
getFactory
(
)
.
Code
(
)
.
createTypeAccess
(
declaringRef
)
)
;
fieldAccess
.
getVariable
(
)
.
setSimpleName
(
createQualifiedTypeName
(
CharOperation
.
subarray
(
qualifiedNameReference
.
tokens
,
qualifiedNameReference
.
tokens
.
length
-
1
,
qualifiedNameReference
.
tokens
.
length
)
)
)
;
return
fieldAccess
;
}
