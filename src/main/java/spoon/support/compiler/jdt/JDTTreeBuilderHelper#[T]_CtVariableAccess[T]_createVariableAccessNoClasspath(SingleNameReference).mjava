/** 
 * Analyzes if  {@code singleNameReference} points to a {@link CtVariable} visible in currentscope and, if existent, returns its corresponding  {@link CtVariableAccess}. Returns {@code null} if {@code singleNameReference} could not be resolved as variable access. Sincewe are in noclasspath mode this function may also returns  {@code null} if{@code singleNameReference} points to a variable declared by an unknown class.
 * @param singleNameReference The potential variable access.
 * @return A {@link CtVariableAccess} if {@code singleNameReference} points to a variablevisible in current scope,  {@code null} otherwise.
 */
<
T
>
CtVariableAccess
<
T
>
createVariableAccessNoClasspath
(
SingleNameReference
singleNameReference
)
{
final
CoreFactory
coreFactory
=
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
;
final
ExecutableFactory
executableFactory
=
jdtTreeBuilder
.
getFactory
(
)
.
Executable
(
)
;
final
ContextBuilder
contextBuilder
=
jdtTreeBuilder
.
getContextBuilder
(
)
;
final
ReferenceBuilder
referenceBuilder
=
jdtTreeBuilder
.
getReferencesBuilder
(
)
;
final
PositionBuilder
positionBuilder
=
jdtTreeBuilder
.
getPositionBuilder
(
)
;
final
String
name
=
CharOperation
.
charToString
(
singleNameReference
.
token
)
;
final
CtVariable
<
T
>
variable
=
contextBuilder
.
getVariableDeclaration
(
name
)
;
if
(
variable
==
null
)
{
return
null
;
}
final
CtVariableReference
<
T
>
variableReference
;
final
CtVariableAccess
<
T
>
variableAccess
;
if
(
variable
instanceof
CtParameter
)
{
final
CtParameterReference
<
T
>
parameterReference
=
coreFactory
.
createParameterReference
(
)
;
if
(
variable
.
getParent
(
)
instanceof
CtLambda
)
{
parameterReference
.
setDeclaringExecutable
(
referenceBuilder
.
getLambdaExecutableReference
(
singleNameReference
)
)
;
}
else
{
final
CtMethod
method
=
(
CtMethod
)
variable
.
getParent
(
)
;
final
List
<
CtTypeReference
<
?
>
>
parameterTypesOfMethod
=
new
ArrayList
<
>
(
)
;
final
List
<
CtParameter
<
?
>
>
parametersOfMethod
=
method
.
getParameters
(
)
;
for
(
CtParameter
<
?
>
parameter
:
parametersOfMethod
)
{
if
(
parameter
.
getType
(
)
!=
null
)
{
parameterTypesOfMethod
.
add
(
parameter
.
getType
(
)
.
clone
(
)
)
;
}
}
MethodDeclaration
methodJDT
=
null
;
for
(
final
ASTPair
astPair
:
contextBuilder
.
stack
)
{
if
(
astPair
.
element
==
method
)
{
methodJDT
=
(
MethodDeclaration
)
astPair
.
node
;
break
;
}
}
assert
methodJDT
!=
null
:
;
final
CtTypeReference
declaringReferenceOfMethod
=
methodJDT
.
binding
==
null
?
coreFactory
.
createTypeReference
(
)
:
referenceBuilder
.
getTypeReference
(
methodJDT
.
binding
.
declaringClass
)
;
final
CtExecutableReference
methodReference
=
executableFactory
.
createReference
(
declaringReferenceOfMethod
,
method
.
getType
(
)
.
clone
(
)
,
method
.
getSimpleName
(
)
,
parameterTypesOfMethod
)
;
parameterReference
.
setDeclaringExecutable
(
methodReference
)
;
}
variableReference
=
parameterReference
;
variableAccess
=
isLhsAssignment
(
contextBuilder
,
singleNameReference
)
?
coreFactory
.
createVariableWrite
(
)
:
coreFactory
.
createVariableRead
(
)
;
}
else
if
(
variable
instanceof
CtField
)
{
variableReference
=
variable
.
getReference
(
)
;
variableAccess
=
isLhsAssignment
(
contextBuilder
,
singleNameReference
)
?
coreFactory
.
createFieldWrite
(
)
:
coreFactory
.
createFieldRead
(
)
;
}
else
{
variableReference
=
variable
.
getReference
(
)
;
variableAccess
=
isLhsAssignment
(
contextBuilder
,
singleNameReference
)
?
coreFactory
.
createVariableWrite
(
)
:
coreFactory
.
createVariableRead
(
)
;
}
variableReference
.
setSimpleName
(
name
)
;
variableReference
.
setPosition
(
positionBuilder
.
buildPosition
(
singleNameReference
.
sourceStart
(
)
,
singleNameReference
.
sourceEnd
(
)
)
)
;
variableAccess
.
setVariable
(
variableReference
)
;
return
variableAccess
;
}
