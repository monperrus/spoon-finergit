SourcePosition
buildPositionCtElement
(
CtElement
e
,
ASTNode
node
)
{
CoreFactory
cf
=
this
.
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
;
CompilationUnit
cu
=
this
.
jdtTreeBuilder
.
getFactory
(
)
.
CompilationUnit
(
)
.
getOrCreate
(
new
String
(
this
.
jdtTreeBuilder
.
getContextBuilder
(
)
.
compilationunitdeclaration
.
getFileName
(
)
)
)
;
CompilationResult
cr
=
this
.
jdtTreeBuilder
.
getContextBuilder
(
)
.
compilationunitdeclaration
.
compilationResult
;
int
[
]
lineSeparatorPositions
=
cr
.
lineSeparatorPositions
;
char
[
]
contents
=
cr
.
compilationUnit
.
getContents
(
)
;
int
sourceStart
=
node
.
sourceStart
;
int
sourceEnd
=
node
.
sourceEnd
;
if
(
(
node
instanceof
Annotation
)
)
{
Annotation
ann
=
(
Annotation
)
node
;
int
declEnd
=
ann
.
declarationSourceEnd
;
if
(
declEnd
>
0
)
{
sourceEnd
=
declEnd
;
}
}
else
if
(
(
node
instanceof
Expression
)
)
{
Expression
expression
=
(
Expression
)
node
;
int
statementEnd
=
expression
.
statementEnd
;
if
(
statementEnd
>
0
)
{
sourceEnd
=
statementEnd
;
}
}
if
(
node
instanceof
TypeParameter
)
{
TypeParameter
typeParameter
=
(
TypeParameter
)
node
;
sourceStart
=
typeParameter
.
declarationSourceStart
;
sourceEnd
=
typeParameter
.
declarationSourceEnd
;
if
(
typeParameter
.
type
!=
null
)
{
sourceEnd
=
getSourceEndOfTypeReference
(
contents
,
typeParameter
.
type
,
sourceEnd
)
;
}
}
else
if
(
node
instanceof
AbstractVariableDeclaration
)
{
AbstractVariableDeclaration
variableDeclaration
=
(
AbstractVariableDeclaration
)
node
;
int
modifiersSourceStart
=
variableDeclaration
.
modifiersSourceStart
;
int
declarationSourceStart
=
variableDeclaration
.
declarationSourceStart
;
int
declarationSourceEnd
=
variableDeclaration
.
declarationSourceEnd
;
Annotation
[
]
annotations
=
variableDeclaration
.
annotations
;
if
(
annotations
!=
null
&&
annotations
.
length
>
0
)
{
if
(
annotations
[
0
]
.
sourceStart
(
)
==
sourceStart
)
{
modifiersSourceStart
=
annotations
[
annotations
.
length
-
1
]
.
sourceEnd
(
)
+
2
;
}
}
if
(
modifiersSourceStart
==
0
)
{
modifiersSourceStart
=
declarationSourceStart
;
}
int
modifiersSourceEnd
;
if
(
variableDeclaration
.
type
!=
null
)
{
modifiersSourceEnd
=
variableDeclaration
.
type
.
sourceStart
(
)
-
2
;
}
else
{
modifiersSourceEnd
=
declarationSourceStart
-
1
;
}
if
(
modifiersSourceStart
>
modifiersSourceEnd
)
{
modifiersSourceEnd
=
modifiersSourceStart
-
1
;
}
return
cf
.
createDeclarationSourcePosition
(
cu
,
sourceStart
,
sourceEnd
,
modifiersSourceStart
,
modifiersSourceEnd
,
declarationSourceStart
,
declarationSourceEnd
,
lineSeparatorPositions
)
;
}
else
if
(
node
instanceof
TypeDeclaration
&&
e
instanceof
CtPackage
)
{
return
cf
.
createSourcePosition
(
cu
,
0
,
contents
.
length
-
1
,
lineSeparatorPositions
)
;
}
else
if
(
node
instanceof
TypeDeclaration
)
{
TypeDeclaration
typeDeclaration
=
(
TypeDeclaration
)
node
;
int
declarationSourceStart
=
typeDeclaration
.
declarationSourceStart
;
int
declarationSourceEnd
=
typeDeclaration
.
declarationSourceEnd
;
int
modifiersSourceStart
=
typeDeclaration
.
modifiersSourceStart
;
int
bodyStart
=
typeDeclaration
.
bodyStart
;
int
bodyEnd
=
typeDeclaration
.
bodyEnd
;
Annotation
[
]
annotations
=
typeDeclaration
.
annotations
;
if
(
annotations
!=
null
&&
annotations
.
length
>
0
)
{
if
(
annotations
[
0
]
.
sourceStart
(
)
==
declarationSourceStart
)
{
modifiersSourceStart
=
findNextNonWhitespace
(
contents
,
declarationSourceEnd
,
annotations
[
annotations
.
length
-
1
]
.
declarationSourceEnd
+
1
)
;
}
}
if
(
modifiersSourceStart
==
0
)
{
modifiersSourceStart
=
declarationSourceStart
;
}
int
modifiersSourceEnd
=
findPrevNonWhitespace
(
contents
,
modifiersSourceStart
-
1
,
findPrevWhitespace
(
contents
,
modifiersSourceStart
-
1
,
findPrevNonWhitespace
(
contents
,
modifiersSourceStart
-
1
,
sourceStart
-
1
)
)
)
;
if
(
modifiersSourceEnd
<
modifiersSourceStart
)
{
modifiersSourceEnd
=
modifiersSourceStart
-
1
;
}
if
(
typeDeclaration
.
name
.
length
==
0
)
{
sourceEnd
=
sourceStart
-
1
;
if
(
contents
[
sourceStart
]
==
'{'
)
{
bodyEnd
++
;
}
}
return
cf
.
createBodyHolderSourcePosition
(
cu
,
sourceStart
,
sourceEnd
,
modifiersSourceStart
,
modifiersSourceEnd
,
declarationSourceStart
,
declarationSourceEnd
,
bodyStart
-
1
,
bodyEnd
,
lineSeparatorPositions
)
;
}
else
if
(
node
instanceof
AbstractMethodDeclaration
)
{
AbstractMethodDeclaration
methodDeclaration
=
(
AbstractMethodDeclaration
)
node
;
int
bodyStart
=
methodDeclaration
.
bodyStart
;
int
bodyEnd
=
methodDeclaration
.
bodyEnd
;
int
declarationSourceStart
=
methodDeclaration
.
declarationSourceStart
;
int
declarationSourceEnd
=
methodDeclaration
.
declarationSourceEnd
;
int
modifiersSourceStart
=
methodDeclaration
.
modifiersSourceStart
;
if
(
modifiersSourceStart
==
0
)
{
modifiersSourceStart
=
declarationSourceStart
;
}
if
(
node
instanceof
AnnotationMethodDeclaration
&&
bodyStart
==
bodyEnd
)
{
bodyEnd
--
;
}
Javadoc
javadoc
=
methodDeclaration
.
javadoc
;
if
(
javadoc
!=
null
&&
javadoc
.
sourceEnd
(
)
>
declarationSourceStart
)
{
modifiersSourceStart
=
javadoc
.
sourceEnd
(
)
+
1
;
}
Annotation
[
]
annotations
=
methodDeclaration
.
annotations
;
if
(
annotations
!=
null
&&
annotations
.
length
>
0
)
{
if
(
annotations
[
0
]
.
sourceStart
(
)
==
declarationSourceStart
)
{
modifiersSourceStart
=
annotations
[
annotations
.
length
-
1
]
.
sourceEnd
(
)
+
2
;
}
}
int
modifiersSourceEnd
=
sourceStart
-
1
;
if
(
methodDeclaration
instanceof
MethodDeclaration
&&
(
(
MethodDeclaration
)
methodDeclaration
)
.
returnType
!=
null
)
{
modifiersSourceEnd
=
(
(
MethodDeclaration
)
methodDeclaration
)
.
returnType
.
sourceStart
(
)
-
2
;
}
TypeParameter
[
]
typeParameters
=
methodDeclaration
.
typeParameters
(
)
;
if
(
typeParameters
!=
null
&&
typeParameters
.
length
>
0
)
{
modifiersSourceEnd
=
typeParameters
[
0
]
.
declarationSourceStart
-
3
;
}
if
(
getModifiers
(
methodDeclaration
.
modifiers
,
false
,
true
)
.
isEmpty
(
)
)
{
modifiersSourceEnd
=
modifiersSourceStart
-
1
;
}
sourceEnd
=
sourceStart
+
methodDeclaration
.
selector
.
length
-
1
;
if
(
bodyStart
==
0
)
{
return
SourcePosition
.
NOPOSITION
;
}
if
(
e
instanceof
CtStatementList
)
{
return
cf
.
createSourcePosition
(
cu
,
bodyStart
-
1
,
bodyEnd
+
1
,
lineSeparatorPositions
)
;
}
else
{
if
(
bodyStart
<
bodyEnd
)
{
if
(
contents
[
bodyStart
-
1
]
==
'{'
)
{
bodyStart
--
;
if
(
contents
[
bodyEnd
+
1
]
==
'}'
)
{
bodyEnd
++
;
}
else
{
throw
new
SpoonException
(
"Missing body end in\n"
+
new
String
(
contents
,
sourceStart
,
sourceEnd
-
sourceStart
)
)
;
}
}
}
return
cf
.
createBodyHolderSourcePosition
(
cu
,
sourceStart
,
sourceEnd
,
modifiersSourceStart
,
modifiersSourceEnd
,
declarationSourceStart
,
declarationSourceEnd
,
bodyStart
,
bodyEnd
,
lineSeparatorPositions
)
;
}
}
else
if
(
node
instanceof
TypeReference
)
{
sourceEnd
=
getSourceEndOfTypeReference
(
contents
,
(
TypeReference
)
node
,
sourceEnd
)
;
}
return
cf
.
createSourcePosition
(
cu
,
sourceStart
,
sourceEnd
,
lineSeparatorPositions
)
;
}
