/** 
 * Try to get the declaring reference (package or type) from imports of the current compilation unit declaration (current class). This method returns a CtReference which can be a CtTypeReference if it retrieves the information in an static import, a CtPackageReference if it retrieves the information in an standard import, otherwise it returns null.
 * @param expectedName Name expected in imports.
 * @return CtReference which can be a CtTypeReference, a CtPackageReference or null.
 */
CtReference
getDeclaringReferenceFromImports
(
char
[
]
expectedName
)
{
if
(
this
.
jdtTreeBuilder
.
getContextBuilder
(
)
.
compilationunitdeclaration
!=
null
&&
this
.
jdtTreeBuilder
.
getContextBuilder
(
)
.
compilationunitdeclaration
.
imports
!=
null
)
{
for
(
ImportReference
anImport
:
this
.
jdtTreeBuilder
.
getContextBuilder
(
)
.
compilationunitdeclaration
.
imports
)
{
if
(
CharOperation
.
equals
(
anImport
.
getImportName
(
)
[
anImport
.
getImportName
(
)
.
length
-
1
]
,
expectedName
)
)
{
if
(
anImport
.
isStatic
(
)
)
{
int
indexDeclaring
=
2
;
if
(
(
anImport
.
bits
&
ASTNode
.
OnDemand
)
!=
0
)
{
indexDeclaring
=
1
;
}
char
[
]
[
]
packageName
=
CharOperation
.
subarray
(
anImport
.
getImportName
(
)
,
0
,
anImport
.
getImportName
(
)
.
length
-
indexDeclaring
)
;
char
[
]
[
]
className
=
CharOperation
.
subarray
(
anImport
.
getImportName
(
)
,
anImport
.
getImportName
(
)
.
length
-
indexDeclaring
,
anImport
.
getImportName
(
)
.
length
-
(
indexDeclaring
-
1
)
)
;
PackageBinding
aPackage
;
if
(
packageName
.
length
!=
0
)
{
aPackage
=
this
.
jdtTreeBuilder
.
getContextBuilder
(
)
.
compilationunitdeclaration
.
scope
.
environment
.
createPackage
(
packageName
)
;
}
else
{
aPackage
=
null
;
}
final
MissingTypeBinding
declaringType
=
this
.
jdtTreeBuilder
.
getContextBuilder
(
)
.
compilationunitdeclaration
.
scope
.
environment
.
createMissingType
(
aPackage
,
className
)
;
this
.
jdtTreeBuilder
.
getContextBuilder
(
)
.
ignoreComputeImports
=
true
;
final
CtTypeReference
<
Object
>
typeReference
=
getTypeReference
(
declaringType
)
;
this
.
jdtTreeBuilder
.
getContextBuilder
(
)
.
ignoreComputeImports
=
false
;
return
typeReference
;
}
else
{
PackageBinding
packageBinding
=
null
;
char
[
]
[
]
chars
=
CharOperation
.
subarray
(
anImport
.
getImportName
(
)
,
0
,
anImport
.
getImportName
(
)
.
length
-
1
)
;
if
(
chars
.
length
>
0
)
{
Binding
someBinding
=
this
.
jdtTreeBuilder
.
getContextBuilder
(
)
.
compilationunitdeclaration
.
scope
.
findImport
(
chars
,
false
,
false
)
;
if
(
someBinding
!=
null
&&
someBinding
.
isValidBinding
(
)
&&
someBinding
instanceof
PackageBinding
)
{
packageBinding
=
(
PackageBinding
)
someBinding
;
}
else
{
packageBinding
=
this
.
jdtTreeBuilder
.
getContextBuilder
(
)
.
compilationunitdeclaration
.
scope
.
environment
.
createPackage
(
chars
)
;
}
}
if
(
packageBinding
==
null
)
{
packageBinding
=
new
PackageBinding
(
chars
,
null
,
this
.
jdtTreeBuilder
.
getContextBuilder
(
)
.
compilationunitdeclaration
.
scope
.
environment
)
;
}
return
getPackageReference
(
packageBinding
)
;
}
}
}
}
return
null
;
}
