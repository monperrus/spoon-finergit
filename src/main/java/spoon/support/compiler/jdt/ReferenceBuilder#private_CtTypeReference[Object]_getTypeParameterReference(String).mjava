/** 
 * Try to build a CtTypeParameterReference from a single name with specified generic types but keep in mind that if you give wrong data in the strong, reference will be wrong.
 */
private
CtTypeReference
<
Object
>
getTypeParameterReference
(
String
name
)
{
CtTypeReference
<
Object
>
param
=
null
;
if
(
name
.
contains
(
"extends"
)
||
name
.
contains
(
"super"
)
)
{
String
[
]
split
=
name
.
contains
(
"extends"
)
?
name
.
split
(
"extends"
)
:
name
.
split
(
"super"
)
;
param
=
getTypeParameterReference
(
split
[
0
]
.
trim
(
)
)
;
(
(
CtTypeParameterReference
)
param
)
.
setBoundingType
(
getTypeReference
(
split
[
split
.
length
-
1
]
.
trim
(
)
)
)
;
}
else
if
(
name
.
matches
(
".*(<.+>)"
)
)
{
Pattern
pattern
=
Pattern
.
compile
(
"([^<]+)<(.+)>"
)
;
Matcher
m
=
pattern
.
matcher
(
name
)
;
if
(
m
.
find
(
)
)
{
param
=
this
.
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
.
createTypeReference
(
)
;
param
.
setSimpleName
(
m
.
group
(
1
)
)
;
final
String
[
]
split
=
m
.
group
(
2
)
.
split
(
","
)
;
for
(
String
parameter
:
split
)
{
param
.
addActualTypeArgument
(
getTypeParameterReference
(
parameter
.
trim
(
)
)
)
;
}
}
}
else
if
(
name
.
contains
(
"?"
)
)
{
param
=
this
.
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
.
createWildcardReference
(
)
;
}
else
{
param
=
this
.
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
.
createTypeParameterReference
(
)
;
param
.
setSimpleName
(
name
)
;
}
return
param
;
}
