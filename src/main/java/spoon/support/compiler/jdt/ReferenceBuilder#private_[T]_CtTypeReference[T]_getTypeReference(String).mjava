/** 
 * Try to build a CtTypeReference from a simple name with specified generic types but returns null if the name doesn't correspond to a type (not start by an upper case).
 */
private
<
T
>
CtTypeReference
<
T
>
getTypeReference
(
String
name
)
{
CtTypeReference
<
T
>
main
=
null
;
if
(
name
.
matches
(
".*(<.+>)"
)
)
{
Pattern
pattern
=
Pattern
.
compile
(
"([^<]+)<(.+)>"
)
;
Matcher
m
=
pattern
.
matcher
(
name
)
;
if
(
name
.
startsWith
(
"?"
)
)
{
main
=
(
CtTypeReference
)
this
.
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
.
createWildcardReference
(
)
;
}
else
{
main
=
this
.
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
.
createTypeReference
(
)
;
}
if
(
m
.
find
(
)
)
{
main
.
setSimpleName
(
m
.
group
(
1
)
)
;
final
String
[
]
split
=
m
.
group
(
2
)
.
split
(
","
)
;
for
(
String
parameter
:
split
)
{
main
.
addActualTypeArgument
(
getTypeParameterReference
(
parameter
.
trim
(
)
)
)
;
}
}
}
else
if
(
Character
.
isUpperCase
(
name
.
charAt
(
0
)
)
)
{
if
(
name
.
endsWith
(
"[]"
)
)
{
main
=
this
.
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
.
createArrayTypeReference
(
)
;
name
=
name
.
substring
(
0
,
name
.
length
(
)
-
2
)
;
(
(
CtArrayTypeReference
<
T
>
)
main
)
.
setComponentType
(
this
.
getTypeReference
(
name
)
)
;
}
else
{
main
=
this
.
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
.
createTypeReference
(
)
;
}
main
.
setSimpleName
(
name
)
;
final
CtReference
declaring
=
this
.
getDeclaringReferenceFromImports
(
name
.
toCharArray
(
)
)
;
setPackageOrDeclaringType
(
main
,
declaring
)
;
}
else
if
(
name
.
startsWith
(
"?"
)
)
{
return
(
CtTypeReference
)
this
.
jdtTreeBuilder
.
getFactory
(
)
.
Core
(
)
.
createWildcardReference
(
)
;
}
return
main
;
}
