/** 
 * In noclasspath, lambda doesn't have always a binding for their variables accesses in their block/expression. Here, we make the job of JDT and bind their variables accesses to their parameters.
 * @param singleNameReference Name of the variable access.
 * @return executable reference which corresponds to the lambda.
 */
public
CtExecutableReference
<
?
>
getLambdaExecutableReference
(
SingleNameReference
singleNameReference
)
{
ASTPair
potentialLambda
=
null
;
for
(
ASTPair
astPair
:
jdtTreeBuilder
.
getContextBuilder
(
)
.
stack
)
{
if
(
astPair
.
node
instanceof
LambdaExpression
)
{
potentialLambda
=
astPair
;
break
;
}
}
if
(
potentialLambda
==
null
)
{
return
null
;
}
LambdaExpression
lambdaJDT
=
(
LambdaExpression
)
potentialLambda
.
node
;
for
(
Argument
argument
:
lambdaJDT
.
arguments
(
)
)
{
if
(
CharOperation
.
equals
(
argument
.
name
,
singleNameReference
.
token
)
)
{
CtTypeReference
<
?
>
declaringType
=
null
;
if
(
lambdaJDT
.
enclosingScope
instanceof
MethodScope
)
{
declaringType
=
jdtTreeBuilder
.
getReferencesBuilder
(
)
.
getTypeReference
(
(
(
MethodScope
)
lambdaJDT
.
enclosingScope
)
.
parent
.
enclosingSourceType
(
)
)
;
}
CtLambda
<
?
>
ctLambda
=
(
CtLambda
<
?
>
)
potentialLambda
.
element
;
List
<
CtTypeReference
<
?
>
>
parametersType
=
new
ArrayList
<
>
(
)
;
List
<
CtParameter
<
?
>
>
parameters
=
ctLambda
.
getParameters
(
)
;
for
(
CtParameter
<
?
>
parameter
:
parameters
)
{
parametersType
.
add
(
getMethodParameterType
(
parameter
)
)
;
}
return
jdtTreeBuilder
.
getFactory
(
)
.
Executable
(
)
.
createReference
(
declaringType
,
ctLambda
.
getType
(
)
,
ctLambda
.
getSimpleName
(
)
,
parametersType
)
;
}
}
return
null
;
}
