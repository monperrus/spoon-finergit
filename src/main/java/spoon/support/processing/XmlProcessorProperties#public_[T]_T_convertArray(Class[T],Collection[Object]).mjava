/** 
 * Converts a collection of object into an array of type <code>type</code>.
 * @param < T > the actual type of the array
 * @param type the type to convert the object into
 * @param val the collection to be converted
 * @return an array of type T
 */
@SuppressWarnings("unchecked")
public
<
T
>
T
convertArray
(
Class
<
T
>
type
,
Collection
<
Object
>
val
)
{
if
(
type
.
equals
(
boolean
.
class
)
)
{
boolean
[
]
ret
=
new
boolean
[
]
;
int
i
=
0
;
for
(
Object
o
:
val
)
{
ret
[
i
++
]
=
convert
(
boolean
.
class
,
o
)
;
}
return
(
T
)
ret
;
}
else
if
(
type
.
equals
(
byte
.
class
)
)
{
byte
[
]
ret
=
new
byte
[
]
;
int
i
=
0
;
for
(
Object
o
:
val
)
{
ret
[
i
++
]
=
convert
(
byte
.
class
,
o
)
;
}
return
(
T
)
ret
;
}
else
if
(
type
.
equals
(
char
.
class
)
)
{
char
[
]
ret
=
new
char
[
]
;
int
i
=
0
;
for
(
Object
o
:
val
)
{
ret
[
i
++
]
=
convert
(
char
.
class
,
o
)
;
}
return
(
T
)
ret
;
}
else
if
(
type
.
equals
(
double
.
class
)
)
{
double
[
]
ret
=
new
double
[
]
;
int
i
=
0
;
for
(
Object
o
:
val
)
{
ret
[
i
++
]
=
convert
(
double
.
class
,
o
)
;
}
return
(
T
)
ret
;
}
else
if
(
type
.
equals
(
float
.
class
)
)
{
float
[
]
ret
=
new
float
[
]
;
int
i
=
0
;
for
(
Object
o
:
val
)
{
ret
[
i
++
]
=
convert
(
float
.
class
,
o
)
;
}
return
(
T
)
ret
;
}
else
if
(
type
.
equals
(
int
.
class
)
)
{
int
[
]
ret
=
new
int
[
]
;
int
i
=
0
;
for
(
Object
o
:
val
)
{
ret
[
i
++
]
=
convert
(
int
.
class
,
o
)
;
}
return
(
T
)
ret
;
}
else
if
(
type
.
equals
(
long
.
class
)
)
{
long
[
]
ret
=
new
long
[
]
;
int
i
=
0
;
for
(
Object
o
:
val
)
{
ret
[
i
++
]
=
convert
(
long
.
class
,
o
)
;
}
return
(
T
)
ret
;
}
else
if
(
type
.
equals
(
String
.
class
)
)
{
String
[
]
ret
=
new
String
[
]
;
int
i
=
0
;
for
(
Object
o
:
val
)
{
ret
[
i
++
]
=
convert
(
String
.
class
,
o
)
;
}
return
(
T
)
ret
;
}
else
if
(
CtPackageReference
.
class
.
isAssignableFrom
(
type
)
)
{
CtPackageReference
[
]
ret
=
new
CtPackageReference
[
]
;
int
i
=
0
;
for
(
Object
o
:
val
)
{
ret
[
i
++
]
=
convert
(
CtPackageReference
.
class
,
o
)
;
}
return
(
T
)
ret
;
}
else
if
(
CtTypeReference
.
class
.
isAssignableFrom
(
type
)
)
{
CtTypeReference
<
?
>
[
]
ret
=
new
CtTypeReference
[
]
;
int
i
=
0
;
for
(
Object
o
:
val
)
{
ret
[
i
++
]
=
convert
(
CtTypeReference
.
class
,
o
)
;
}
return
(
T
)
ret
;
}
else
if
(
CtFieldReference
.
class
.
isAssignableFrom
(
type
)
)
{
CtFieldReference
<
?
>
[
]
ret
=
new
CtFieldReference
[
]
;
int
i
=
0
;
for
(
Object
o
:
val
)
{
ret
[
i
++
]
=
convert
(
CtFieldReference
.
class
,
o
)
;
}
return
(
T
)
ret
;
}
else
if
(
CtExecutableReference
.
class
.
isAssignableFrom
(
type
)
)
{
CtExecutableReference
<
?
>
[
]
ret
=
new
CtExecutableReference
[
]
;
int
i
=
0
;
for
(
Object
o
:
val
)
{
ret
[
i
++
]
=
convert
(
CtExecutableReference
.
class
,
o
)
;
}
return
(
T
)
ret
;
}
else
if
(
type
.
isEnum
(
)
)
{
Collection
<
Enum
<
?
>
>
ret
=
new
ArrayList
<
>
(
)
;
for
(
Object
o
:
val
)
{
ret
.
add
(
(
Enum
<
?
>
)
convert
(
type
,
o
)
)
;
}
return
(
T
)
ret
.
toArray
(
(
Enum
[
]
)
Array
.
newInstance
(
type
,
0
)
)
;
}
return
null
;
}
