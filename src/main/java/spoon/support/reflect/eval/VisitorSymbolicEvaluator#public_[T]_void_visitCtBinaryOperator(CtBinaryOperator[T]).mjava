public
<
T
>
void
visitCtBinaryOperator
(
CtBinaryOperator
<
T
>
operator
)
{
SymbolicInstance
<
?
>
left
=
evaluate
(
operator
.
getLeftHandOperand
(
)
)
;
SymbolicInstance
<
?
>
right
=
evaluate
(
operator
.
getRightHandOperand
(
)
)
;
switch
(
operator
.
getKind
(
)
)
{
case
AND
:
case
OR
:
case
EQ
:
if
(
left
.
equalsRef
(
right
)
)
{
result
=
SymbolicInstance
.
TRUE
;
}
else
{
result
=
SymbolicInstance
.
FALSE
;
}
return
;
case
NE
:
if
(
!
left
.
equalsRef
(
right
)
)
{
result
=
SymbolicInstance
.
TRUE
;
}
else
{
result
=
SymbolicInstance
.
FALSE
;
}
return
;
case
GE
:
case
LE
:
case
GT
:
case
LT
:
case
INSTANCEOF
:
SymbolicInstance
<
Boolean
>
bool
=
new
SymbolicInstance
<
Boolean
>
(
this
,
operator
.
getFactory
(
)
.
Type
(
)
.
createReference
(
boolean
.
class
)
,
false
)
;
result
=
bool
;
return
;
case
MINUS
:
case
MUL
:
case
DIV
:
SymbolicInstance
<
Number
>
number
=
new
SymbolicInstance
<
Number
>
(
this
,
operator
.
getFactory
(
)
.
Type
(
)
.
createReference
(
Number
.
class
)
,
false
)
;
result
=
number
;
return
;
case
PLUS
:
if
(
(
left
.
getConcreteType
(
)
!=
null
)
&&
(
(
left
.
getConcreteType
(
)
.
getActualClass
(
)
==
String
.
class
)
||
(
right
.
getConcreteType
(
)
.
getActualClass
(
)
==
String
.
class
)
)
)
{
SymbolicInstance
<
String
>
string
=
new
SymbolicInstance
<
String
>
(
this
,
operator
.
getFactory
(
)
.
Type
(
)
.
createReference
(
String
.
class
)
,
false
)
;
result
=
string
;
return
;
}
bool
=
new
SymbolicInstance
<
Boolean
>
(
this
,
operator
.
getFactory
(
)
.
Type
(
)
.
createReference
(
boolean
.
class
)
,
false
)
;
result
=
bool
;
return
;
default
:
throw
new
RuntimeException
(
"unsupported operator"
)
;
}
}
