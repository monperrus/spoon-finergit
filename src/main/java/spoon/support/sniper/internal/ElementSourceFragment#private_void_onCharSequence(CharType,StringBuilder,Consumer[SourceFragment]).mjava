private
void
onCharSequence
(
CharType
type
,
StringBuilder
buff
,
Consumer
<
SourceFragment
>
consumer
)
{
if
(
type
==
CharType
.
SPACE
)
{
consumer
.
accept
(
new
TokenSourceFragment
(
buff
.
toString
(
)
,
TokenType
.
SPACE
)
)
;
return
;
}
char
[
]
str
=
new
char
[
]
;
buff
.
getChars
(
0
,
buff
.
length
(
)
,
str
,
0
)
;
int
off
=
0
;
while
(
off
<
str
.
length
)
{
int
lenOfIdentifier
=
detectJavaIdentifier
(
str
,
off
)
;
if
(
lenOfIdentifier
>
0
)
{
String
identifier
=
new
String
(
str
,
off
,
lenOfIdentifier
)
;
if
(
javaKeywords
.
contains
(
identifier
)
)
{
consumer
.
accept
(
new
TokenSourceFragment
(
identifier
,
TokenType
.
KEYWORD
)
)
;
}
else
{
consumer
.
accept
(
new
TokenSourceFragment
(
identifier
,
TokenType
.
IDENTIFIER
)
)
;
}
off
=
lenOfIdentifier
;
continue
;
}
StringMatcher
longestMatcher
=
null
;
for
(
StringMatcher
strMatcher
:
matchers
)
{
if
(
strMatcher
.
isMatch
(
str
,
off
)
)
{
longestMatcher
=
strMatcher
.
getLonger
(
longestMatcher
)
;
}
}
if
(
longestMatcher
==
null
)
{
throw
new
SpoonException
(
"Unexpected source text: "
+
buff
.
toString
(
)
)
;
}
consumer
.
accept
(
new
TokenSourceFragment
(
longestMatcher
.
toString
(
)
,
longestMatcher
.
getType
(
)
)
)
;
off
=
longestMatcher
.
getLength
(
)
;
}
}
