/** 
 * Builds tree of  {@link SourcePosition}s of `element` and all it's children
 * @param element the root element of the tree
 */
public
void
addTreeOfSourceFragmentsOfElement
(
CtElement
element
)
{
Deque
<
ElementSourceFragment
>
parents
=
new
ArrayDeque
<
>
(
)
;
parents
.
push
(
this
)
;
new
EarlyTerminatingScanner
<
Void
>
(
)
{
public
<
T
>
void
visitCtFieldReference
(
final
CtFieldReference
<
T
>
reference
)
{
enter
(
reference
)
;
scan
(
CtRole
.
DECLARING_TYPE
,
reference
.
getDeclaringType
(
)
)
;
scan
(
CtRole
.
ANNOTATION
,
reference
.
getAnnotations
(
)
)
;
exit
(
reference
)
;
}
@Override
protected
void
enter
(
CtElement
e
)
{
if
(
e
instanceof
CtCompilationUnit
)
{
return
;
}
ElementSourceFragment
newFragment
=
addChild
(
parents
.
peek
(
)
,
scannedRole
,
e
)
;
if
(
newFragment
!=
null
)
{
parents
.
push
(
newFragment
)
;
if
(
e
instanceof
CtModifiable
)
{
CtModifiable
modifiable
=
(
CtModifiable
)
e
;
Set
<
CtExtendedModifier
>
modifiers
=
modifiable
.
getExtendedModifiers
(
)
;
for
(
CtExtendedModifier
ctExtendedModifier
:
modifiers
)
{
addChild
(
newFragment
,
CtRole
.
MODIFIER
,
ctExtendedModifier
)
;
}
}
}
}
@Override
protected
void
exit
(
CtElement
e
)
{
if
(
e
instanceof
CtCompilationUnit
)
{
return
;
}
ElementSourceFragment
topFragment
=
parents
.
peek
(
)
;
if
(
topFragment
!=
null
&&
topFragment
.
getElement
(
)
==
e
)
{
parents
.
pop
(
)
;
}
}
}
.
setVisitCompilationUnitContent
(
true
)
.
scan
(
element
.
getRoleInParent
(
)
,
element
)
;
}
