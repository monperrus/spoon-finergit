/** 
 * resolve typeRefs declared in scope of declarer using actual type arguments registered in typeScopeToActualTypeArguments
 * @param typeRefs to be resolved type references
 * @return resolved type references - one for each `typeRefs`
 * @throws SpoonException if they cannot be resolved. It should not normally happen. If it happens then spoon AST model is probably not consistent.
 */
private
List
<
CtTypeReference
<
?
>
>
resolveTypeParameters
(
List
<
CtTypeReference
<
?
>
>
typeRefs
)
{
List
<
CtTypeReference
<
?
>
>
result
=
new
ArrayList
<
>
(
typeRefs
.
size
(
)
)
;
for
(
CtTypeReference
<
?
>
typeRef
:
typeRefs
)
{
if
(
typeRef
instanceof
CtTypeParameterReference
)
{
CtTypeParameterReference
typeParamRef
=
(
CtTypeParameterReference
)
typeRef
;
CtTypeParameter
typeParam
=
typeParamRef
.
getDeclaration
(
)
;
CtFormalTypeDeclarer
declarer
=
typeParam
.
getTypeParameterDeclarer
(
)
;
if
(
(
declarer
instanceof
CtType
<
?
>
)
==
false
)
{
throw
new
SpoonException
(
"Cannot adapt type parameters of non type scope"
)
;
}
CtType
<
?
>
typeDeclarer
=
(
CtType
<
?
>
)
declarer
;
List
<
CtTypeReference
<
?
>
>
actualTypeArguments
=
getActualTypeArguments
(
typeDeclarer
.
getQualifiedName
(
)
)
;
if
(
actualTypeArguments
==
null
)
{
throw
new
SpoonException
(
"Cannot resolve "
+
(
result
.
size
(
)
+
1
)
+
") type parameter <"
+
typeParamRef
.
getSimpleName
(
)
+
">  of declarer "
+
declarer
)
;
}
if
(
actualTypeArguments
.
size
(
)
!=
typeDeclarer
.
getFormalCtTypeParameters
(
)
.
size
(
)
)
{
if
(
actualTypeArguments
.
isEmpty
(
)
==
false
)
{
throw
new
SpoonException
(
"Unexpected actual type arguments "
+
actualTypeArguments
+
" on "
+
typeDeclarer
)
;
}
actualTypeArguments
=
getTypeReferences
(
typeDeclarer
.
getFormalCtTypeParameters
(
)
)
;
typeToArguments
.
put
(
typeDeclarer
.
getQualifiedName
(
)
,
actualTypeArguments
)
;
}
typeRef
=
getValue
(
actualTypeArguments
,
typeParam
,
declarer
)
;
}
result
.
add
(
typeRef
)
;
}
return
result
;
}
