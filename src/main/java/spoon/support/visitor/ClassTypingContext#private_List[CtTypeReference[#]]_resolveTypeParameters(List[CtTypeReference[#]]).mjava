/** 
 * resolve typeRefs declared in scope of declarer using actual type arguments registered in typeScopeToActualTypeArguments
 * @param typeRefs to be resolved type references
 * @return resolved type references - one for each `typeRefs`
 * @throws SpoonException if they cannot be resolved. It should not normally happen. If it happens then spoon AST model is probably not consistent.
 */
private
List
<
CtTypeReference
<
?
>
>
resolveTypeParameters
(
List
<
CtTypeReference
<
?
>
>
typeRefs
)
{
List
<
CtTypeReference
<
?
>
>
result
=
new
ArrayList
<
>
(
typeRefs
.
size
(
)
)
;
for
(
CtTypeReference
<
?
>
typeRef
:
typeRefs
)
{
if
(
typeRef
instanceof
CtTypeParameterReference
)
{
CtTypeParameterReference
typeParamRef
=
(
CtTypeParameterReference
)
typeRef
;
CtTypeParameter
typeParam
=
typeParamRef
.
getDeclaration
(
)
;
if
(
typeParam
==
null
)
{
throw
new
SpoonException
(
"The typeParam "
+
typeRef
.
getQualifiedName
(
)
+
" declaration cannot be resolved"
)
;
}
CtFormalTypeDeclarer
declarer
=
typeParam
.
getTypeParameterDeclarer
(
)
;
typeRef
=
resolveTypeParameter
(
declarer
,
typeParamRef
,
typeParam
,
typeRef
)
;
}
result
.
add
(
typeRef
)
;
}
return
result
;
}
