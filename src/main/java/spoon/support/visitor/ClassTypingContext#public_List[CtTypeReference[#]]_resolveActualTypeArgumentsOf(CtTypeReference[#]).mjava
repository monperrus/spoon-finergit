/** 
 * resolve actual type argument values of the provided type reference
 * @param typeRef the reference to the typewhose actual type argument values has to be resolved in scope of `scope` type
 * @return actual type arguments of `typeRef` in scope of `scope` element or null if typeRef is not a super type of `scope`
 */
public
List
<
CtTypeReference
<
?
>
>
resolveActualTypeArgumentsOf
(
CtTypeReference
<
?
>
typeRef
)
{
final
String
typeQualifiedName
=
typeRef
.
getQualifiedName
(
)
;
List
<
CtTypeReference
<
?
>
>
args
=
typeToArguments
.
get
(
typeQualifiedName
)
;
if
(
args
!=
null
)
{
return
args
;
}
CtTypeReference
<
?
>
enclosingTypeRef
=
getEnclosingType
(
typeRef
)
;
if
(
enclosingTypeRef
!=
null
)
{
if
(
enclosingClassTypingContext
==
null
)
{
return
null
;
}
if
(
enclosingClassTypingContext
.
resolveActualTypeArgumentsOf
(
enclosingTypeRef
)
==
null
)
{
return
null
;
}
}
if
(
lastResolvedSuperclass
==
null
)
{
return
null
;
}
final
HierarchyListener
listener
=
new
HierarchyListener
(
getVisitedSet
(
)
)
;
(
(
CtElement
)
lastResolvedSuperclass
)
.
map
(
new
SuperInheritanceHierarchyFunction
(
)
.
includingSelf
(
false
)
.
returnTypeReferences
(
true
)
.
setListener
(
listener
)
)
.
forEach
(
new
CtConsumer
<
CtTypeReference
<
?
>
>
(
)
{
@Override
public
void
accept
(
CtTypeReference
<
?
>
typeRef
)
{
String
superTypeQualifiedName
=
typeRef
.
getQualifiedName
(
)
;
List
<
CtTypeReference
<
?
>
>
superTypeActualTypeArgumentsResolvedFromSubType
=
resolveTypeParameters
(
typeRef
.
getActualTypeArguments
(
)
)
;
typeToArguments
.
put
(
superTypeQualifiedName
,
superTypeActualTypeArgumentsResolvedFromSubType
)
;
if
(
typeQualifiedName
.
equals
(
superTypeQualifiedName
)
)
{
listener
.
foundArguments
=
superTypeActualTypeArgumentsResolvedFromSubType
;
}
}
}
)
;
return
listener
.
foundArguments
;
}
