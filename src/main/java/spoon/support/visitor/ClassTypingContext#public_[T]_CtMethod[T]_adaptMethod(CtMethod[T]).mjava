/** 
 * @param method to be adapted to this context
 * @return new method whose parameters are adapted to `this context` or the same`method` if there is no need to adapt it
 */
public
<
T
>
CtMethod
<
T
>
adaptMethod
(
CtMethod
<
T
>
method
)
{
CtType
<
?
>
declType
=
method
.
getDeclaringType
(
)
;
if
(
declType
==
null
)
{
throw
new
SpoonException
(
"Cannot adapt method, which has no declaringType"
)
;
}
if
(
getAdaptationScope
(
)
==
declType
)
{
return
method
;
}
if
(
isSubtypeOf
(
declType
.
getReference
(
)
)
==
false
)
{
throw
new
SpoonException
(
"Cannot create MethodTypingContext for method declared in different ClassTypingContext"
)
;
}
Factory
factory
=
method
.
getFactory
(
)
;
CtMethod
<
T
>
adaptedMethod
=
factory
.
Core
(
)
.
createMethod
(
)
;
adaptedMethod
.
setParent
(
getAdaptationScope
(
)
)
;
adaptedMethod
.
setModifiers
(
method
.
getModifiers
(
)
)
;
adaptedMethod
.
setSimpleName
(
method
.
getSimpleName
(
)
)
;
for
(
CtTypeReference
<
?
Throwable
>
thrownType
:
method
.
getThrownTypes
(
)
)
{
adaptedMethod
.
addThrownType
(
thrownType
.
clone
(
)
)
;
}
for
(
CtTypeParameter
typeParam
:
method
.
getFormalCtTypeParameters
(
)
)
{
CtTypeParameter
newTypeParam
=
typeParam
.
clone
(
)
;
newTypeParam
.
setSuperclass
(
adaptTypeForNewMethod
(
typeParam
.
getSuperclass
(
)
)
)
;
adaptedMethod
.
addFormalCtTypeParameter
(
newTypeParam
)
;
}
adaptedMethod
.
setType
(
(
CtTypeReference
)
adaptTypeForNewMethod
(
method
.
getType
(
)
)
)
;
List
<
CtParameter
<
?
>
>
adaptedParams
=
new
ArrayList
<
>
(
method
.
getParameters
(
)
.
size
(
)
)
;
for
(
CtParameter
<
?
>
parameter
:
method
.
getParameters
(
)
)
{
adaptedParams
.
add
(
factory
.
Executable
(
)
.
createParameter
(
null
,
adaptTypeForNewMethod
(
parameter
.
getType
(
)
)
,
parameter
.
getSimpleName
(
)
)
)
;
}
adaptedMethod
.
setParameters
(
adaptedParams
)
;
return
adaptedMethod
;
}
