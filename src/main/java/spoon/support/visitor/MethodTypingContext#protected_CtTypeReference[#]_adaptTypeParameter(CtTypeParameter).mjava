/** 
 * adapts `typeParam` to the  {@link CtTypeReference}of scope of this  {@link MethodTypingContext}In can be  {@link CtTypeParameterReference} again - depending actual type arguments of this {@link MethodTypingContext}. Note: this method is not checking whether declarer method is overridden by scope method, so it it may adapt parameters of potentially override equivalent methods. Use  {@link #checkSignature(CtMethod,boolean)} to check if method overrides another method
 * @param superParam to be resolved {@link CtTypeParameter}
 * @return {@link CtTypeReference} or {@link CtTypeParameterReference} adapted to scope of this {@link MethodTypingContext}or null if `typeParam` cannot be adapted to target `scope`
 */
@Override
protected
CtTypeReference
<
?
>
adaptTypeParameter
(
CtTypeParameter
superParam
)
{
CtFormalTypeDeclarer
superDeclarer
=
superParam
.
getTypeParameterDeclarer
(
)
;
if
(
superDeclarer
instanceof
CtType
<
?
>
)
{
return
getEnclosingGenericTypeAdapter
(
)
.
adaptType
(
superParam
)
;
}
if
(
superDeclarer
instanceof
CtMethod
)
{
CtMethod
<
?
>
superMethod
=
(
CtMethod
<
?
>
)
superDeclarer
;
if
(
mightBeSameSignature
(
superMethod
)
==
false
)
{
return
null
;
}
int
superParamPosition
=
superMethod
.
getFormalCtTypeParameters
(
)
.
indexOf
(
superParam
)
;
CtTypeParameter
scopeParam
=
(
(
CtFormalTypeDeclarer
)
scopeMethod
)
.
getFormalCtTypeParameters
(
)
.
get
(
superParamPosition
)
;
if
(
isSameMethodFormalTypeParameter
(
scopeParam
,
superParam
)
==
false
)
{
return
null
;
}
return
actualTypeArguments
.
get
(
superParamPosition
)
;
}
return
null
;
}
