public
MethodTypingContext
setMethod
(
CtMethod
<
?
>
method
)
{
actualTypeArguments
=
getTypeReferences
(
method
.
getFormalCtTypeParameters
(
)
)
;
if
(
classTypingContext
!=
null
)
{
CtType
<
?
>
declType
=
method
.
getDeclaringType
(
)
;
if
(
declType
==
null
)
{
throw
new
SpoonException
(
"Cannot use method without declaring type as scope of method typing context"
)
;
}
if
(
classTypingContext
.
getAdaptationScope
(
)
!=
declType
)
{
if
(
classTypingContext
.
isSubtypeOf
(
declType
.
getReference
(
)
)
==
false
)
{
throw
new
SpoonException
(
"Cannot create MethodTypingContext for method declared in different ClassTypingContext"
)
;
}
Factory
factory
=
method
.
getFactory
(
)
;
CtMethod
<
?
>
adaptedMethod
=
factory
.
Core
(
)
.
createMethod
(
)
;
adaptedMethod
.
setParent
(
classTypingContext
.
getAdaptationScope
(
)
)
;
adaptedMethod
.
setModifiers
(
method
.
getModifiers
(
)
)
;
adaptedMethod
.
setSimpleName
(
method
.
getSimpleName
(
)
)
;
for
(
CtTypeParameter
typeParam
:
method
.
getFormalCtTypeParameters
(
)
)
{
CtTypeParameter
newTypeParam
=
typeParam
.
clone
(
)
;
newTypeParam
.
setSuperclass
(
adaptTypeForNewMethod
(
typeParam
.
getSuperclass
(
)
)
)
;
adaptedMethod
.
addFormalCtTypeParameter
(
newTypeParam
)
;
}
scopeMethod
=
adaptedMethod
;
for
(
CtTypeReference
<
?
Throwable
>
thrownType
:
method
.
getThrownTypes
(
)
)
{
adaptedMethod
.
addThrownType
(
(
CtTypeReference
<
Throwable
>
)
adaptType
(
thrownType
.
clone
(
)
)
)
;
}
adaptedMethod
.
setType
(
(
CtTypeReference
)
adaptType
(
method
.
getType
(
)
)
)
;
List
<
CtParameter
<
?
>
>
adaptedParams
=
new
ArrayList
<
>
(
method
.
getParameters
(
)
.
size
(
)
)
;
for
(
CtParameter
<
?
>
parameter
:
method
.
getParameters
(
)
)
{
adaptedParams
.
add
(
factory
.
Executable
(
)
.
createParameter
(
null
,
adaptType
(
parameter
.
getType
(
)
)
,
parameter
.
getSimpleName
(
)
)
)
;
}
adaptedMethod
.
setParameters
(
adaptedParams
)
;
method
=
adaptedMethod
;
}
}
scopeMethod
=
method
;
return
this
;
}
