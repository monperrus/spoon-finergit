/** 
 * Calls `outputConsumer.apply(subType)` for each sub type of the targetSuperTypes that are found in `inputPackage`. Each sub type is returned only once. It makes sense to call this method again for example after new super types are added by  {@link #addSuperType(CtTypeInformation)}. If this method is called again with same input and configuration, nothing in sent to outputConsumer
 * @param outputConsumer the consumer for found sub types
 */
public
<
T
extends
CtType
<
?
>
>
void
forEachSubTypeInPackage
(
final
CtConsumer
<
T
>
outputConsumer
)
{
final
Set
<
String
>
allVisitedTypeNames
=
new
HashSet
<
>
(
)
;
final
Deque
<
CtTypeReference
<
?
>
>
currentSubTypes
=
new
ArrayDeque
<
>
(
)
;
final
CtQuery
q
=
inputPackage
.
map
(
new
CtScannerFunction
(
)
)
;
if
(
includingInterfaces
)
{
q
.
select
(
typeFilter
)
;
}
else
{
q
.
select
(
classFilter
)
;
}
q
.
map
(
new
SuperInheritanceHierarchyFunction
(
)
.
includingInterfaces
(
hasSuperInterface
)
.
failOnClassNotFound
(
failOnClassNotFound
)
.
setListener
(
new
CtScannerListener
(
)
{
@Override
public
ScanningMode
enter
(
CtElement
element
)
{
final
CtTypeReference
<
?
>
typeRef
=
(
CtTypeReference
<
?
>
)
element
;
String
qName
=
typeRef
.
getQualifiedName
(
)
;
if
(
targetSuperTypes
.
contains
(
qName
)
)
{
while
(
currentSubTypes
.
size
(
)
>
0
)
{
final
CtTypeReference
<
?
>
currentTypeRef
=
currentSubTypes
.
pop
(
)
;
String
currentQName
=
currentTypeRef
.
getQualifiedName
(
)
;
if
(
!
targetSuperTypes
.
contains
(
currentQName
)
)
{
targetSuperTypes
.
add
(
currentQName
)
;
outputConsumer
.
accept
(
(
T
)
currentTypeRef
.
getTypeDeclaration
(
)
)
;
}
}
return
SKIP_ALL
;
}
if
(
allVisitedTypeNames
.
add
(
qName
)
==
false
)
{
return
SKIP_ALL
;
}
currentSubTypes
.
push
(
typeRef
)
;
return
NORMAL
;
}
@Override
public
void
exit
(
CtElement
element
)
{
CtTypeInformation
type
=
(
CtTypeInformation
)
element
;
if
(
currentSubTypes
.
isEmpty
(
)
==
false
)
{
CtTypeInformation
stackType
=
currentSubTypes
.
pop
(
)
;
if
(
stackType
!=
type
)
{
throw
new
SpoonException
(
"CtScannerListener#exit was not called after enter."
)
;
}
}
}
}
)
)
.
forEach
(
new
CtConsumer
<
CtType
<
?
>
>
(
)
{
@Override
public
void
accept
(
CtType
<
?
>
type
)
{
}
}
)
;
}
