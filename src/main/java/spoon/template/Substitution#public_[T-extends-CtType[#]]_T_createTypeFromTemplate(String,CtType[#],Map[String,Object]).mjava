/** 
 * Generates a type (class, interface, enum, ...) from the template model `templateOfType` by by substituting all the template parameters by their values. Inserts all the methods, fields, constructors, initialization blocks (if target is a class), inner types, super class and super interfaces. Note! This algorithm does NOT handle interfaces or annotations {@link Template},  {@link spoon.template.Local},  {@link TemplateParameter} or {@link Parameter}in a special way, it means they all will be added to the generated type too. If you do not want to add them then clone your templateOfType and remove these nodes from that model before.
 * @param qualifiedTypeName the qualified name of the new type
 * @param templateOfType the model used as source of generation.
 * @param templateParameters the substitution parameters
 */
@SuppressWarnings("unchecked")
public
static
<
T
extends
CtType
<
?
>
>
T
createTypeFromTemplate
(
String
qualifiedTypeName
,
CtType
<
?
>
templateOfType
,
Map
<
String
,
Object
>
templateParameters
)
{
final
Factory
f
=
templateOfType
.
getFactory
(
)
;
CtTypeReference
<
T
>
typeRef
=
f
.
Type
(
)
.
createReference
(
qualifiedTypeName
)
;
CtPackage
targetPackage
=
f
.
Package
(
)
.
getOrCreate
(
typeRef
.
getPackage
(
)
.
getSimpleName
(
)
)
;
final
Map
<
String
,
Object
>
extendedParams
=
new
HashMap
<
String
,
Object
>
(
templateParameters
)
;
extendedParams
.
put
(
templateOfType
.
getSimpleName
(
)
,
typeRef
)
;
List
<
CtType
<
?
>
>
generated
=
(
List
)
new
SubstitutionVisitor
(
f
,
extendedParams
)
.
substitute
(
templateOfType
.
clone
(
)
)
;
for
(
CtType
<
?
>
ctType
:
generated
)
{
targetPackage
.
addType
(
ctType
)
;
}
return
(
T
)
typeRef
.
getTypeDeclaration
(
)
;
}
