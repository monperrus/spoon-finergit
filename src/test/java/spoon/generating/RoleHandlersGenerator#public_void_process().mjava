@Override
public
void
process
(
)
{
Metamodel
metaModel
=
Metamodel
.
getInstance
(
)
;
List
<
MetamodelProperty
>
superFields
=
new
ArrayList
<
>
(
)
;
metaModel
.
getConcepts
(
)
.
forEach
(
mmConcept
->
{
mmConcept
.
getRoleToProperty
(
)
.
forEach
(
(
role
,
rim
)
->
{
addUniqueObject
(
superFields
,
rim
.
getSuperProperty
(
)
)
;
}
)
;
}
)
;
superFields
.
sort
(
(
a
,
b
)
->
{
int
d
=
a
.
getRole
(
)
.
name
(
)
.
compareTo
(
b
.
getRole
(
)
.
name
(
)
)
;
if
(
d
!=
0
)
{
return
d
;
}
return
a
.
getOwner
(
)
.
getName
(
)
.
compareTo
(
b
.
getOwner
(
)
.
getName
(
)
)
;
}
)
;
PrinterHelper
concept
=
new
PrinterHelper
(
getFactory
(
)
.
getEnvironment
(
)
)
;
superFields
.
forEach
(
mmField
->
{
concept
.
write
(
mmField
.
getOwner
(
)
.
getName
(
)
+
" CtRole."
+
mmField
.
getRole
(
)
.
name
(
)
)
.
writeln
(
)
.
incTab
(
)
.
write
(
"ItemType: "
)
.
write
(
mmField
.
getTypeOfField
(
)
.
toString
(
)
)
.
writeln
(
)
;
for
(
MMMethodKind
mk
:
MMMethodKind
.
values
(
)
)
{
MMMethod
mmMethod
=
mmField
.
getMethod
(
mk
)
;
if
(
mmMethod
!=
null
)
{
concept
.
write
(
mk
.
name
(
)
)
.
write
(
": "
)
.
write
(
mmMethod
.
getSignature
(
)
)
.
write
(
" : "
)
.
write
(
mmMethod
.
getReturnType
(
)
.
toString
(
)
)
.
writeln
(
)
;
}
}
concept
.
decTab
(
)
;
concept
.
write
(
"----------------------------------------------------------"
)
.
writeln
(
)
;
}
)
;
try
(
Writer
w
=
new
OutputStreamWriter
(
new
FileOutputStream
(
file
(
"target/report/concept.txt"
)
)
)
)
{
w
.
write
(
concept
.
toString
(
)
)
;
}
catch
(
IOException
e
)
{
throw
new
RuntimeException
(
e
)
;
}
CtType
<
?
>
template
=
getTemplate
(
"spoon.generating.meta.ModelRoleHandlerTemplate"
)
;
CtClass
<
?
>
modelRoleHandlersClass
=
Substitution
.
createTypeFromTemplate
(
TARGET_PACKAGE
+
".ModelRoleHandlers"
,
template
,
new
HashMap
<
>
(
)
)
;
CtNewArray
<
?
>
roleHandlersFieldExpr
=
(
CtNewArray
<
?
>
)
modelRoleHandlersClass
.
getField
(
"roleHandlers"
)
.
getDefaultExpression
(
)
;
superFields
.
forEach
(
rim
->
{
Map
<
String
,
Object
>
params
=
new
HashMap
<
>
(
)
;
params
.
put
(
"$getterName$"
,
rim
.
getMethod
(
MMMethodKind
.
GET
)
.
getName
(
)
)
;
if
(
rim
.
getMethod
(
MMMethodKind
.
SET
)
!=
null
)
{
params
.
put
(
"$setterName$"
,
rim
.
getMethod
(
MMMethodKind
.
SET
)
.
getName
(
)
)
;
}
params
.
put
(
"$Role$"
,
getFactory
(
)
.
Type
(
)
.
createReference
(
CtRole
.
class
)
)
;
params
.
put
(
"ROLE"
,
rim
.
getRole
(
)
.
name
(
)
)
;
params
.
put
(
"$TargetType$"
,
rim
.
getOwner
(
)
.
getMetamodelInterface
(
)
.
getReference
(
)
)
;
CtTypeReference
<
?
>
nodeRef
=
rim
.
getOwner
(
)
.
getMetamodelInterface
(
)
.
getReference
(
)
;
CtTypeReference
<
?
>
valueTypeRef
=
fixMainValueType
(
getRoleHandlerSuperTypeQName
(
rim
)
.
endsWith
(
"SingleHandler"
)
?
rim
.
getTypeOfField
(
)
:
rim
.
getTypeofItems
(
)
)
;
CtTypeReference
<
?
>
handlerSuperClassRef
=
getFactory
(
)
.
Type
(
)
.
createReference
(
getRoleHandlerSuperTypeQName
(
rim
)
)
;
handlerSuperClassRef
.
addActualTypeArgument
(
nodeRef
)
;
handlerSuperClassRef
.
addActualTypeArgument
(
valueTypeRef
)
;
params
.
put
(
"AbstractHandler"
,
handlerSuperClassRef
)
;
params
.
put
(
"Node"
,
nodeRef
)
;
params
.
put
(
"ValueType"
,
valueTypeRef
)
;
CtClass
<
?
>
modelRoleHandlerClass
=
Substitution
.
createTypeFromTemplate
(
getHandlerName
(
rim
)
,
getTemplate
(
"spoon.generating.meta.RoleHandlerTemplate"
)
,
params
)
;
if
(
rim
.
getMethod
(
MMMethodKind
.
SET
)
==
null
)
{
modelRoleHandlerClass
.
getMethodsByName
(
"setValue"
)
.
forEach
(
m
->
m
.
delete
(
)
)
;
}
modelRoleHandlerClass
.
addModifier
(
ModifierKind
.
STATIC
)
;
modelRoleHandlersClass
.
addNestedType
(
modelRoleHandlerClass
)
;
roleHandlersFieldExpr
.
addElement
(
getFactory
(
)
.
createCodeSnippetExpression
(
"new "
+
modelRoleHandlerClass
.
getSimpleName
(
)
+
"()"
)
)
;
}
)
;
}
