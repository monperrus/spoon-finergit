@Test
public
void
testAvoidSetCollectionSavedOnAST
(
)
{
final
Launcher
launcher
=
new
Launcher
(
)
;
launcher
.
getEnvironment
(
)
.
setNoClasspath
(
true
)
;
launcher
.
addInputResource
(
"src/main/java"
)
;
launcher
.
buildModel
(
)
;
final
Factory
factory
=
launcher
.
getFactory
(
)
;
final
List
<
CtTypeReference
<
?
>
>
collectionsRef
=
Arrays
.
asList
(
factory
.
Type
(
)
.
createReference
(
Collection
.
class
)
,
factory
.
Type
(
)
.
createReference
(
List
.
class
)
,
factory
.
Type
(
)
.
createReference
(
Set
.
class
)
,
factory
.
Type
(
)
.
createReference
(
Map
.
class
)
)
;
final
List
<
CtInvocation
<
?
>
>
invocations
=
Query
.
getElements
(
factory
,
new
TypeFilter
<
CtInvocation
<
?
>
>
(
CtInvocation
.
class
)
{
@Override
public
boolean
matches
(
CtInvocation
<
?
>
element
)
{
if
(
!
(
element
.
getParent
(
)
instanceof
CtInvocation
)
)
{
return
false
;
}
final
CtInvocation
<
?
>
parent
=
(
CtInvocation
<
?
>
)
element
.
getParent
(
)
;
if
(
parent
.
getTarget
(
)
==
null
||
!
parent
.
getTarget
(
)
.
equals
(
element
)
)
{
return
false
;
}
if
(
!
element
.
getExecutable
(
)
.
getDeclaringType
(
)
.
getSimpleName
(
)
.
startsWith
(
"Ct"
)
)
{
return
false
;
}
boolean
isDataStructure
=
false
;
for
(
CtTypeReference
<
?
>
ctTypeReference
:
collectionsRef
)
{
if
(
element
.
getType
(
)
.
isSubtypeOf
(
ctTypeReference
)
)
{
isDataStructure
=
true
;
break
;
}
}
if
(
!
isDataStructure
)
{
return
false
;
}
final
String
simpleName
=
parent
.
getExecutable
(
)
.
getSimpleName
(
)
;
return
simpleName
.
startsWith
(
"add"
)
||
simpleName
.
startsWith
(
"remove"
)
||
simpleName
.
startsWith
(
"put"
)
;
}
}
)
;
if
(
invocations
.
size
(
)
>
0
)
{
final
String
error
=
invocations
.
stream
(
)
.
sorted
(
new
CtLineElementComparator
(
)
)
.
map
(
i
->
"see "
+
i
.
getPosition
(
)
.
getFile
(
)
.
getAbsoluteFile
(
)
+
" at "
+
i
.
getPosition
(
)
.
getLine
(
)
)
.
collect
(
Collectors
.
joining
(
",\n"
)
)
;
throw
new
AssertionError
(
error
)
;
}
}
