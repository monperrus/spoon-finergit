@Test
public
void
testUsageOfTypeAnnotationWithGenericTypesInStatements
(
)
throws
Exception
{
final
CtClass
<
?
>
ctClass
=
(
CtClass
<
?
>
)
this
.
factory
.
Type
(
)
.
get
(
"spoon.test.annotation.testclasses.AnnotationsAppliedOnAnyTypeInAClass"
)
;
final
CtMethod
<
?
>
method
=
ctClass
.
getMethodsByName
(
"m4"
)
.
get
(
0
)
;
final
List
<
CtTypeParameterReference
>
formalTypeParameters
=
method
.
getFormalTypeParameters
(
)
;
assertEquals
(
"Method has 1 generic parameter"
,
1
,
formalTypeParameters
.
size
(
)
)
;
assertEquals
(
"Method with an type annotation must be well printed"
,
"@spoon.test.annotation.testclasses.TypeAnnotation"
+
System
.
lineSeparator
(
)
+
"T"
,
formalTypeParameters
.
get
(
0
)
.
toString
(
)
)
;
final
CtBlock
<
?
>
body
=
method
.
getBody
(
)
;
final
String
expectedFirstStatement
=
"java.util.List<@spoon.test.annotation.testclasses.TypeAnnotation"
+
System
.
lineSeparator
(
)
+
"T> list = new java.util.ArrayList<>()"
;
final
CtStatement
firstStatement
=
body
.
getStatement
(
0
)
;
assertEquals
(
"Type annotation on generic parameter declared in the method"
,
expectedFirstStatement
,
firstStatement
.
toString
(
)
)
;
final
CtConstructorCall
firstConstructorCall
=
firstStatement
.
getElements
(
new
TypeFilter
<
CtConstructorCall
>
(
CtConstructorCall
.
class
)
)
.
get
(
0
)
;
final
CtTypeReference
<
?
>
firstTypeReference
=
firstConstructorCall
.
getType
(
)
.
getActualTypeArguments
(
)
.
get
(
0
)
;
assertTrue
(
firstTypeReference
.
isImplicit
(
)
)
;
assertEquals
(
"T"
,
firstTypeReference
.
getSimpleName
(
)
)
;
final
String
expectedSecondStatement
=
"java.util.List<@spoon.test.annotation.testclasses.TypeAnnotation"
+
System
.
lineSeparator
(
)
+
"?> list2 = new java.util.ArrayList<>()"
;
final
CtStatement
secondStatement
=
body
.
getStatement
(
1
)
;
assertEquals
(
"Wildcard with an type annotation must be well printed"
,
expectedSecondStatement
,
secondStatement
.
toString
(
)
)
;
final
CtConstructorCall
secondConstructorCall
=
secondStatement
.
getElements
(
new
TypeFilter
<
CtConstructorCall
>
(
CtConstructorCall
.
class
)
)
.
get
(
0
)
;
final
CtTypeReference
<
?
>
secondTypeReference
=
secondConstructorCall
.
getType
(
)
.
getActualTypeArguments
(
)
.
get
(
0
)
;
assertTrue
(
secondTypeReference
.
isImplicit
(
)
)
;
assertEquals
(
"Object"
,
secondTypeReference
.
getSimpleName
(
)
)
;
final
String
expectedThirdStatement
=
"java.util.List<spoon.test.annotation.testclasses.@spoon.test.annotation.testclasses.TypeAnnotation"
+
System
.
lineSeparator
(
)
+
"BasicAnnotation> list3 = new java.util.ArrayList<spoon.test.annotation.testclasses.@spoon.test.annotation.testclasses.TypeAnnotation"
+
System
.
lineSeparator
(
)
+
"BasicAnnotation>()"
;
assertEquals
(
"Type in generic parameter with an type annotation must be well printed"
,
expectedThirdStatement
,
body
.
getStatement
(
2
)
.
toString
(
)
)
;
}
