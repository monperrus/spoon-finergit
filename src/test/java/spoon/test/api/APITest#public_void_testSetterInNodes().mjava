@Test
public
void
testSetterInNodes
(
)
throws
Exception
{
class
SetterMethodWithoutCollectionsFilter
extends
TypeFilter
<
CtMethod
<
?
>
>
{
private
final
List
<
CtTypeReference
<
?
>
>
collections
=
new
ArrayList
<
>
(
4
)
;
public
SetterMethodWithoutCollectionsFilter
(
Factory
factory
)
{
super
(
CtMethod
.
class
)
;
for
(
Class
<
?
>
aCollectionClass
:
Arrays
.
asList
(
Collection
.
class
,
List
.
class
,
Map
.
class
,
Set
.
class
)
)
{
collections
.
add
(
factory
.
Type
(
)
.
createReference
(
aCollectionClass
)
)
;
}
}
@Override
public
boolean
matches
(
CtMethod
<
?
>
element
)
{
boolean
isSetter
=
isSetterMethod
(
element
)
;
boolean
isNotSubType
=
!
isSubTypeOfCollection
(
element
)
;
boolean
doesNotHaveUnsettableAnnotation
=
doesNotHaveUnsettableAnnotation
(
element
)
;
boolean
isNotSetterForADerivedProperty
=
isNotSetterForADerivedProperty
(
element
)
;
boolean
superMatch
=
super
.
matches
(
element
)
;
return
isSetter
&&
doesNotHaveUnsettableAnnotation
&&
isNotSetterForADerivedProperty
&&
isNotSubType
&&
superMatch
;
}
private
boolean
isNotSetterForADerivedProperty
(
CtMethod
<
?
>
method
)
{
String
methodName
=
method
.
getSimpleName
(
)
;
String
getterName
=
methodName
.
replace
(
"set"
,
"get"
)
;
if
(
getterName
.
equals
(
methodName
)
)
{
return
false
;
}
CtType
<
?
>
zeClass
=
(
CtType
)
method
.
getParent
(
)
;
List
<
CtMethod
<
?
>
>
getterMethods
=
zeClass
.
getMethodsByName
(
getterName
)
;
if
(
getterMethods
.
size
(
)
!=
1
)
{
return
false
;
}
CtMethod
<
?
>
getterMethod
=
getterMethods
.
get
(
0
)
;
return
(
getterMethod
.
getAnnotation
(
DerivedProperty
.
class
)
==
null
)
;
}
private
boolean
doesNotHaveUnsettableAnnotation
(
CtMethod
<
?
>
element
)
{
return
(
element
.
getAnnotation
(
UnsettableProperty
.
class
)
==
null
)
;
}
private
boolean
isSubTypeOfCollection
(
CtMethod
<
?
>
element
)
{
final
List
<
CtParameter
<
?
>
>
parameters
=
element
.
getParameters
(
)
;
if
(
parameters
.
size
(
)
!=
1
)
{
return
false
;
}
final
CtTypeReference
<
?
>
type
=
parameters
.
get
(
0
)
.
getType
(
)
;
for
(
CtTypeReference
<
?
>
aCollectionRef
:
collections
)
{
if
(
type
.
isSubtypeOf
(
aCollectionRef
)
||
type
.
equals
(
aCollectionRef
)
)
{
return
true
;
}
}
return
false
;
}
private
boolean
isSetterMethod
(
CtMethod
<
?
>
element
)
{
final
List
<
CtParameter
<
?
>
>
parameters
=
element
.
getParameters
(
)
;
if
(
parameters
.
size
(
)
!=
1
)
{
return
false
;
}
final
CtTypeReference
<
?
>
typeParameter
=
parameters
.
get
(
0
)
.
getType
(
)
;
final
CtTypeReference
<
CtElement
>
ctElementRef
=
element
.
getFactory
(
)
.
Type
(
)
.
createReference
(
CtElement
.
class
)
;
boolean
isSubtypeof
=
typeParameter
.
isSubtypeOf
(
ctElementRef
)
;
if
(
!
isSubtypeof
)
{
return
false
;
}
return
element
.
getSimpleName
(
)
.
startsWith
(
"set"
)
&&
element
.
getDeclaringType
(
)
.
getSimpleName
(
)
.
startsWith
(
"Ct"
)
&&
element
.
getBody
(
)
!=
null
;
}
}
class
CheckNotNullToSetParentMatcher
extends
CtElementImpl
{
public
TemplateParameter
<
CtVariableAccess
<
?
>
>
_parameter_access_
;
public
void
matcher
(
)
{
if
(
_parameter_access_
.
S
(
)
!=
null
)
{
_parameter_access_
.
S
(
)
.
setParent
(
this
)
;
}
}
@Override
@Local
public
void
accept
(
CtVisitor
visitor
)
{
}
}
final
Launcher
launcher
=
new
Launcher
(
)
;
launcher
.
setArgs
(
new
String
[
]
{
"--output-type"
,
"nooutput"
}
)
;
launcher
.
getEnvironment
(
)
.
setNoClasspath
(
true
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/support/reflect/code"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/support/reflect/declaration"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/support/reflect/reference"
)
;
launcher
.
addInputResource
(
"./src/test/java/"
+
this
.
getClass
(
)
.
getCanonicalName
(
)
.
replace
(
"."
,
"/"
)
+
".java"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/reflect/"
)
;
launcher
.
buildModel
(
)
;
CtClass
<
CheckNotNullToSetParentMatcher
>
matcherCtClass
=
launcher
.
getFactory
(
)
.
Class
(
)
.
get
(
CheckNotNullToSetParentMatcher
.
class
)
;
CtIf
templateRoot
=
matcherCtClass
.
getMethod
(
"matcher"
)
.
getBody
(
)
.
getStatement
(
0
)
;
final
List
<
CtMethod
<
?
>
>
setters
=
Query
.
getElements
(
launcher
.
getFactory
(
)
,
new
SetterMethodWithoutCollectionsFilter
(
launcher
.
getFactory
(
)
)
)
;
assertTrue
(
"Number of setters found null"
,
setters
.
size
(
)
>
0
)
;
for
(
CtStatement
statement
:
setters
.
stream
(
)
.
map
(
(
Function
<
CtMethod
<
?
>
,
CtStatement
>
)
ctMethod
->
ctMethod
.
getBody
(
)
.
getStatement
(
0
)
)
.
collect
(
Collectors
.
toList
(
)
)
)
{
assertTrue
(
"Check the method "
+
statement
.
getParent
(
CtMethod
.
class
)
.
getSignature
(
)
+
" in the declaring class "
+
statement
.
getParent
(
CtType
.
class
)
.
getQualifiedName
(
)
,
statement
instanceof
CtIf
)
;
CtIf
ifCondition
=
(
CtIf
)
statement
;
TemplateMatcher
matcher
=
new
TemplateMatcher
(
templateRoot
)
;
assertEquals
(
"Check the number of if in method "
+
statement
.
getParent
(
CtMethod
.
class
)
.
getSignature
(
)
+
" in the declaring class "
+
statement
.
getParent
(
CtType
.
class
)
.
getQualifiedName
(
)
,
1
,
matcher
.
find
(
ifCondition
)
.
size
(
)
)
;
}
}
