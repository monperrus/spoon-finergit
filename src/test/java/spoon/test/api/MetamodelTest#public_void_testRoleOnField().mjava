@Test
public
void
testRoleOnField
(
)
{
SpoonAPI
implementations
=
new
Launcher
(
)
;
implementations
.
addInputResource
(
"src/main/java/spoon/support/reflect"
)
;
implementations
.
buildModel
(
)
;
Factory
factory
=
implementations
.
getFactory
(
)
;
CtTypeReference
metamodelPropertyField
=
factory
.
Type
(
)
.
get
(
MetamodelPropertyField
.
class
)
.
getReference
(
)
;
List
<
CtField
>
fieldWithoutAnnotation
=
(
List
<
CtField
>
)
implementations
.
getModel
(
)
.
getElements
(
new
TypeFilter
<
CtField
>
(
CtField
.
class
)
{
@Override
public
boolean
matches
(
CtField
candidate
)
{
if
(
candidate
.
hasModifier
(
ModifierKind
.
FINAL
)
||
candidate
.
hasModifier
(
ModifierKind
.
STATIC
)
||
candidate
.
hasModifier
(
ModifierKind
.
TRANSIENT
)
)
{
return
false
;
}
if
(
"parent"
.
equals
(
candidate
.
getSimpleName
(
)
)
||
"metadata"
.
equals
(
candidate
.
getSimpleName
(
)
)
||
"valueOfMethod"
.
equals
(
candidate
.
getSimpleName
(
)
)
)
{
return
false
;
}
CtClass
parent
=
candidate
.
getParent
(
CtClass
.
class
)
;
return
parent
!=
null
&&
parent
.
isSubtypeOf
(
candidate
.
getFactory
(
)
.
createCtTypeReference
(
CtElement
.
class
)
)
;
}
}
)
.
stream
(
)
.
filter
(
f
->
f
.
getAnnotation
(
metamodelPropertyField
)
==
null
)
.
collect
(
Collectors
.
toList
(
)
)
;
Assert
.
assertEquals
(
Collections
.
emptyList
(
)
,
fieldWithoutAnnotation
)
;
final
CtTypeReference
propertySetter
=
factory
.
Type
(
)
.
get
(
PropertySetter
.
class
)
.
getReference
(
)
;
final
CtTypeReference
propertyGetter
=
factory
.
Type
(
)
.
get
(
PropertyGetter
.
class
)
.
getReference
(
)
;
List
<
CtField
>
fields
=
factory
.
getModel
(
)
.
getElements
(
new
AnnotationFilter
<
CtField
>
(
MetamodelPropertyField
.
class
)
)
;
for
(
CtField
field
:
fields
)
{
CtClass
parent
=
field
.
getParent
(
CtClass
.
class
)
;
CtExpression
roleExpression
=
field
.
getAnnotation
(
metamodelPropertyField
)
.
getValue
(
"role"
)
;
List
<
String
>
roles
=
new
ArrayList
<
>
(
)
;
if
(
roleExpression
instanceof
CtFieldRead
)
{
roles
.
add
(
(
(
CtFieldRead
)
roleExpression
)
.
getVariable
(
)
.
getSimpleName
(
)
)
;
}
else
if
(
roleExpression
instanceof
CtNewArray
)
{
List
<
CtFieldRead
>
elements
=
(
(
CtNewArray
)
roleExpression
)
.
getElements
(
)
;
for
(
int
i
=
0
;
i
<
elements
.
size
(
)
;
i
++
)
{
CtFieldRead
ctFieldRead
=
elements
.
get
(
i
)
;
roles
.
add
(
ctFieldRead
.
getVariable
(
)
.
getSimpleName
(
)
)
;
}
}
CtQuery
superQuery
=
parent
.
map
(
new
SuperInheritanceHierarchyFunction
(
)
)
;
List
<
CtMethod
>
methods
=
superQuery
.
map
(
(
CtType
type
)
->
type
.
getMethodsAnnotatedWith
(
propertyGetter
,
propertySetter
)
)
.
list
(
)
;
boolean
setterFound
=
false
;
boolean
getterFound
=
false
;
for
(
CtMethod
method
:
methods
)
{
CtAnnotation
getterAnnotation
=
method
.
getAnnotation
(
propertyGetter
)
;
CtAnnotation
setterAnnotation
=
method
.
getAnnotation
(
propertySetter
)
;
if
(
getterAnnotation
!=
null
)
{
getterFound
=
roles
.
contains
(
(
(
CtFieldRead
)
getterAnnotation
.
getValue
(
"role"
)
)
.
getVariable
(
)
.
getSimpleName
(
)
)
;
}
if
(
setterAnnotation
!=
null
)
{
setterFound
=
roles
.
contains
(
(
(
CtFieldRead
)
setterAnnotation
.
getValue
(
"role"
)
)
.
getVariable
(
)
.
getSimpleName
(
)
)
;
}
}
Assert
.
assertTrue
(
roles
+
" must have a getter in "
+
parent
.
getQualifiedName
(
)
,
getterFound
)
;
Assert
.
assertTrue
(
roles
+
" must have a setter in "
+
parent
.
getQualifiedName
(
)
,
setterFound
)
;
}
}
