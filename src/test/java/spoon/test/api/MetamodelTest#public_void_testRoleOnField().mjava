@Test
public
void
testRoleOnField
(
)
{
SpoonAPI
implementations
=
new
Launcher
(
)
;
implementations
.
addInputResource
(
"src/main/java/spoon/support/reflect"
)
;
implementations
.
buildModel
(
)
;
Factory
factory
=
implementations
.
getFactory
(
)
;
CtTypeReference
metamodelPropertyField
=
factory
.
Type
(
)
.
get
(
MetamodelPropertyField
.
class
)
.
getReference
(
)
;
List
<
CtField
>
fieldWithoutAnnotation
=
(
List
<
CtField
>
)
implementations
.
getModel
(
)
.
getElements
(
new
TypeFilter
<
CtField
>
(
CtField
.
class
)
{
@Override
public
boolean
matches
(
CtField
candidate
)
{
if
(
candidate
.
hasModifier
(
ModifierKind
.
FINAL
)
||
candidate
.
hasModifier
(
ModifierKind
.
STATIC
)
||
candidate
.
hasModifier
(
ModifierKind
.
TRANSIENT
)
)
{
return
false
;
}
if
(
"parent"
.
equals
(
candidate
.
getSimpleName
(
)
)
||
"metadata"
.
equals
(
candidate
.
getSimpleName
(
)
)
||
"valueOfMethod"
.
equals
(
candidate
.
getSimpleName
(
)
)
)
{
return
false
;
}
CtClass
parent
=
candidate
.
getParent
(
CtClass
.
class
)
;
return
parent
!=
null
&&
!
(
parent
.
isSubtypeOf
(
candidate
.
getFactory
(
)
.
createCtTypeReference
(
CtReference
.
class
)
)
)
&&
parent
.
isSubtypeOf
(
candidate
.
getFactory
(
)
.
createCtTypeReference
(
CtElement
.
class
)
)
;
}
}
)
.
stream
(
)
.
filter
(
f
->
f
.
getAnnotation
(
metamodelPropertyField
)
==
null
)
.
collect
(
Collectors
.
toList
(
)
)
;
Assert
.
assertEquals
(
Collections
.
emptyList
(
)
,
fieldWithoutAnnotation
)
;
final
CtTypeReference
propertySetter
=
factory
.
Type
(
)
.
get
(
PropertySetter
.
class
)
.
getReference
(
)
;
final
CtTypeReference
propertyGetter
=
factory
.
Type
(
)
.
get
(
PropertyGetter
.
class
)
.
getReference
(
)
;
List
<
CtField
>
fields
=
factory
.
getModel
(
)
.
getElements
(
new
AnnotationFilter
<
CtField
>
(
MetamodelPropertyField
.
class
)
)
;
for
(
CtField
field
:
fields
)
{
CtClass
parent
=
field
.
getParent
(
CtClass
.
class
)
;
String
role
=
(
(
CtFieldRead
)
field
.
getAnnotation
(
metamodelPropertyField
)
.
getValue
(
"role"
)
)
.
getVariable
(
)
.
getSimpleName
(
)
;
CtQuery
superQuery
=
parent
.
map
(
new
SuperInheritanceHierarchyFunction
(
)
)
;
List
<
CtType
>
superType
=
superQuery
.
list
(
)
;
List
<
CtMethod
>
methods
=
superQuery
.
map
(
(
CtType
type
)
->
type
.
getMethodsAnnotatedWith
(
propertyGetter
,
propertySetter
)
)
.
list
(
)
;
boolean
setterFound
=
false
;
boolean
getterFound
=
false
;
for
(
CtMethod
method
:
methods
)
{
CtAnnotation
getterAnnotation
=
method
.
getAnnotation
(
propertyGetter
)
;
CtAnnotation
setterAnnotation
=
method
.
getAnnotation
(
propertySetter
)
;
if
(
getterAnnotation
!=
null
)
{
getterFound
=
(
(
CtFieldRead
)
getterAnnotation
.
getValue
(
"role"
)
)
.
getVariable
(
)
.
getSimpleName
(
)
.
equals
(
role
)
;
}
if
(
setterAnnotation
!=
null
)
{
setterFound
=
(
(
CtFieldRead
)
setterAnnotation
.
getValue
(
"role"
)
)
.
getVariable
(
)
.
getSimpleName
(
)
.
equals
(
role
)
;
}
}
Assert
.
assertTrue
(
role
+
" must have a getter in "
+
parent
.
getQualifiedName
(
)
,
getterFound
)
;
Assert
.
assertTrue
(
role
+
" must have a setter in "
+
parent
.
getQualifiedName
(
)
,
setterFound
)
;
}
}
