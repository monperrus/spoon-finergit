@Test
public
void
testRuntimeMetamodel
(
)
{
Metamodel
testMetaModel
=
Metamodel
.
getInstance
(
)
;
Map
<
String
,
MetamodelConcept
>
expectedTypesByName
=
new
HashMap
<
>
(
)
;
testMetaModel
.
getConcepts
(
)
.
forEach
(
t
->
{
if
(
t
.
getKind
(
)
==
ConceptKind
.
LEAF
)
{
expectedTypesByName
.
put
(
t
.
getName
(
)
,
t
)
;
}
}
)
;
List
<
String
>
problems
=
new
ArrayList
<
>
(
)
;
for
(
spoon
.
test
.
api
.
Metamodel
.
Type
type
:
spoon
.
test
.
api
.
Metamodel
.
getAllMetamodelTypes
(
)
)
{
MetamodelConcept
expectedType
=
expectedTypesByName
.
remove
(
type
.
getName
(
)
)
;
assertSame
(
expectedType
.
getImplementationClass
(
)
.
getActualClass
(
)
,
type
.
getModelClass
(
)
)
;
assertSame
(
expectedType
.
getMetamodelInterface
(
)
.
getActualClass
(
)
,
type
.
getModelInterface
(
)
)
;
Map
<
CtRole
,
MetamodelProperty
>
expectedRoleToField
=
new
HashMap
<
>
(
expectedType
.
getRoleToProperty
(
)
)
;
for
(
spoon
.
test
.
api
.
Metamodel
.
Field
field
:
type
.
getFields
(
)
)
{
MetamodelProperty
expectedField
=
expectedRoleToField
.
remove
(
field
.
getRole
(
)
)
;
if
(
expectedField
==
null
)
{
problems
.
add
(
"no method with role "
+
field
.
getRole
(
)
+
" in interface "
+
type
.
getName
(
)
)
;
continue
;
}
if
(
expectedField
.
isDerived
(
)
!=
field
.
isDerived
(
)
)
{
problems
.
add
(
"Field "
+
expectedField
+
".derived hardcoded value = "
+
field
.
isDerived
(
)
+
" but computed value is "
+
expectedField
.
isDerived
(
)
)
;
}
if
(
expectedField
.
isUnsettable
(
)
!=
field
.
isUnsettable
(
)
)
{
problems
.
add
(
"Field "
+
expectedField
+
".unsettable hardcoded value = "
+
field
.
isUnsettable
(
)
+
" but computed value is "
+
expectedField
.
isUnsettable
(
)
)
;
}
}
}
if
(
expectedTypesByName
.
isEmpty
(
)
==
false
)
{
problems
.
add
(
"These Metamodel.Type instances are missing:"
+
expectedTypesByName
.
keySet
(
)
)
;
}
assertTrue
(
"You might need to update api/Metamodel.java: "
+
String
.
join
(
"\n"
,
problems
)
,
problems
.
isEmpty
(
)
)
;
}
