@Test
public
void
testSrcMainJava
(
)
{
Launcher
spoon
=
new
Launcher
(
)
;
spoon
.
getEnvironment
(
)
.
setCommentEnabled
(
true
)
;
spoon
.
addInputResource
(
"src/main/java/"
)
;
spoon
.
buildModel
(
)
;
List
<
String
>
notDocumented
=
new
ArrayList
<
>
(
)
;
for
(
CtMethod
method
:
spoon
.
getModel
(
)
.
getElements
(
new
TypeFilter
<
>
(
CtMethod
.
class
)
)
)
{
if
(
method
.
hasModifier
(
ModifierKind
.
PUBLIC
)
&&
!
method
.
getSimpleName
(
)
.
startsWith
(
"get"
)
&&
!
method
.
getSimpleName
(
)
.
startsWith
(
"set"
)
&&
!
method
.
getSimpleName
(
)
.
startsWith
(
"is"
)
&&
!
method
.
getSimpleName
(
)
.
startsWith
(
"add"
)
&&
!
method
.
getSimpleName
(
)
.
startsWith
(
"remove"
)
&&
method
.
getTopDefinitions
(
)
.
size
(
)
==
0
&&
(
method
.
hasModifier
(
ModifierKind
.
ABSTRACT
)
||
method
.
filterChildren
(
new
TypeFilter
<
>
(
CtCodeElement
.
class
)
)
.
list
(
)
.
size
(
)
>
35
)
)
{
if
(
method
.
getDocComment
(
)
.
length
(
)
<=
15
)
{
notDocumented
.
add
(
method
.
getParent
(
CtType
.
class
)
.
getQualifiedName
(
)
+
"#"
+
method
.
getSignature
(
)
)
;
}
}
}
if
(
notDocumented
.
size
(
)
>
0
)
{
fail
(
notDocumented
.
size
(
)
+
" public methods should be documented with proper API documentation: \n"
+
StringUtils
.
join
(
notDocumented
,
"\n"
)
)
;
}
List
<
CtConstructorCall
>
treeSetWithoutComparators
=
spoon
.
getFactory
(
)
.
Package
(
)
.
getRootPackage
(
)
.
filterChildren
(
new
AbstractFilter
<
CtConstructorCall
>
(
)
{
@Override
public
boolean
matches
(
CtConstructorCall
element
)
{
return
element
.
getType
(
)
.
getActualClass
(
)
.
equals
(
TreeSet
.
class
)
&&
element
.
getArguments
(
)
.
size
(
)
==
0
;
}
}
)
.
list
(
)
;
assertEquals
(
0
,
treeSetWithoutComparators
.
size
(
)
)
;
}
