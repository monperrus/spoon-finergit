@Test
public
void
testDocumentationContract
(
)
throws
Exception
{
final
Launcher
launcher
=
new
Launcher
(
)
;
launcher
.
getEnvironment
(
)
.
setNoClasspath
(
true
)
;
launcher
.
getEnvironment
(
)
.
setCommentEnabled
(
true
)
;
launcher
.
getEnvironment
(
)
.
setComplianceLevel
(
10
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/reflect/"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/support/reflect/"
)
;
launcher
.
buildModel
(
)
;
StringBuffer
codeElementsDocumentationPage
=
new
StringBuffer
(
)
;
codeElementsDocumentationPage
.
append
(
IOUtils
.
toString
(
new
FileReader
(
"doc/code_elements_header.md"
)
)
)
;
codeElementsDocumentationPage
.
append
(
"\n\n"
)
;
launcher
.
getModel
(
)
.
getElements
(
new
TypeFilter
<
>
(
CtInterface
.
class
)
)
.
stream
(
)
.
forEach
(
x
->
{
assertNotNull
(
x
.
getSimpleName
(
)
+
" has no documentation"
,
x
.
getDocComment
(
)
)
;
assertTrue
(
x
.
getSimpleName
(
)
+
" has no documentation"
,
!
x
.
getDocComment
(
)
.
isEmpty
(
)
)
;
if
(
launcher
.
getModel
(
)
.
getElements
(
new
AbstractFilter
<
CtElement
>
(
)
{
@Override
public
boolean
matches
(
CtElement
element
)
{
return
(
element
instanceof
CtNamedElement
)
&&
(
(
CtNamedElement
)
element
)
.
getSimpleName
(
)
.
equals
(
x
.
getSimpleName
(
)
+
"Impl"
)
&&
(
element
instanceof
CtClass
)
&&
!
(
(
CtClass
)
element
)
.
hasModifier
(
ModifierKind
.
ABSTRACT
)
;
}
}
)
.
isEmpty
(
)
)
{
return
;
}
if
(
x
.
getSimpleName
(
)
.
endsWith
(
"Reference"
)
)
{
return
;
}
if
(
x
.
isSubtypeOf
(
launcher
.
getFactory
(
)
.
Type
(
)
.
get
(
CtStatement
.
class
)
.
getReference
(
)
)
||
x
.
isSubtypeOf
(
launcher
.
getFactory
(
)
.
Type
(
)
.
get
(
CtExpression
.
class
)
.
getReference
(
)
)
)
{
if
(
"CtCodeSnippetStatement"
.
equals
(
x
.
getSimpleName
(
)
)
)
{
return
;
}
if
(
"CtCodeSnippetExpression"
.
equals
(
x
.
getSimpleName
(
)
)
)
{
return
;
}
if
(
"CtComment"
.
equals
(
x
.
getSimpleName
(
)
)
)
{
return
;
}
if
(
"CtEnum"
.
equals
(
x
.
getSimpleName
(
)
)
)
{
return
;
}
if
(
"CtAnnotationFieldAccess"
.
equals
(
x
.
getSimpleName
(
)
)
)
{
return
;
}
codeElementsDocumentationPage
.
append
(
"### "
+
x
.
getSimpleName
(
)
+
"\n"
)
;
codeElementsDocumentationPage
.
append
(
"[(javadoc)](http://spoon.gforge.inria.fr/mvnsites/spoon-core/apidocs/"
+
x
.
getQualifiedName
(
)
.
replace
(
'.'
,
'/'
)
+
".html)\n\n"
)
;
codeElementsDocumentationPage
.
append
(
"```java"
+
"\n"
)
;
Pattern
p
=
Pattern
.
compile
(
"<pre>(.*?)</pre>"
,
Pattern
.
CASE_INSENSITIVE
|
Pattern
.
DOTALL
|
Pattern
.
MULTILINE
|
Pattern
.
UNIX_LINES
)
;
Matcher
m
=
p
.
matcher
(
x
.
getDocComment
(
)
)
;
m
.
find
(
)
;
do
{
String
snippet
=
null
;
try
{
snippet
=
m
.
group
(
1
)
;
}
catch
(
IllegalStateException
e
)
{
fail
(
x
+
" does not have code snippet"
)
;
}
snippet
=
StringEscapeUtils
.
unescapeHtml4
(
snippet
)
;
CtElement
el
=
launcher
.
getFactory
(
)
.
Code
(
)
.
createCodeSnippetStatement
(
snippet
)
.
compile
(
)
;
assertTrue
(
snippet
+
" does not contain a "
+
x
.
getSimpleName
(
)
,
!
el
.
getElements
(
new
TypeFilter
<
>
(
x
.
getActualClass
(
)
)
)
.
isEmpty
(
)
)
;
codeElementsDocumentationPage
.
append
(
snippet
+
"\n"
)
;
}
while
(
m
.
find
(
)
)
;
codeElementsDocumentationPage
.
append
(
"```"
+
"\n"
)
;
}
}
)
;
try
{
assertEquals
(
"doc outdated, please commit doc/code_elements.md"
,
IOUtils
.
toString
(
new
FileReader
(
"doc/code_elements.md"
)
)
,
codeElementsDocumentationPage
.
toString
(
)
)
;
}
finally
{
write
(
codeElementsDocumentationPage
.
toString
(
)
,
new
FileOutputStream
(
"doc/code_elements.md"
)
)
;
}
}
