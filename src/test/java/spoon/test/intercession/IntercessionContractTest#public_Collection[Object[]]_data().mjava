@Parameterized.Parameters(name="{0}")
public
static
Collection
<
Object
[
]
>
data
(
)
throws
Exception
{
final
Launcher
launcher
=
new
Launcher
(
)
;
final
Factory
factory
=
launcher
.
getFactory
(
)
;
launcher
.
getEnvironment
(
)
.
setNoClasspath
(
true
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/reflect/code"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/reflect/declaration"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/reflect/reference"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/support/reflect/code"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/support/reflect/declaration"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/support/reflect/reference"
)
;
launcher
.
buildModel
(
)
;
final
List
<
Object
[
]
>
values
=
new
ArrayList
<
>
(
)
;
new
IntercessionScanner
(
launcher
.
getFactory
(
)
)
{
@Override
protected
boolean
isToBeProcessed
(
CtMethod
<
?
>
candidate
)
{
return
(
candidate
.
getSimpleName
(
)
.
startsWith
(
"set"
)
||
candidate
.
getSimpleName
(
)
.
startsWith
(
"add"
)
)
&&
candidate
.
hasModifier
(
ModifierKind
.
PUBLIC
)
&&
takeSetterForCtElement
(
candidate
)
&&
avoidInterfaces
(
candidate
)
&&
avoidThrowUnsupportedOperationException
(
candidate
)
;
}
@Override
protected
void
process
(
CtMethod
<
?
>
element
)
{
values
.
add
(
new
Object
[
]
{
getDeclaringClassConcrete
(
element
)
,
element
.
getReference
(
)
.
getActualMethod
(
)
}
)
;
}
private
Class
<
?
>
getDeclaringClassConcrete
(
CtMethod
<
?
>
element
)
{
final
CtType
<
?
>
declaringType
=
element
.
getDeclaringType
(
)
;
if
(
!
declaringType
.
hasModifier
(
ModifierKind
.
ABSTRACT
)
)
{
return
declaringType
.
getActualClass
(
)
;
}
final
List
<
CtTypeReference
<
?
>
>
superClasses
=
getSuperClassesOf
(
declaringType
)
;
superClasses
.
add
(
declaringType
.
getReference
(
)
)
;
final
List
<
CtClass
<
?
>
>
elements
=
Query
.
getElements
(
factory
,
new
TypeFilter
<
CtClass
<
?
>
>
(
CtClass
.
class
)
{
@Override
public
boolean
matches
(
CtClass
<
?
>
element
)
{
return
super
.
matches
(
element
)
&&
!
element
.
hasModifier
(
ModifierKind
.
ABSTRACT
)
&&
!
superClasses
.
contains
(
element
.
getReference
(
)
)
&&
getSuperClassesOf
(
element
)
.
contains
(
declaringType
.
getReference
(
)
)
;
}
}
)
;
if
(
elements
.
size
(
)
<=
0
)
{
fail
(
"Can't have an abstract class without any concrete sub class. Error detected with "
+
declaringType
.
getQualifiedName
(
)
)
;
}
return
takeFirstOneCorrect
(
element
,
elements
)
;
}
private
Class
<
?
>
takeFirstOneCorrect
(
CtMethod
<
?
>
element
,
List
<
CtClass
<
?
>
>
potentials
)
{
for
(
CtClass
<
?
>
potential
:
potentials
)
{
final
CtMethod
<
?
>
method
=
potential
.
getMethod
(
element
.
getType
(
)
,
element
.
getSimpleName
(
)
,
element
.
getParameters
(
)
.
stream
(
)
.
map
(
CtTypedElement
::
getType
)
.
toArray
(
CtTypeReference
[
]
::
new
)
)
;
if
(
method
==
null
)
{
continue
;
}
if
(
avoidThrowUnsupportedOperationException
(
method
)
)
{
return
potential
.
getActualClass
(
)
;
}
}
return
potentials
.
get
(
0
)
.
getActualClass
(
)
;
}
private
List
<
CtTypeReference
<
?
>
>
getSuperClassesOf
(
CtType
<
?
>
declaringType
)
{
final
List
<
CtTypeReference
<
?
>
>
superClasses
=
new
ArrayList
<
>
(
)
;
CtTypeReference
<
?
>
declaringTypeReference
=
declaringType
.
getReference
(
)
;
while
(
declaringTypeReference
.
getSuperclass
(
)
!=
null
)
{
superClasses
.
add
(
declaringTypeReference
.
getSuperclass
(
)
)
;
declaringTypeReference
=
declaringTypeReference
.
getSuperclass
(
)
;
}
return
superClasses
;
}
}
.
scan
(
launcher
.
getModel
(
)
.
getRootPackage
(
)
)
;
return
values
;
}
