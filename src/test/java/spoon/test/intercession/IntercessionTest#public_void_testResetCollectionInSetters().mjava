@Test
public
void
testResetCollectionInSetters
(
)
throws
Exception
{
final
Launcher
launcher
=
new
Launcher
(
)
;
final
Factory
factory
=
launcher
.
getFactory
(
)
;
launcher
.
getEnvironment
(
)
.
setNoClasspath
(
true
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/reflect/code"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/reflect/declaration"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/reflect/reference"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/support/reflect/code"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/support/reflect/declaration"
)
;
launcher
.
addInputResource
(
"./src/main/java/spoon/support/reflect/reference"
)
;
launcher
.
buildModel
(
)
;
new
IntercessionScanner
(
factory
)
{
@Override
protected
boolean
isToBeProcessed
(
CtMethod
<
?
>
candidate
)
{
return
candidate
.
getSimpleName
(
)
.
startsWith
(
"set"
)
&&
candidate
.
hasModifier
(
ModifierKind
.
PUBLIC
)
&&
takeSetterCollection
(
candidate
)
&&
avoidInterfaces
(
candidate
)
&&
avoidSpecificMethods
(
candidate
)
&&
avoidThrowUnsupportedOperationException
(
candidate
)
;
}
private
boolean
takeSetterCollection
(
CtMethod
<
?
>
candidate
)
{
final
CtTypeReference
<
?
>
type
=
candidate
.
getParameters
(
)
.
get
(
0
)
.
getType
(
)
;
final
List
<
CtTypeReference
<
?
>
>
actualTypeArguments
=
type
.
getActualTypeArguments
(
)
;
return
COLLECTIONS
.
contains
(
type
)
&&
actualTypeArguments
.
size
(
)
==
1
&&
actualTypeArguments
.
get
(
0
)
.
isSubtypeOf
(
CTELEMENT_REFERENCE
)
;
}
@Override
protected
void
process
(
CtMethod
<
?
>
element
)
{
final
CtStatement
statement
=
element
.
getBody
(
)
.
getStatement
(
0
)
;
if
(
!
(
statement
instanceof
CtIf
)
)
{
fail
(
log
(
element
,
"First statement should be an if to check the parameter of the setter"
)
)
;
}
final
CtIf
anIf
=
(
CtIf
)
statement
;
if
(
!
createCheckNull
(
element
.
getParameters
(
)
.
get
(
0
)
)
.
equals
(
anIf
.
getCondition
(
)
)
)
{
fail
(
log
(
element
,
"Condition should test if the parameter is null.\nThe condition was "
+
anIf
.
getCondition
(
)
)
)
;
}
if
(
!
(
anIf
.
getThenStatement
(
)
instanceof
CtBlock
)
)
{
fail
(
log
(
element
,
"Should have a block in the if condition to have the initialization and the return."
)
)
;
}
if
(
element
.
getParameters
(
)
.
get
(
0
)
.
getType
(
)
.
equals
(
SET_REFERENCE
)
)
{
if
(
!
hasCallEmptyInv
(
anIf
.
getThenStatement
(
)
,
SET_REFERENCE
)
)
{
fail
(
log
(
element
,
"Should initilize the list with CtElementImpl#emptySet()."
)
)
;
}
}
else
{
if
(
!
hasCallEmptyInv
(
anIf
.
getThenStatement
(
)
,
LIST_REFERENCE
)
)
{
fail
(
log
(
element
,
"Should initilize the list with CtElementImpl#emptyList()."
)
)
;
}
}
}
private
boolean
hasCallEmptyInv
(
CtBlock
thenStatement
,
CtTypeReference
<
?
Collection
>
collectionReference
)
{
if
(
!
(
thenStatement
.
getStatement
(
0
)
instanceof
CtAssignment
)
)
{
return
false
;
}
final
CtExpression
assignment
=
(
(
CtAssignment
)
thenStatement
.
getStatement
(
0
)
)
.
getAssignment
(
)
;
if
(
!
(
assignment
instanceof
CtInvocation
)
)
{
return
false
;
}
final
CtInvocation
inv
=
(
CtInvocation
)
assignment
;
if
(
collectionReference
.
equals
(
SET_REFERENCE
)
)
{
if
(
!
inv
.
getExecutable
(
)
.
getSimpleName
(
)
.
equals
(
"emptySet"
)
)
{
return
false
;
}
}
else
if
(
collectionReference
.
equals
(
LIST_REFERENCE
)
)
{
if
(
!
inv
.
getExecutable
(
)
.
getSimpleName
(
)
.
equals
(
"emptyList"
)
)
{
return
false
;
}
}
return
true
;
}
/** 
 * Creates <code>list == null && list.isEmpty()</code>.
 * @param ctParameter <code>list</code>
 */
private
CtBinaryOperator
<
Boolean
>
createCheckNull
(
CtParameter
<
?
>
ctParameter
)
{
final
CtVariableAccess
<
?
>
variableRead
=
factory
.
Code
(
)
.
createVariableRead
(
ctParameter
.
getReference
(
)
,
true
)
;
final
CtLiteral
nullLiteral
=
factory
.
Code
(
)
.
createLiteral
(
null
)
;
nullLiteral
.
setType
(
factory
.
Type
(
)
.
nullType
(
)
)
;
final
CtBinaryOperator
<
Boolean
>
checkNull
=
factory
.
Code
(
)
.
createBinaryOperator
(
variableRead
,
nullLiteral
,
BinaryOperatorKind
.
EQ
)
;
checkNull
.
setType
(
factory
.
Type
(
)
.
BOOLEAN_PRIMITIVE
)
;
final
CtMethod
<
Boolean
>
isEmptyMethod
=
ctParameter
.
getType
(
)
.
getTypeDeclaration
(
)
.
getMethod
(
factory
.
Type
(
)
.
booleanPrimitiveType
(
)
,
"isEmpty"
)
;
final
CtInvocation
<
Boolean
>
isEmpty
=
factory
.
Code
(
)
.
createInvocation
(
variableRead
,
isEmptyMethod
.
getReference
(
)
)
;
final
CtBinaryOperator
<
Boolean
>
condition
=
factory
.
Code
(
)
.
createBinaryOperator
(
checkNull
,
isEmpty
,
BinaryOperatorKind
.
OR
)
;
return
condition
.
setType
(
factory
.
Type
(
)
.
booleanPrimitiveType
(
)
)
;
}
private
String
log
(
CtMethod
<
?
>
element
,
String
message
)
{
return
message
+
"\nin "
+
element
.
getSignature
(
)
+
"\ndeclared in "
+
element
.
getDeclaringType
(
)
.
getQualifiedName
(
)
;
}
}
.
scan
(
factory
.
getModel
(
)
.
getRootPackage
(
)
)
;
}
