@Test
public
void
testWithImportFromItf
(
)
{
Launcher
spoon
=
new
Launcher
(
)
;
spoon
.
addInputResource
(
"./src/test/resources/jdtimportbuilder/"
)
;
spoon
.
getEnvironment
(
)
.
setAutoImports
(
true
)
;
spoon
.
getEnvironment
(
)
.
setShouldCompile
(
true
)
;
spoon
.
setSourceOutputDirectory
(
"./target/spoon-jdtimport-itfimport"
)
;
spoon
.
run
(
)
;
CtClass
classStatic
=
spoon
.
getFactory
(
)
.
Class
(
)
.
get
(
"jdtimportbuilder.ItfImport"
)
;
CompilationUnit
unitStatic
=
spoon
.
getFactory
(
)
.
CompilationUnit
(
)
.
getMap
(
)
.
get
(
classStatic
.
getPosition
(
)
.
getFile
(
)
.
getPath
(
)
)
;
Collection
<
CtReference
>
imports
=
unitStatic
.
getImports
(
)
;
assertEquals
(
2
,
imports
.
size
(
)
)
;
List
<
String
>
importNames
=
new
SortedList
<
String
>
(
new
Comparator
<
String
>
(
)
{
@Override
public
int
compare
(
String
o1
,
String
o2
)
{
return
o1
.
compareTo
(
o2
)
;
}
}
)
;
for
(
CtReference
refImport
:
imports
)
{
if
(
refImport
instanceof
CtFieldReference
)
{
importNames
.
add
(
(
(
CtFieldReference
)
refImport
)
.
getQualifiedName
(
)
)
;
}
else
if
(
refImport
instanceof
CtExecutableReference
)
{
importNames
.
add
(
(
(
CtExecutableReference
)
refImport
)
.
getDeclaringType
(
)
.
getQualifiedName
(
)
+
CtMethod
.
EXECUTABLE_SEPARATOR
+
refImport
.
getSimpleName
(
)
)
;
}
}
assertEquals
(
"jdtimportbuilder.itf.DumbItf#MYSTRING"
,
importNames
.
get
(
0
)
)
;
assertEquals
(
"jdtimportbuilder.itf.DumbItf#anotherStaticMethod"
,
importNames
.
get
(
1
)
)
;
}
