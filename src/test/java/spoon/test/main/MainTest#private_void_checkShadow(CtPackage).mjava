private
void
checkShadow
(
CtPackage
pack
)
{
new
CtScanner
(
)
{
@Override
public
void
scan
(
CtElement
element
)
{
if
(
element
!=
null
&&
CtShadowable
.
class
.
isAssignableFrom
(
element
.
getClass
(
)
)
)
{
assertFalse
(
(
(
CtShadowable
)
element
)
.
isShadow
(
)
)
;
}
super
.
scan
(
element
)
;
}
@Override
public
<
T
>
void
visitCtTypeReference
(
CtTypeReference
<
T
>
reference
)
{
assertNotNull
(
reference
)
;
if
(
CtTypeReference
.
NULL_TYPE_NAME
.
equals
(
reference
.
getSimpleName
(
)
)
||
"?"
.
equals
(
reference
.
getSimpleName
(
)
)
)
{
super
.
visitCtTypeReference
(
reference
)
;
return
;
}
final
CtType
<
T
>
typeDeclaration
=
reference
.
getTypeDeclaration
(
)
;
assertNotNull
(
typeDeclaration
)
;
assertEquals
(
reference
.
getSimpleName
(
)
,
typeDeclaration
.
getSimpleName
(
)
)
;
assertEquals
(
reference
.
getQualifiedName
(
)
,
typeDeclaration
.
getQualifiedName
(
)
)
;
if
(
reference
.
getDeclaration
(
)
==
null
)
{
assertTrue
(
typeDeclaration
.
isShadow
(
)
)
;
}
super
.
visitCtTypeReference
(
reference
)
;
}
@Override
public
<
T
>
void
visitCtExecutableReference
(
CtExecutableReference
<
T
>
reference
)
{
super
.
visitCtExecutableReference
(
reference
)
;
assertNotNull
(
reference
)
;
if
(
isLanguageExecutable
(
reference
)
)
{
return
;
}
final
CtExecutable
<
T
>
executableDeclaration
=
reference
.
getExecutableDeclaration
(
)
;
assertNotNull
(
"cannot find decl for "
+
reference
.
toString
(
)
,
executableDeclaration
)
;
assertEquals
(
reference
.
getSimpleName
(
)
,
executableDeclaration
.
getSimpleName
(
)
)
;
for
(
int
i
=
0
;
i
<
reference
.
getParameters
(
)
.
size
(
)
;
i
++
)
{
if
(
reference
.
getParameters
(
)
.
get
(
i
)
instanceof
CtTypeParameterReference
)
{
return
;
}
if
(
reference
.
getParameters
(
)
.
get
(
i
)
instanceof
CtArrayTypeReference
&&
(
(
CtArrayTypeReference
)
reference
.
getParameters
(
)
.
get
(
i
)
)
.
getComponentType
(
)
instanceof
CtTypeParameterReference
)
{
return
;
}
if
(
executableDeclaration
instanceof
CtLambda
)
{
return
;
}
assertEquals
(
reference
.
getParameters
(
)
.
get
(
i
)
.
getQualifiedName
(
)
,
executableDeclaration
.
getParameters
(
)
.
get
(
i
)
.
getType
(
)
.
getQualifiedName
(
)
)
;
}
if
(
reference
.
getActualTypeArguments
(
)
.
size
(
)
==
0
&&
executableDeclaration
instanceof
CtMethod
&&
(
(
CtMethod
)
executableDeclaration
)
.
getFormalCtTypeParameters
(
)
.
size
(
)
!=
0
)
{
assertEquals
(
reference
.
getSignature
(
)
,
executableDeclaration
.
getSignature
(
)
)
;
}
if
(
reference
.
getActualTypeArguments
(
)
.
size
(
)
==
0
&&
executableDeclaration
instanceof
CtConstructor
&&
(
(
CtConstructor
)
executableDeclaration
)
.
getFormalCtTypeParameters
(
)
.
size
(
)
!=
0
)
{
assertEquals
(
reference
.
getSignature
(
)
,
executableDeclaration
.
getSignature
(
)
)
;
}
if
(
reference
.
getDeclaration
(
)
==
null
&&
CtShadowable
.
class
.
isAssignableFrom
(
executableDeclaration
.
getClass
(
)
)
)
{
assertTrue
(
(
(
CtShadowable
)
executableDeclaration
)
.
isShadow
(
)
)
;
}
}
private
<
T
>
boolean
isLanguageExecutable
(
CtExecutableReference
<
T
>
reference
)
{
return
"values"
.
equals
(
reference
.
getSimpleName
(
)
)
;
}
@Override
public
<
T
>
void
visitCtFieldReference
(
CtFieldReference
<
T
>
reference
)
{
assertNotNull
(
reference
)
;
if
(
isLanguageField
(
reference
)
||
isDeclaredInSuperClass
(
reference
)
)
{
super
.
visitCtFieldReference
(
reference
)
;
return
;
}
final
CtField
<
T
>
fieldDeclaration
=
reference
.
getFieldDeclaration
(
)
;
assertNotNull
(
fieldDeclaration
)
;
assertEquals
(
reference
.
getSimpleName
(
)
,
fieldDeclaration
.
getSimpleName
(
)
)
;
assertEquals
(
reference
.
getType
(
)
.
getQualifiedName
(
)
,
fieldDeclaration
.
getType
(
)
.
getQualifiedName
(
)
)
;
if
(
reference
.
getDeclaration
(
)
==
null
)
{
assertTrue
(
fieldDeclaration
.
isShadow
(
)
)
;
}
super
.
visitCtFieldReference
(
reference
)
;
}
private
<
T
>
boolean
isLanguageField
(
CtFieldReference
<
T
>
reference
)
{
return
"class"
.
equals
(
reference
.
getSimpleName
(
)
)
||
"length"
.
equals
(
reference
.
getSimpleName
(
)
)
;
}
private
<
T
>
boolean
isDeclaredInSuperClass
(
CtFieldReference
<
T
>
reference
)
{
final
CtType
<
?
>
typeDeclaration
=
reference
.
getDeclaringType
(
)
.
getTypeDeclaration
(
)
;
return
typeDeclaration
!=
null
&&
typeDeclaration
.
getField
(
reference
.
getSimpleName
(
)
)
==
null
;
}
}
.
visitCtPackage
(
pack
)
;
}
