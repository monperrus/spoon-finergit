@Test
public
void
testGetModifiersHelpers
(
)
{
Launcher
spoon
=
new
Launcher
(
)
;
spoon
.
addInputResource
(
"./src/test/java/spoon/test/modifiers/testclasses/AbstractClass.java"
)
;
spoon
.
addInputResource
(
"./src/test/java/spoon/test/modifiers/testclasses/ConcreteClass.java"
)
;
spoon
.
getEnvironment
(
)
.
setShouldCompile
(
true
)
;
spoon
.
run
(
)
;
CtType
<
?
>
abstractClass
=
spoon
.
getFactory
(
)
.
Type
(
)
.
get
(
AbstractClass
.
class
)
;
checkCtModifiableHelpersAssertion
(
abstractClass
,
true
,
false
,
false
,
true
,
false
,
false
)
;
assertEquals
(
4
,
abstractClass
.
getFields
(
)
.
size
(
)
)
;
for
(
CtField
field
:
abstractClass
.
getFields
(
)
)
{
switch
(
field
.
getSimpleName
(
)
)
{
case
"privateField"
:
checkCtModifiableHelpersAssertion
(
field
,
false
,
false
,
true
,
false
,
false
,
false
)
;
break
;
case
"protectedField"
:
checkCtModifiableHelpersAssertion
(
field
,
false
,
true
,
false
,
false
,
false
,
false
)
;
break
;
case
"privateStaticField"
:
checkCtModifiableHelpersAssertion
(
field
,
false
,
false
,
true
,
false
,
false
,
true
)
;
break
;
case
"publicFinalField"
:
checkCtModifiableHelpersAssertion
(
field
,
true
,
false
,
false
,
false
,
true
,
false
)
;
break
;
default
:
fail
(
"The field "
+
field
.
getSimpleName
(
)
+
" should be take into account."
)
;
}
}
assertEquals
(
4
,
abstractClass
.
getMethods
(
)
.
size
(
)
)
;
for
(
CtMethod
method
:
abstractClass
.
getMethods
(
)
)
{
switch
(
method
.
getSimpleName
(
)
)
{
case
"method"
:
checkCtModifiableHelpersAssertion
(
method
,
true
,
false
,
false
,
false
,
true
,
true
)
;
break
;
case
"onlyStatic"
:
checkCtModifiableHelpersAssertion
(
method
,
true
,
false
,
false
,
false
,
false
,
true
)
;
break
;
case
"otherMethod"
:
checkCtModifiableHelpersAssertion
(
method
,
false
,
true
,
false
,
true
,
false
,
false
)
;
break
;
case
"anotherOne"
:
checkCtModifiableHelpersAssertion
(
method
,
false
,
false
,
false
,
true
,
false
,
false
)
;
break
;
default
:
fail
(
"The method "
+
method
.
getSimpleName
(
)
+
" should be taken into account."
)
;
}
}
CtType
<
?
>
concreteClass
=
spoon
.
getFactory
(
)
.
Type
(
)
.
get
(
"spoon.test.modifiers.testclasses.ConcreteClass"
)
;
checkCtModifiableHelpersAssertion
(
concreteClass
,
false
,
false
,
false
,
false
,
true
,
false
)
;
assertEquals
(
2
,
concreteClass
.
getFields
(
)
.
size
(
)
)
;
for
(
CtField
field
:
concreteClass
.
getFields
(
)
)
{
switch
(
field
.
getSimpleName
(
)
)
{
case
"className"
:
checkCtModifiableHelpersAssertion
(
field
,
true
,
false
,
false
,
false
,
true
,
true
)
;
break
;
case
"test"
:
checkCtModifiableHelpersAssertion
(
field
,
false
,
false
,
true
,
false
,
false
,
true
)
;
break
;
default
:
fail
(
"The field "
+
field
.
getSimpleName
(
)
+
" should be take into account."
)
;
}
}
assertEquals
(
2
,
concreteClass
.
getMethods
(
)
.
size
(
)
)
;
for
(
CtMethod
method
:
concreteClass
.
getMethods
(
)
)
{
switch
(
method
.
getSimpleName
(
)
)
{
case
"otherMethod"
:
checkCtModifiableHelpersAssertion
(
method
,
false
,
true
,
false
,
false
,
false
,
false
)
;
break
;
case
"anotherOne"
:
checkCtModifiableHelpersAssertion
(
method
,
false
,
false
,
false
,
false
,
true
,
false
)
;
break
;
default
:
fail
(
"The method "
+
method
.
getSimpleName
(
)
+
" should be taken into account."
)
;
}
}
}
