public
static
Object
createCompatibleObject
(
CtTypeReference
<
?
>
parameterType
)
{
Class
<
?
>
c
=
parameterType
.
getActualClass
(
)
;
Factory
f
=
parameterType
.
getFactory
(
)
;
if
(
Class
.
class
.
isAssignableFrom
(
c
)
&&
parameterType
.
getActualTypeArguments
(
)
.
size
(
)
==
0
)
{
return
Object
.
class
;
}
if
(
Class
.
class
.
isAssignableFrom
(
c
)
&&
parameterType
.
getActualTypeArguments
(
)
.
get
(
0
)
.
toString
(
)
.
equals
(
"?"
)
)
{
return
Object
.
class
;
}
if
(
Class
.
class
.
isAssignableFrom
(
c
)
&&
parameterType
.
getActualTypeArguments
(
)
.
get
(
0
)
.
toString
(
)
.
equals
(
"? extends java.lang.Throwable"
)
)
{
return
Exception
.
class
;
}
if
(
Class
.
class
.
isAssignableFrom
(
c
)
&&
parameterType
.
getActualTypeArguments
(
)
.
get
(
0
)
.
toString
(
)
.
equals
(
"? extends spoon.reflect.declaration.CtElement"
)
)
{
return
CtCodeSnippetExpression
.
class
;
}
if
(
parameterType
.
toString
(
)
.
equals
(
"spoon.reflect.declaration.CtType<?>"
)
)
{
CtClass
fooBar
=
f
.
createClass
(
"FooBar"
)
;
fooBar
.
delete
(
)
;
return
fooBar
;
}
for
(
CtType
t
:
allInstantiableMetamodelInterfaces
)
{
if
(
c
.
isAssignableFrom
(
t
.
getActualClass
(
)
)
)
{
CtElement
argument
=
factory
.
Core
(
)
.
create
(
t
.
getActualClass
(
)
)
;
if
(
argument
instanceof
CtPackage
)
{
(
(
CtPackage
)
argument
)
.
setSimpleName
(
argument
.
getShortRepresentation
(
)
)
;
}
return
argument
;
}
}
if
(
BinaryOperatorKind
.
class
.
isAssignableFrom
(
c
)
)
{
return
BinaryOperatorKind
.
AND
;
}
if
(
ModifierKind
.
class
.
isAssignableFrom
(
c
)
)
{
return
ModifierKind
.
PUBLIC
;
}
if
(
CtComment
.
CommentType
.
class
.
isAssignableFrom
(
c
)
)
{
return
CtComment
.
CommentType
.
INLINE
;
}
if
(
CtJavaDocTag
.
TagType
.
class
.
isAssignableFrom
(
c
)
)
{
return
CtJavaDocTag
.
TagType
.
SEE
;
}
if
(
ModifierKind
[
]
.
class
.
isAssignableFrom
(
c
)
)
{
return
new
ModifierKind
[
]
{
ModifierKind
.
PUBLIC
}
;
}
if
(
CompilationUnit
.
class
.
isAssignableFrom
(
c
)
)
{
return
parameterType
.
getFactory
(
)
.
createCompilationUnit
(
)
;
}
if
(
Set
.
class
.
isAssignableFrom
(
c
)
)
{
HashSet
<
Object
>
objects
=
new
HashSet
<
>
(
)
;
objects
.
add
(
createCompatibleObject
(
parameterType
.
getActualTypeArguments
(
)
.
get
(
0
)
)
)
;
return
objects
;
}
if
(
Collection
.
class
.
isAssignableFrom
(
c
)
)
{
ArrayList
<
Object
>
objects
=
new
ArrayList
<
>
(
)
;
objects
.
add
(
createCompatibleObject
(
parameterType
.
getActualTypeArguments
(
)
.
get
(
0
)
)
)
;
return
objects
;
}
if
(
String
.
class
.
isAssignableFrom
(
c
)
)
{
return
"42"
;
}
if
(
int
.
class
.
isAssignableFrom
(
c
)
)
{
return
42
;
}
if
(
boolean
.
class
.
isAssignableFrom
(
c
)
)
{
return
true
;
}
if
(
int
[
]
.
class
.
isAssignableFrom
(
c
)
)
{
return
new
int
[
]
{
42
}
;
}
if
(
CtExpression
[
]
.
class
.
isAssignableFrom
(
c
)
)
{
return
new
CtExpression
[
]
;
}
if
(
Object
[
]
.
class
.
isAssignableFrom
(
c
)
)
{
return
new
Object
[
]
{
42
}
;
}
if
(
java
.
lang
.
Package
.
class
.
isAssignableFrom
(
c
)
)
{
return
Package
.
getPackages
(
)
[
0
]
;
}
throw
new
IllegalArgumentException
(
"cannot instantiate "
+
parameterType
)
;
}
