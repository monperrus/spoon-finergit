@Test
public
void
testContract
(
)
throws
Throwable
{
Object
o
=
instance
;
for
(
Method
setter
:
getMethodsToInvoke
(
toTest
)
)
{
if
(
setter
.
getAnnotation
(
Deprecated
.
class
)
!=
null
)
continue
;
if
(
o
instanceof
CtAnnotationType
&&
"addMethod"
.
equals
(
setter
.
getName
(
)
)
)
continue
;
if
(
CtActualTypeContainer
.
class
.
isAssignableFrom
(
o
.
getClass
(
)
)
)
{
if
(
"setActualTypeArguments"
.
equals
(
setter
.
getName
(
)
)
)
continue
;
if
(
"addActualTypeArgument"
.
equals
(
setter
.
getName
(
)
)
)
continue
;
}
if
(
o
instanceof
CtInvocation
&&
"setType"
.
equals
(
setter
.
getName
(
)
)
)
continue
;
if
(
(
o
instanceof
CtConstructorCall
||
CtConstructorCall
.
class
.
isAssignableFrom
(
o
.
getClass
(
)
)
)
&&
"setType"
.
equals
(
setter
.
getName
(
)
)
)
continue
;
if
(
o
instanceof
CtTypeAccess
&&
"setType"
.
equals
(
setter
.
getName
(
)
)
)
continue
;
if
(
o
instanceof
CtType
&&
"setSuperclass"
.
equals
(
setter
.
getName
(
)
)
)
continue
;
CtElement
mockedArgument
=
(
CtElement
)
mock
(
setter
.
getParameters
(
)
[
0
]
.
getType
(
)
,
Mockito
.
withSettings
(
)
.
extraInterfaces
(
Comparable
.
class
)
)
;
try
{
CtElement
receiver
=
(
(
CtElement
)
o
)
.
clone
(
)
;
setter
.
invoke
(
receiver
,
new
Object
[
]
{
mockedArgument
}
)
;
verify
(
mockedArgument
)
.
setParent
(
(
CtElement
)
receiver
)
;
}
catch
(
AssertionError
e
)
{
Assert
.
fail
(
"call setParent contract failed for "
+
setter
.
toString
(
)
+
" "
+
e
.
toString
(
)
)
;
}
catch
(
InvocationTargetException
e
)
{
if
(
e
.
getCause
(
)
instanceof
UnsupportedOperationException
)
{
}
else
if
(
e
.
getCause
(
)
instanceof
RuntimeException
)
{
throw
e
.
getCause
(
)
;
}
else
{
throw
new
SpoonException
(
e
.
getCause
(
)
)
;
}
}
}
}
