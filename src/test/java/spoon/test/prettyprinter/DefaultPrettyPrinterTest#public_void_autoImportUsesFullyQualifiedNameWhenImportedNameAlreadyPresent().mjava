@Test
public
void
autoImportUsesFullyQualifiedNameWhenImportedNameAlreadyPresent
(
)
throws
Exception
{
final
Launcher
launcher
=
new
Launcher
(
)
;
final
Factory
factory
=
launcher
.
getFactory
(
)
;
factory
.
getEnvironment
(
)
.
setAutoImports
(
true
)
;
final
SpoonCompiler
compiler
=
launcher
.
createCompiler
(
)
;
compiler
.
addInputSource
(
new
File
(
"./src/test/java/spoon/test/prettyprinter/testclasses/sub/TypeIdentifierCollision.java"
)
)
;
compiler
.
addInputSource
(
new
File
(
"./src/test/java/spoon/test/prettyprinter/testclasses/TypeIdentifierCollision.java"
)
)
;
compiler
.
build
(
)
;
final
CtClass
<
?
>
aClass
=
(
CtClass
<
?
>
)
factory
.
Type
(
)
.
get
(
spoon
.
test
.
prettyprinter
.
testclasses
.
TypeIdentifierCollision
.
class
)
;
String
expected
=
"public void setFieldUsingExternallyDefinedEnumWithSameNameAsLocal() {"
+
nl
+
"    localField = E1.ordinal();"
+
nl
+
"}"
;
String
computed
=
aClass
.
getMethodsByName
(
"setFieldUsingExternallyDefinedEnumWithSameNameAsLocal"
)
.
get
(
0
)
.
toString
(
)
;
assertEquals
(
"E1 is statically imported then we can call it directly"
,
expected
,
computed
)
;
expected
=
"public void setFieldUsingLocallyDefinedEnum() {"
+
nl
+
"    localField = TypeIdentifierCollision.ENUM.E1.ordinal();"
+
nl
+
"}"
;
computed
=
aClass
.
getMethodsByName
(
"setFieldUsingLocallyDefinedEnum"
)
.
get
(
0
)
.
toString
(
)
;
assertEquals
(
expected
,
computed
)
;
expected
=
"public void setFieldOfClassWithSameNameAsTheCompilationUnitClass() {"
+
nl
+
"    globalField = localField;"
+
nl
+
"}"
;
computed
=
aClass
.
getMethodsByName
(
"setFieldOfClassWithSameNameAsTheCompilationUnitClass"
)
.
get
(
0
)
.
toString
(
)
;
assertEquals
(
"The static field of an external type with the same identifier as the compilation unit is statically imported"
,
expected
,
computed
)
;
expected
=
"public void referToTwoInnerClassesWithTheSameName() {"
+
nl
+
"    TypeIdentifierCollision.Class0.ClassA.VAR0 = TypeIdentifierCollision.Class0.ClassA.getNum();"
+
nl
+
"    TypeIdentifierCollision.Class1.ClassA.VAR1 = TypeIdentifierCollision.Class1.ClassA.getNum();"
+
nl
+
"}"
;
computed
=
aClass
.
getMethodsByName
(
"referToTwoInnerClassesWithTheSameName"
)
.
get
(
0
)
.
toString
(
)
;
assertEquals
(
"where inner types have the same identifier only one may be shortened and the other should be fully qualified"
,
expected
,
computed
)
;
expected
=
"public enum ENUM {"
+
nl
+
"E1(globalField,E1);"
+
nl
+
"    final int NUM;"
+
nl
+
nl
+
"    final Enum<?> e;"
+
nl
+
nl
+
"    private ENUM(int num, Enum<?> e) {"
+
nl
+
"        NUM = num;"
+
nl
+
"        this.e = e;"
+
nl
+
"    }"
+
nl
+
"}"
;
computed
=
aClass
.
getNestedType
(
"ENUM"
)
.
toString
(
)
;
assertEquals
(
"Parameters in an enum constructor should be statically imported when they refer to externally defined static field of a class with the same identifier as another locally defined type"
,
expected
,
computed
)
;
}
