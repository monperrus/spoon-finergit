private
Integer
getLiteralValue
(
CtVariable
<
?
>
var
)
{
CtExpression
<
?
>
exp
=
var
.
getDefaultExpression
(
)
;
if
(
exp
!=
null
)
{
try
{
return
getLiteralValue
(
exp
)
;
}
catch
(
ClassCastException
e
)
{
}
}
if
(
var
instanceof
CtParameter
)
{
CtParameter
param
=
(
CtParameter
)
var
;
CtExecutable
<
?
>
l_exec
=
param
.
getParent
(
CtExecutable
.
class
)
;
int
l_argIdx
=
l_exec
.
getParameters
(
)
.
indexOf
(
param
)
;
assertTrue
(
l_argIdx
>=
0
)
;
if
(
l_exec
instanceof
CtLambda
)
{
CtLambda
<
?
>
lambda
=
(
CtLambda
<
?
>
)
l_exec
;
CtLocalVariable
<
?
>
lamVar
=
(
CtLocalVariable
)
lambda
.
getParent
(
)
;
CtLocalVariableReference
<
?
>
lamVarRef
=
lamVar
.
getParent
(
)
.
filterChildren
(
(
CtLocalVariableReference
ref
)
->
ref
.
getSimpleName
(
)
.
equals
(
lamVar
.
getSimpleName
(
)
)
)
.
first
(
)
;
CtAbstractInvocation
inv
=
lamVarRef
.
getParent
(
CtAbstractInvocation
.
class
)
;
return
getLiteralValue
(
(
CtExpression
<
?
>
)
inv
.
getArguments
(
)
.
get
(
l_argIdx
)
)
;
}
else
{
CtExecutableReference
<
?
>
l_execRef
=
l_exec
.
getReference
(
)
;
List
<
CtAbstractInvocation
<
?
>
>
list
=
l_exec
.
getFactory
(
)
.
Package
(
)
.
getRootPackage
(
)
.
filterChildren
(
(
CtAbstractInvocation
inv
)
->
{
return
inv
.
getExecutable
(
)
.
getExecutableDeclaration
(
)
==
l_exec
;
}
)
.
list
(
)
;
CtAbstractInvocation
inv
=
list
.
get
(
0
)
;
Integer
firstValue
=
getLiteralValue
(
(
CtExpression
<
?
>
)
inv
.
getArguments
(
)
.
get
(
l_argIdx
)
)
;
list
.
forEach
(
inv2
->
{
assertEquals
(
firstValue
,
getLiteralValue
(
(
CtExpression
<
?
>
)
inv2
.
getArguments
(
)
.
get
(
l_argIdx
)
)
)
;
}
)
;
return
firstValue
;
}
}
return
getCommentValue
(
var
)
;
}
