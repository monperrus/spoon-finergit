@Test
public
void
testGenerateClassWithSelfReferences
(
)
throws
Exception
{
CtType
templateModel
=
ModelUtils
.
buildClass
(
AClassWithMethodsAndRefs
.
class
)
;
Factory
factory
=
templateModel
.
getFactory
(
)
;
Pattern
pattern
=
PatternBuilder
.
create
(
templateModel
)
.
setAddGeneratedBy
(
true
)
.
build
(
)
;
final
String
newQName
=
"spoon.test.generated.ACloneOfAClassWithMethodsAndRefs"
;
CtClass
<
?
>
generatedType
=
pattern
.
generator
(
)
.
generateType
(
newQName
,
Collections
.
emptyMap
(
)
)
;
assertNotNull
(
generatedType
)
;
assertEquals
(
Arrays
.
asList
(
"<init>"
,
"local"
,
"sameType"
,
"sameTypeStatic"
,
"anotherMethod"
,
"someMethod"
,
"Local"
,
"foo"
)
,
generatedType
.
getTypeMembers
(
)
.
stream
(
)
.
map
(
CtTypeMember
::
getSimpleName
)
.
collect
(
Collectors
.
toList
(
)
)
)
;
assertEquals
(
newQName
,
generatedType
.
getQualifiedName
(
)
)
;
Set
<
String
>
usedTypeRefs
=
new
HashSet
<
>
(
)
;
generatedType
.
filterChildren
(
new
TypeFilter
<
>
(
CtTypeReference
.
class
)
)
.
forEach
(
(
CtTypeReference
ref
)
->
usedTypeRefs
.
add
(
ref
.
getQualifiedName
(
)
)
)
;
assertEquals
(
new
HashSet
<
>
(
Arrays
.
asList
(
"spoon.test.generated.ACloneOfAClassWithMethodsAndRefs"
,
"void"
,
"boolean"
,
"spoon.test.generated.ACloneOfAClassWithMethodsAndRefs$1Bar"
,
"java.lang.Object"
,
"int"
,
"spoon.test.generated.ACloneOfAClassWithMethodsAndRefs$Local"
)
)
,
usedTypeRefs
)
;
generatedType
.
filterChildren
(
new
TypeFilter
<
>
(
CtExecutableReference
.
class
)
)
.
forEach
(
(
CtExecutableReference
execRef
)
->
{
CtTypeReference
declTypeRef
=
execRef
.
getDeclaringType
(
)
;
if
(
declTypeRef
.
getQualifiedName
(
)
.
startsWith
(
"spoon.test.generated.ACloneOfAClassWithMethodsAndRefs"
)
)
{
return
;
}
if
(
declTypeRef
.
getQualifiedName
(
)
.
equals
(
Object
.
class
.
getName
(
)
)
)
{
return
;
}
fail
(
"Unexpected declaring type "
+
declTypeRef
.
getQualifiedName
(
)
)
;
}
)
;
}
