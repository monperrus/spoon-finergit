@Test
public
void
testMatchSample1
(
)
throws
Exception
{
Factory
f
=
ModelUtils
.
build
(
new
File
(
"./src/test/java/spoon/test/template/testclasses/replace/DPPSample1.java"
)
,
new
File
(
"./src/test/java/spoon/test/template/testclasses/replace"
)
)
;
CtClass
<
?
>
classDJPP
=
f
.
Class
(
)
.
get
(
DPPSample1
.
class
)
;
assertNotNull
(
classDJPP
)
;
assertFalse
(
classDJPP
.
isShadow
(
)
)
;
CtType
<
Object
>
type
=
f
.
Type
(
)
.
get
(
OldPattern
.
class
)
;
Pattern
p
=
PatternBuilder
.
create
(
new
PatternBuilderHelper
(
type
)
.
setBodyOfMethod
(
"patternModel"
)
.
getPatternElements
(
)
)
.
configurePatternParameters
(
(
PatternParameterConfigurator
pb
)
->
pb
.
byFieldAccessOnVariable
(
"params"
)
.
byFieldAccessOnVariable
(
"item"
)
.
parameter
(
"statements"
)
.
setContainerKind
(
ContainerKind
.
LIST
)
)
.
configurePatternParameters
(
)
.
configureInlineStatements
(
ls
->
ls
.
inlineIfOrForeachReferringTo
(
"useStartKeyword"
)
)
.
build
(
)
;
List
<
Match
>
matches
=
p
.
getMatches
(
classDJPP
)
;
assertEquals
(
2
,
matches
.
size
(
)
)
;
ImmutableMap
params
=
matches
.
get
(
0
)
.
getParameters
(
)
;
assertEquals
(
"\"extends\""
,
params
.
getValue
(
"startKeyword"
)
.
toString
(
)
)
;
assertEquals
(
Boolean
.
TRUE
,
params
.
getValue
(
"useStartKeyword"
)
)
;
assertEquals
(
"false"
,
params
.
getValue
(
"startPrefixSpace"
)
.
toString
(
)
)
;
assertEquals
(
"null"
,
params
.
getValue
(
"start"
)
.
toString
(
)
)
;
assertEquals
(
"false"
,
params
.
getValue
(
"startSuffixSpace"
)
.
toString
(
)
)
;
assertEquals
(
"false"
,
params
.
getValue
(
"nextPrefixSpace"
)
.
toString
(
)
)
;
assertEquals
(
"\",\""
,
params
.
getValue
(
"next"
)
.
toString
(
)
)
;
assertEquals
(
"true"
,
params
.
getValue
(
"nextSuffixSpace"
)
.
toString
(
)
)
;
assertEquals
(
"false"
,
params
.
getValue
(
"endPrefixSpace"
)
.
toString
(
)
)
;
assertEquals
(
"\";\""
,
params
.
getValue
(
"end"
)
.
toString
(
)
)
;
assertEquals
(
"ctEnum.getEnumValues()"
,
params
.
getValue
(
"getIterable"
)
.
toString
(
)
)
;
assertEquals
(
"[scan(enumValue)]"
,
params
.
getValue
(
"statements"
)
.
toString
(
)
)
;
params
=
matches
.
get
(
1
)
.
getParameters
(
)
;
assertEquals
(
null
,
params
.
getValue
(
"startKeyword"
)
)
;
assertEquals
(
Boolean
.
FALSE
,
params
.
getValue
(
"useStartKeyword"
)
)
;
assertEquals
(
"false"
,
params
.
getValue
(
"startPrefixSpace"
)
.
toString
(
)
)
;
assertEquals
(
"null"
,
params
.
getValue
(
"start"
)
.
toString
(
)
)
;
assertEquals
(
"false"
,
params
.
getValue
(
"startSuffixSpace"
)
.
toString
(
)
)
;
assertEquals
(
"false"
,
params
.
getValue
(
"nextPrefixSpace"
)
.
toString
(
)
)
;
assertEquals
(
"\",\""
,
params
.
getValue
(
"next"
)
.
toString
(
)
)
;
assertEquals
(
"true"
,
params
.
getValue
(
"nextSuffixSpace"
)
.
toString
(
)
)
;
assertEquals
(
"false"
,
params
.
getValue
(
"endPrefixSpace"
)
.
toString
(
)
)
;
assertEquals
(
"\";\""
,
params
.
getValue
(
"end"
)
.
toString
(
)
)
;
assertEquals
(
"ctEnum.getEnumValues()"
,
params
.
getValue
(
"getIterable"
)
.
toString
(
)
)
;
assertEquals
(
"[scan(enumValue)]"
,
params
.
getValue
(
"statements"
)
.
toString
(
)
)
;
assertEquals
(
params
.
asMap
(
)
,
params
.
checkpoint
(
)
.
asMap
(
)
)
;
}
