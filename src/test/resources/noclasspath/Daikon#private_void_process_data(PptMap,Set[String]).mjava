/** 
 * The data-processing routine of the daikon engine.  At this point, the decls and spinfo files have been loaded, all of the program points have been setup, and candidate invariants have been instantiated.  This routine processes data to falsify the candidate invariants.
 */
private
static
void
process_data
(
PptMap
all_ppts
,
Set
<
String
>
dtrace_files
)
{
MemMonitor
monitor
=
null
;
if
(
use_mem_monitor
)
{
monitor
=
new
MemMonitor
(
"stat.out"
)
;
new
Thread
(
(
Runnable
)
monitor
)
.
start
(
)
;
}
stopwatch
.
reset
(
)
;
setup_NISuppression
(
)
;
try
{
fileio_progress
.
clear
(
)
;
if
(
!
Daikon
.
dkconfig_quiet
)
{
System
.
out
.
println
(
"Processing trace data; reading "
+
UtilMDE
.
nplural
(
dtrace_files
.
size
(
)
,
"dtrace file"
)
+
":"
)
;
}
FileIO
.
read_data_trace_files
(
dtrace_files
,
all_ppts
)
;
fileio_progress
.
shouldStop
=
true
;
fileio_progress
.
display
(
)
;
if
(
!
Daikon
.
dkconfig_quiet
)
{
System
.
out
.
println
(
)
;
}
}
catch
(
IOException
e
)
{
System
.
out
.
println
(
)
;
e
.
printStackTrace
(
)
;
throw
new
Error
(
e
)
;
}
finally
{
debugProgress
.
fine
(
"Time spent on read_data_trace_files: "
+
stopwatch
.
format
(
)
)
;
}
if
(
monitor
!=
null
)
{
monitor
.
stop
(
)
;
}
if
(
FileIO
.
dkconfig_read_samples_only
)
{
throw
new
Daikon
.
TerminationMessage
(
Fmt
.
spf
(
"Finished reading %s samples"
,
""
+
FileIO
.
samples_processed
)
)
;
}
if
(
all_ppts
.
size
(
)
==
0
)
{
String
message
=
"No program point declarations were found."
;
if
(
FileIO
.
omitted_declarations
!=
0
)
{
message
=
lineSep
+
"  "
+
FileIO
.
omitted_declarations
+
" "
+
(
(
FileIO
.
omitted_declarations
==
1
)
?
"declaration was"
:
"declarations were"
)
+
" omitted by regexps (e.g., --ppt-select-pattern)."
;
}
throw
new
Daikon
.
TerminationMessage
(
message
)
;
}
int
unmatched_count
=
FileIO
.
call_stack
.
size
(
)
+
FileIO
.
call_hashmap
.
size
(
)
;
if
(
(
use_dataflow_hierarchy
&&
FileIO
.
samples_processed
==
unmatched_count
)
||
(
FileIO
.
samples_processed
==
0
)
)
{
throw
new
Daikon
.
TerminationMessage
(
"No samples found for any of "
+
UtilMDE
.
nplural
(
all_ppts
.
size
(
)
,
"program point"
)
)
;
}
stopwatch
.
reset
(
)
;
debugProgress
.
fine
(
"Create Combined Exits ... "
)
;
create_combined_exits
(
all_ppts
)
;
if
(
dkconfig_use_dynamic_constant_optimization
)
{
debugProgress
.
fine
(
"Constant Post Processing ... "
)
;
for
(
Iterator
<
PptTopLevel
>
itor
=
all_ppts
.
ppt_all_iterator
(
)
;
itor
.
hasNext
(
)
;
)
{
PptTopLevel
ppt
=
itor
.
next
(
)
;
if
(
ppt
.
constants
!=
null
)
ppt
.
constants
.
post_process
(
)
;
}
}
debugProgress
.
fine
(
"Init Hierarchy ... "
)
;
if
(
FileIO
.
new_decl_format
)
PptRelation
.
init_hierarchy_new
(
all_ppts
)
;
else
PptRelation
.
init_hierarchy
(
all_ppts
)
;
debugProgress
.
fine
(
"Init Hierarchy ... done"
)
;
if
(
use_dataflow_hierarchy
)
{
debugProgress
.
fine
(
"createUpperPpts"
)
;
createUpperPpts
(
all_ppts
)
;
debugProgress
.
fine
(
"createUpperPpts ... done"
)
;
}
if
(
Daikon
.
use_equality_optimization
&&
!
Daikon
.
dkconfig_undo_opts
)
{
debugProgress
.
fine
(
"Equality Post Process ... "
)
;
for
(
Iterator
<
PptTopLevel
>
itor
=
all_ppts
.
ppt_all_iterator
(
)
;
itor
.
hasNext
(
)
;
)
{
PptTopLevel
ppt
=
itor
.
next
(
)
;
ppt
.
postProcessEquality
(
)
;
}
debugProgress
.
fine
(
"Equality Post Process ... done"
)
;
}
if
(
Daikon
.
dkconfig_undo_opts
)
{
undoOpts
(
all_ppts
)
;
}
if
(
debugEquality
.
isLoggable
(
Level
.
FINE
)
)
{
for
(
Iterator
<
PptTopLevel
>
itor
=
all_ppts
.
ppt_all_iterator
(
)
;
itor
.
hasNext
(
)
;
)
{
PptTopLevel
ppt
=
itor
.
next
(
)
;
debugEquality
.
fine
(
ppt
.
name
(
)
+
": "
+
ppt
.
equality_sets_txt
(
)
)
;
}
}
debugProgress
.
fine
(
"Time spent on non-implication postprocessing: "
+
stopwatch
.
format
(
)
)
;
isInferencing
=
false
;
stopwatch
.
reset
(
)
;
fileio_progress
.
clear
(
)
;
if
(
!
Daikon
.
dkconfig_disable_splitting
)
{
debugProgress
.
fine
(
"Adding Implications ... "
)
;
for
(
Iterator
<
PptTopLevel
>
itor
=
all_ppts
.
pptIterator
(
)
;
itor
.
hasNext
(
)
;
)
{
PptTopLevel
ppt
=
itor
.
next
(
)
;
ppt
.
addImplications
(
)
;
}
debugProgress
.
fine
(
"Time spent adding implications: "
+
stopwatch
.
format
(
)
)
;
}
}
