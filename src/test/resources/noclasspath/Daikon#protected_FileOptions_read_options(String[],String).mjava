protected
static
FileOptions
read_options
(
String
[
]
args
,
String
usage
)
{
if
(
args
.
length
==
0
)
{
System
.
out
.
println
(
"Daikon error: no files supplied on command line."
)
;
System
.
out
.
println
(
usage
)
;
throw
new
Daikon
.
TerminationMessage
(
)
;
}
HashSet
<
File
>
decl_files
=
new
LinkedHashSet
<
File
>
(
)
;
HashSet
<
String
>
dtrace_files
=
new
LinkedHashSet
<
String
>
(
)
;
HashSet
<
File
>
spinfo_files
=
new
LinkedHashSet
<
File
>
(
)
;
HashSet
<
File
>
map_files
=
new
LinkedHashSet
<
File
>
(
)
;
LongOpt
[
]
longopts
=
new
LongOpt
[
]
{
new
LongOpt
(
help_SWITCH
,
LongOpt
.
NO_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
no_text_output_SWITCH
,
LongOpt
.
NO_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
format_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
show_progress_SWITCH
,
LongOpt
.
NO_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
no_show_progress_SWITCH
,
LongOpt
.
NO_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
noversion_SWITCH
,
LongOpt
.
NO_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
output_num_samples_SWITCH
,
LongOpt
.
NO_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
files_from_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
omit_from_output_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
conf_limit_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
list_type_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
no_dataflow_hierarchy_SWITCH
,
LongOpt
.
NO_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
suppress_redundant_SWITCH
,
LongOpt
.
NO_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
ppt_regexp_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
ppt_omit_regexp_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
var_regexp_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
var_omit_regexp_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
server_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
config_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
config_option_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
debugAll_SWITCH
,
LongOpt
.
NO_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
debug_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
track_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
disc_reason_SWITCH
,
LongOpt
.
REQUIRED_ARGUMENT
,
null
,
0
)
,
new
LongOpt
(
mem_stat_SWITCH
,
LongOpt
.
NO_ARGUMENT
,
null
,
0
)
}
;
Getopt
g
=
new
Getopt
(
"daikon.Daikon"
,
args
,
"ho:"
,
longopts
)
;
int
c
;
while
(
(
c
=
g
.
getopt
(
)
)
!=
-
1
)
{
switch
(
c
)
{
case
0
:
String
option_name
=
longopts
[
g
.
getLongind
(
)
]
.
getName
(
)
;
if
(
help_SWITCH
.
equals
(
option_name
)
)
{
System
.
out
.
println
(
usage
)
;
throw
new
Daikon
.
TerminationMessage
(
)
;
}
else
if
(
no_text_output_SWITCH
.
equals
(
option_name
)
)
{
no_text_output
=
true
;
}
else
if
(
format_SWITCH
.
equals
(
option_name
)
)
{
String
format_name
=
g
.
getOptarg
(
)
;
Daikon
.
output_format
=
OutputFormat
.
get
(
format_name
)
;
if
(
Daikon
.
output_format
==
null
)
{
throw
new
Daikon
.
TerminationMessage
(
"Unknown output format:  --format "
+
format_name
)
;
}
}
else
if
(
show_progress_SWITCH
.
equals
(
option_name
)
)
{
show_progress
=
true
;
LogHelper
.
setLevel
(
"daikon.Progress"
,
LogHelper
.
FINE
)
;
}
else
if
(
no_show_progress_SWITCH
.
equals
(
option_name
)
)
{
show_progress
=
false
;
}
else
if
(
noversion_SWITCH
.
equals
(
option_name
)
)
{
noversion_output
=
true
;
}
else
if
(
output_num_samples_SWITCH
.
equals
(
option_name
)
)
{
output_num_samples
=
true
;
}
else
if
(
files_from_SWITCH
.
equals
(
option_name
)
)
{
String
files_from_filename
=
g
.
getOptarg
(
)
;
try
{
for
(
String
filename
:
new
TextFile
(
files_from_filename
)
)
{
if
(
filename
.
equals
(
""
)
)
{
continue
;
}
File
file
=
new
File
(
filename
)
;
if
(
!
file
.
exists
(
)
)
{
throw
new
Daikon
.
TerminationMessage
(
"File "
+
filename
+
" not found."
)
;
}
if
(
filename
.
indexOf
(
".decls"
)
!=
-
1
)
{
decl_files
.
add
(
file
)
;
}
else
if
(
filename
.
indexOf
(
".dtrace"
)
!=
-
1
)
{
dtrace_files
.
add
(
filename
)
;
}
else
if
(
filename
.
indexOf
(
".spinfo"
)
!=
-
1
)
{
spinfo_files
.
add
(
file
)
;
}
else
if
(
filename
.
indexOf
(
".map"
)
!=
-
1
)
{
map_files
.
add
(
file
)
;
}
else
{
throw
new
Daikon
.
TerminationMessage
(
"Unrecognized file extension: "
+
filename
)
;
}
}
}
catch
(
IOException
e
)
{
throw
new
RuntimeException
(
String
.
format
(
"Error reading --files_from file: %s"
,
files_from_filename
)
)
;
}
break
;
}
else
if
(
omit_from_output_SWITCH
.
equals
(
option_name
)
)
{
String
f
=
g
.
getOptarg
(
)
;
for
(
int
i
=
0
;
i
<
f
.
length
(
)
;
i
++
)
{
if
(
"0rs"
.
indexOf
(
f
.
charAt
(
i
)
)
==
-
1
)
throw
new
Daikon
.
TerminationMessage
(
"omit_from_output flag letter '"
+
f
.
charAt
(
i
)
+
"' is unknown"
)
;
omit_types
[
f
.
charAt
(
i
)
]
=
true
;
}
omit_from_output
=
true
;
}
else
if
(
conf_limit_SWITCH
.
equals
(
option_name
)
)
{
double
limit
=
Double
.
parseDouble
(
g
.
getOptarg
(
)
)
;
if
(
(
limit
<
0.0
)
||
(
limit
>
1.0
)
)
{
throw
new
Daikon
.
TerminationMessage
(
conf_limit_SWITCH
+
" must be between [0..1]"
)
;
}
Configuration
.
getInstance
(
)
.
apply
(
"daikon.inv.Invariant.confidence_limit"
,
String
.
valueOf
(
limit
)
)
;
}
else
if
(
list_type_SWITCH
.
equals
(
option_name
)
)
{
try
{
String
list_type_string
=
g
.
getOptarg
(
)
;
ProglangType
.
list_implementors
.
add
(
list_type_string
)
;
}
catch
(
Exception
e
)
{
throw
new
Daikon
.
TerminationMessage
(
"Problem parsing "
+
list_type_SWITCH
+
" option: "
+
e
)
;
}
break
;
}
else
if
(
no_dataflow_hierarchy_SWITCH
.
equals
(
option_name
)
)
{
use_dataflow_hierarchy
=
false
;
}
else
if
(
suppress_redundant_SWITCH
.
equals
(
option_name
)
)
{
suppress_redundant_invariants_with_simplify
=
true
;
}
else
if
(
ppt_regexp_SWITCH
.
equals
(
option_name
)
)
{
if
(
ppt_regexp
!=
null
)
throw
new
Daikon
.
TerminationMessage
(
"multiple --"
+
ppt_regexp_SWITCH
+
" regular expressions supplied on command line"
)
;
String
regexp_string
=
g
.
getOptarg
(
)
;
try
{
ppt_regexp
=
Pattern
.
compile
(
regexp_string
)
;
}
catch
(
Exception
e
)
{
throw
new
Daikon
.
TerminationMessage
(
"Bad regexp "
+
regexp_string
+
" for "
+
ppt_regexp_SWITCH
+
": "
+
e
.
getMessage
(
)
)
;
}
break
;
}
else
if
(
ppt_omit_regexp_SWITCH
.
equals
(
option_name
)
)
{
if
(
ppt_omit_regexp
!=
null
)
throw
new
Daikon
.
TerminationMessage
(
"multiple --"
+
ppt_omit_regexp_SWITCH
+
" regular expressions supplied on command line"
)
;
String
regexp_string
=
g
.
getOptarg
(
)
;
try
{
ppt_omit_regexp
=
Pattern
.
compile
(
regexp_string
)
;
}
catch
(
Exception
e
)
{
throw
new
Daikon
.
TerminationMessage
(
"Bad regexp "
+
regexp_string
+
" for "
+
ppt_omit_regexp_SWITCH
+
": "
+
e
.
getMessage
(
)
)
;
}
break
;
}
else
if
(
var_regexp_SWITCH
.
equals
(
option_name
)
)
{
if
(
var_regexp
!=
null
)
throw
new
Daikon
.
TerminationMessage
(
"multiple --"
+
var_regexp_SWITCH
+
" regular expressions supplied on command line"
)
;
String
regexp_string
=
g
.
getOptarg
(
)
;
try
{
var_regexp
=
Pattern
.
compile
(
regexp_string
)
;
}
catch
(
Exception
e
)
{
throw
new
Daikon
.
TerminationMessage
(
"Bad regexp "
+
regexp_string
+
" for "
+
var_regexp_SWITCH
+
": "
+
e
.
getMessage
(
)
)
;
}
break
;
}
else
if
(
var_omit_regexp_SWITCH
.
equals
(
option_name
)
)
{
if
(
var_omit_regexp
!=
null
)
throw
new
Daikon
.
TerminationMessage
(
"multiple --"
+
var_omit_regexp_SWITCH
+
" regular expressions supplied on command line"
)
;
String
regexp_string
=
g
.
getOptarg
(
)
;
try
{
var_omit_regexp
=
Pattern
.
compile
(
regexp_string
)
;
}
catch
(
Exception
e
)
{
throw
new
Daikon
.
TerminationMessage
(
"Bad regexp "
+
regexp_string
+
" for "
+
var_omit_regexp_SWITCH
+
": "
+
e
.
getMessage
(
)
)
;
}
break
;
}
else
if
(
server_SWITCH
.
equals
(
option_name
)
)
{
String
input_dir
=
g
.
getOptarg
(
)
;
server_dir
=
new
File
(
input_dir
)
;
if
(
!
server_dir
.
isDirectory
(
)
||
!
server_dir
.
canRead
(
)
||
!
server_dir
.
canWrite
(
)
)
throw
new
RuntimeException
(
"Could not open config file in server directory "
+
server_dir
)
;
break
;
}
else
if
(
config_SWITCH
.
equals
(
option_name
)
)
{
String
config_file
=
g
.
getOptarg
(
)
;
try
{
InputStream
stream
=
new
FileInputStream
(
config_file
)
;
Configuration
.
getInstance
(
)
.
apply
(
stream
)
;
}
catch
(
IOException
e
)
{
throw
new
Daikon
.
TerminationMessage
(
"Could not open config file "
+
config_file
)
;
}
break
;
}
else
if
(
config_option_SWITCH
.
equals
(
option_name
)
)
{
String
item
=
g
.
getOptarg
(
)
;
try
{
Configuration
.
getInstance
(
)
.
apply
(
item
)
;
}
catch
(
daikon
.
config
.
Configuration
.
ConfigException
e
)
{
throw
new
Daikon
.
TerminationMessage
(
e
)
;
}
break
;
}
else
if
(
debugAll_SWITCH
.
equals
(
option_name
)
)
{
Global
.
debugAll
=
true
;
}
else
if
(
debug_SWITCH
.
equals
(
option_name
)
)
{
LogHelper
.
setLevel
(
g
.
getOptarg
(
)
,
LogHelper
.
FINE
)
;
}
else
if
(
track_SWITCH
.
equals
(
option_name
)
)
{
LogHelper
.
setLevel
(
"daikon.Debug"
,
LogHelper
.
FINE
)
;
String
error
=
Debug
.
add_track
(
g
.
getOptarg
(
)
)
;
if
(
error
!=
null
)
{
throw
new
Daikon
.
TerminationMessage
(
"Error parsing track argument '"
+
g
.
getOptarg
(
)
+
"' - "
+
error
)
;
}
}
else
if
(
disc_reason_SWITCH
.
equals
(
option_name
)
)
{
try
{
PrintInvariants
.
discReasonSetup
(
g
.
getOptarg
(
)
)
;
}
catch
(
IllegalArgumentException
e
)
{
throw
new
Daikon
.
TerminationMessage
(
e
)
;
}
}
else
if
(
mem_stat_SWITCH
.
equals
(
option_name
)
)
{
use_mem_monitor
=
true
;
}
else
{
throw
new
Daikon
.
TerminationMessage
(
"Unknown option "
+
option_name
+
" on command line"
)
;
}
break
;
case
'h'
:
System
.
out
.
println
(
usage
)
;
throw
new
Daikon
.
TerminationMessage
(
)
;
case
'o'
:
String
inv_filename
=
g
.
getOptarg
(
)
;
if
(
inv_file
!=
null
)
{
throw
new
Daikon
.
TerminationMessage
(
"multiple serialization output files supplied on command line: "
+
inv_file
+
" "
+
inv_filename
)
;
}
inv_file
=
new
File
(
inv_filename
)
;
if
(
!
UtilMDE
.
canCreateAndWrite
(
inv_file
)
)
{
throw
new
Daikon
.
TerminationMessage
(
"Cannot write to serialization output file "
+
inv_file
)
;
}
break
;
case
'?'
:
System
.
out
.
println
(
usage
)
;
throw
new
Daikon
.
TerminationMessage
(
)
;
default
:
System
.
out
.
println
(
"getopt() returned "
+
c
)
;
break
;
}
}
for
(
int
i
=
g
.
getOptind
(
)
;
i
<
args
.
length
;
i
++
)
{
String
filename
=
args
[
i
]
;
File
file
=
null
;
if
(
!
filename
.
equals
(
"-"
)
&&
!
filename
.
equals
(
"+"
)
)
{
file
=
new
File
(
filename
)
;
if
(
!
file
.
exists
(
)
)
{
throw
new
Daikon
.
TerminationMessage
(
"File "
+
file
+
" not found."
)
;
}
filename
=
file
.
toString
(
)
;
}
if
(
filename
.
indexOf
(
".decls"
)
!=
-
1
)
{
decl_files
.
add
(
file
)
;
}
else
if
(
filename
.
indexOf
(
".dtrace"
)
!=
-
1
)
{
dtrace_files
.
add
(
filename
)
;
if
(
inv_file
==
null
)
{
String
basename
;
basename
=
new
File
(
filename
)
.
getName
(
)
;
int
base_end
=
basename
.
indexOf
(
".dtrace"
)
;
String
inv_filename
=
basename
.
substring
(
0
,
base_end
)
+
".inv.gz"
;
inv_file
=
new
File
(
inv_filename
)
;
if
(
!
UtilMDE
.
canCreateAndWrite
(
inv_file
)
)
{
throw
new
Daikon
.
TerminationMessage
(
"Cannot write to file "
+
inv_file
)
;
}
}
}
else
if
(
filename
.
indexOf
(
".spinfo"
)
!=
-
1
)
{
spinfo_files
.
add
(
file
)
;
}
else
if
(
filename
.
indexOf
(
".map"
)
!=
-
1
)
{
map_files
.
add
(
file
)
;
}
else
if
(
filename
.
equals
(
"-"
)
||
filename
.
equals
(
"+"
)
)
{
dtrace_files
.
add
(
filename
)
;
}
else
{
throw
new
Daikon
.
TerminationMessage
(
"Unrecognized file type: "
+
file
)
;
}
}
Global
.
fuzzy
.
set_rel_diff
(
Invariant
.
dkconfig_fuzzy_ratio
)
;
if
(
dkconfig_ppt_perc
!=
100
)
{
ppt_max_name
=
setup_ppt_perc
(
decl_files
,
dkconfig_ppt_perc
)
;
System
.
out
.
println
(
"Max ppt name = "
+
ppt_max_name
)
;
}
PrintInvariants
.
validateGuardNulls
(
)
;
return
new
FileOptions
(
decl_files
,
dtrace_files
,
spinfo_files
,
map_files
)
;
}
