/** 
 * This does the work of main, but it never calls System.exit, so it is appropriate to be called progrmmatically. Termination of the program with a message to the user is indicated by throwing TerminationMessage.
 * @see #main(String[])
 * @see TerminationMessage
 */
public
static
void
mainHelper
(
final
String
[
]
args
)
{
cleanup
(
)
;
FileOptions
files
=
read_options
(
args
,
usage
)
;
Set
<
File
>
decls_files
=
files
.
decls
;
Set
<
String
>
dtrace_files
=
files
.
dtrace
;
Set
<
File
>
spinfo_files
=
files
.
spinfo
;
Set
<
File
>
map_files
=
files
.
map
;
if
(
server_dir
==
null
&&
(
decls_files
.
size
(
)
==
0
)
&&
(
dtrace_files
.
size
(
)
==
0
)
)
{
System
.
out
.
println
(
"No .decls or .dtrace files specified"
)
;
throw
new
Daikon
.
TerminationMessage
(
"No .decls or .dtrace files specified"
)
;
}
if
(
Daikon
.
dkconfig_undo_opts
)
{
Daikon
.
dkconfig_disable_splitting
=
true
;
}
if
(
Daikon
.
dkconfig_quiet
)
Daikon
.
dkconfig_progress_delay
=
-
1
;
LogHelper
.
setupLogs
(
Global
.
debugAll
?
LogHelper
.
FINE
:
LogHelper
.
INFO
)
;
if
(
!
noversion_output
)
{
if
(
!
Daikon
.
dkconfig_quiet
)
System
.
out
.
println
(
release_string
)
;
}
if
(
NIS
.
dkconfig_suppression_processor
==
SuppressionProcessor
.
HYBRID
)
{
NIS
.
hybrid_method
=
true
;
}
else
{
if
(
NIS
.
dkconfig_suppression_processor
==
SuppressionProcessor
.
ANTECEDENT
)
{
NIS
.
antecedent_method
=
true
;
NIS
.
hybrid_method
=
false
;
}
else
{
assert
(
NIS
.
dkconfig_suppression_processor
==
SuppressionProcessor
.
FALSIFIED
)
:
;
NIS
.
antecedent_method
=
false
;
NIS
.
hybrid_method
=
false
;
}
}
setup_proto_invs
(
)
;
if
(
PrintInvariants
.
print_discarded_invariants
)
{
DiscReasonMap
.
initialize
(
)
;
}
fileio_progress
=
new
FileIOProgress
(
)
;
fileio_progress
.
start
(
)
;
load_spinfo_files
(
spinfo_files
)
;
all_ppts
=
load_decls_files
(
decls_files
)
;
load_map_files
(
all_ppts
,
map_files
)
;
all_ppts
.
trimToSize
(
)
;
if
(
dkconfig_calc_possible_invs
)
{
fileio_progress
.
shouldStop
=
true
;
int
total_invs
=
0
;
for
(
Iterator
<
PptTopLevel
>
itor
=
all_ppts
.
ppt_all_iterator
(
)
;
itor
.
hasNext
(
)
;
)
{
PptTopLevel
ppt
=
itor
.
next
(
)
;
System
.
out
.
printf
(
"Processing %s with %d variables"
,
ppt
.
name
(
)
,
ppt
.
var_infos
.
length
)
;
int
inv_cnt
=
0
;
if
(
ppt
.
var_infos
.
length
>
1600
)
{
System
.
out
.
println
(
"Skipping, too many variables!"
)
;
}
else
{
ppt
.
instantiate_views_and_invariants
(
)
;
inv_cnt
=
ppt
.
invariant_cnt
(
)
;
ppt
.
clean_for_merge
(
)
;
System
.
out
.
println
(
inv_cnt
+
" invariants in "
+
ppt
.
name
(
)
)
;
total_invs
=
inv_cnt
;
}
}
System
.
out
.
println
(
total_invs
+
"invariants total"
)
;
return
;
}
isInferencing
=
true
;
process_data
(
all_ppts
,
dtrace_files
)
;
isInferencing
=
false
;
if
(
Debug
.
logOn
(
)
)
Debug
.
check
(
all_ppts
,
"After process data"
)
;
if
(
suppress_redundant_invariants_with_simplify
)
{
suppressWithSimplify
(
all_ppts
)
;
}
all_ppts
.
repCheck
(
)
;
if
(
omit_from_output
)
{
processOmissions
(
all_ppts
)
;
}
if
(
inv_file
!=
null
)
{
try
{
FileIO
.
write_serialized_pptmap
(
all_ppts
,
inv_file
)
;
}
catch
(
IOException
e
)
{
throw
new
RuntimeException
(
"Error while writing .inv file "
+
"'"
+
inv_file
+
"': "
+
e
.
toString
(
)
)
;
}
}
if
(
false
)
{
for
(
PptTopLevel
ppt
:
all_ppts
.
all_ppts
(
)
)
{
System
.
out
.
printf
(
"Dumping variables for ppt %s%n"
,
ppt
.
name
(
)
)
;
for
(
VarInfo
vi
:
ppt
.
var_infos
)
{
System
.
out
.
printf
(
"  vi %s%n"
,
vi
)
;
System
.
out
.
printf
(
"    file_rep_type = %s%n"
,
vi
.
file_rep_type
)
;
System
.
out
.
printf
(
"    type = %s%n"
,
vi
.
type
)
;
}
}
}
if
(
Daikon
.
dkconfig_undo_opts
)
{
for
(
Iterator
<
PptTopLevel
>
t
=
all_ppts
.
pptIterator
(
)
;
t
.
hasNext
(
)
;
)
{
PptTopLevel
ppt
=
t
.
next
(
)
;
if
(
ppt
.
num_samples
(
)
==
0
)
{
continue
;
}
List
<
Invariant
>
invs
=
PrintInvariants
.
sort_invariant_list
(
ppt
.
invariants_vector
(
)
)
;
List
<
Invariant
>
filtered_invs
=
filter_invs
(
invs
)
;
System
.
out
.
println
(
"===================================================="
)
;
System
.
out
.
println
(
ppt
.
name
(
)
)
;
System
.
out
.
println
(
ppt
.
num_samples
(
)
)
;
for
(
Invariant
inv
:
filtered_invs
)
{
System
.
out
.
println
(
inv
.
getClass
(
)
)
;
System
.
out
.
println
(
inv
)
;
}
}
return
;
}
if
(
output_num_samples
)
{
System
.
out
.
println
(
"The --output_num_samples debugging flag is on."
)
;
System
.
out
.
println
(
"Some of the debugging output may only make sense to Daikon programmers."
)
;
}
if
(
!
PrintInvariants
.
print_discarded_invariants
)
{
PrintInvariants
.
print_invariants
(
all_ppts
)
;
}
else
{
PrintInvariants
.
print_reasons
(
all_ppts
)
;
}
if
(
output_num_samples
)
{
Global
.
output_statistics
(
)
;
}
if
(
dkconfig_print_sample_totals
)
System
.
out
.
println
(
FileIO
.
samples_processed
+
" samples processed"
)
;
if
(
debugStats
.
isLoggable
(
Level
.
FINE
)
)
{
for
(
Iterator
<
PptTopLevel
>
itor
=
all_ppts
.
ppt_all_iterator
(
)
;
itor
.
hasNext
(
)
;
)
{
PptTopLevel
ppt
=
itor
.
next
(
)
;
PrintInvariants
.
print_filter_stats
(
debugStats
,
ppt
,
all_ppts
)
;
}
}
if
(
!
Daikon
.
dkconfig_quiet
)
{
System
.
out
.
println
(
"Exiting Daikon."
)
;
}
}
