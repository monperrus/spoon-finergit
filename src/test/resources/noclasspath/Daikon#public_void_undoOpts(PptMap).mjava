/** 
 * Undoes the invariants suppressed for the dynamic constant, suppression and equality set optimizations (should yield the same invariants as the simple incremental algorithm
 */
public
static
void
undoOpts
(
PptMap
all_ppts
)
{
Iterator
<
PptTopLevel
>
suppress_it
=
all_ppts
.
ppt_all_iterator
(
)
;
while
(
suppress_it
.
hasNext
(
)
)
{
PptTopLevel
p
=
suppress_it
.
next
(
)
;
NIS
.
create_suppressed_invs
(
p
)
;
}
Iterator
<
PptTopLevel
>
equality_it
=
all_ppts
.
ppt_all_iterator
(
)
;
while
(
equality_it
.
hasNext
(
)
)
{
PptTopLevel
ppt
=
equality_it
.
next
(
)
;
PptSliceEquality
sliceEquality
=
ppt
.
equality_view
;
if
(
sliceEquality
==
null
)
{
continue
;
}
List
<
Equality
>
allNewInvs
=
new
ArrayList
<
Equality
>
(
)
;
for
(
Invariant
eq_as_inv
:
sliceEquality
.
invs
)
{
Equality
eq
=
(
Equality
)
eq_as_inv
;
VarInfo
leader
=
eq
.
leader
(
)
;
List
<
VarInfo
>
vars
=
new
ArrayList
<
VarInfo
>
(
)
;
for
(
VarInfo
var
:
eq
.
getVars
(
)
)
{
if
(
!
var
.
equals
(
leader
)
)
{
vars
.
add
(
var
)
;
}
}
if
(
vars
.
size
(
)
>
0
)
{
List
<
Equality
>
newInvs
=
sliceEquality
.
createEqualityInvs
(
vars
,
eq
)
;
sliceEquality
.
copyInvsFromLeader
(
leader
,
vars
)
;
allNewInvs
.
addAll
(
newInvs
)
;
}
}
sliceEquality
.
invs
.
addAll
(
allNewInvs
)
;
}
}
