/** 
 * Read a variable name, type, and comparability; construct a VarInfo. Return null after reading the last variable in this program point declaration.
 */
private
static
VarInfo
read_VarInfo
(
ParseState
state
,
String
ppt_name
)
throws
IOException
{
LineNumberReader
file
=
state
.
reader
;
int
varcomp_format
=
state
.
varcomp_format
;
File
filename
=
state
.
file
;
String
line
=
file
.
readLine
(
)
;
if
(
(
line
==
null
)
||
(
line
.
equals
(
""
)
)
)
return
null
;
String
varname
=
line
;
String
proglang_type_string_and_aux
=
file
.
readLine
(
)
;
String
file_rep_type_string
=
file
.
readLine
(
)
;
String
comparability_string
=
file
.
readLine
(
)
;
if
(
(
proglang_type_string_and_aux
==
null
)
||
(
file_rep_type_string
==
null
)
||
(
comparability_string
==
null
)
)
throw
new
Daikon
.
TerminationMessage
(
"End of file "
+
filename
+
" while reading variable "
+
varname
+
" in declaration of program point "
+
ppt_name
)
;
int
equals_index
=
file_rep_type_string
.
indexOf
(
" = "
)
;
String
static_constant_value_string
=
null
;
Object
static_constant_value
=
null
;
boolean
is_static_constant
=
false
;
if
(
equals_index
!=
-
1
)
{
is_static_constant
=
true
;
static_constant_value_string
=
file_rep_type_string
.
substring
(
equals_index
+
3
)
;
file_rep_type_string
=
file_rep_type_string
.
substring
(
0
,
equals_index
)
;
}
if
(
"String"
.
equals
(
file_rep_type_string
)
)
{
file_rep_type_string
=
"java.lang.String"
;
if
(
!
seen_string_rep_type
)
{
seen_string_rep_type
=
true
;
System
.
err
.
println
(
"Warning: Malformed trace file.  Representation type 'String' should be "
+
"'java.lang.String' instead on line "
+
(
file
.
getLineNumber
(
)
-
1
)
+
" of "
+
filename
)
;
}
}
else
if
(
"String[]"
.
equals
(
file_rep_type_string
)
)
{
throw
new
Daikon
.
TerminationMessage
(
"Representation type 'String[]' should be "
+
"'java.lang.String[]' instead for variable "
+
varname
,
file
,
filename
)
;
}
int
hash_position
=
proglang_type_string_and_aux
.
indexOf
(
'#'
)
;
String
aux_string
=
""
;
if
(
hash_position
==
-
1
)
{
hash_position
=
proglang_type_string_and_aux
.
length
(
)
;
}
else
{
aux_string
=
proglang_type_string_and_aux
.
substring
(
hash_position
+
1
,
proglang_type_string_and_aux
.
length
(
)
)
;
}
String
proglang_type_string
=
proglang_type_string_and_aux
.
substring
(
0
,
hash_position
)
.
trim
(
)
;
ProglangType
prog_type
;
ProglangType
file_rep_type
;
ProglangType
rep_type
;
VarInfoAux
aux
;
try
{
prog_type
=
ProglangType
.
parse
(
proglang_type_string
)
;
file_rep_type
=
ProglangType
.
rep_parse
(
file_rep_type_string
)
;
rep_type
=
file_rep_type
.
fileTypeToRepType
(
)
;
aux
=
VarInfoAux
.
parse
(
aux_string
)
;
}
catch
(
IOException
e
)
{
throw
new
Daikon
.
TerminationMessage
(
file
,
filename
,
e
)
;
}
if
(
static_constant_value_string
!=
null
)
{
static_constant_value
=
rep_type
.
parse_value
(
static_constant_value_string
)
;
Assert
.
assertTrue
(
static_constant_value
!=
null
)
;
}
VarComparability
comparability
=
null
;
try
{
comparability
=
VarComparability
.
parse
(
varcomp_format
,
comparability_string
,
prog_type
)
;
}
catch
(
Exception
e
)
{
throw
new
Daikon
.
TerminationMessage
(
String
.
format
(
"Error parsing comparability (%s) at line %d "
+
"in file %s"
,
e
,
file
.
getLineNumber
(
)
,
filename
)
)
;
}
if
(
!
VarInfo
.
legalFileRepType
(
file_rep_type
)
)
{
throw
new
Daikon
.
TerminationMessage
(
"Unsupported representation type "
+
file_rep_type
.
format
(
)
+
" (parsed as "
+
rep_type
+
")"
+
" for variable "
+
varname
,
file
,
filename
)
;
}
if
(
!
VarInfo
.
legalRepType
(
rep_type
)
)
{
throw
new
Daikon
.
TerminationMessage
(
"Unsupported (converted) representation type "
+
file_rep_type
.
format
(
)
+
" for variable "
+
varname
,
file
,
filename
)
;
}
return
new
VarInfo
(
varname
,
prog_type
,
file_rep_type
,
comparability
,
is_static_constant
,
static_constant_value
,
aux
)
;
}
