/** 
 * If this is an function entry ppt, stores the values of all of the variables away for use at the exit.  If this is an exit, finds the values at enter and adds them as the value sof the orig variables. Normally returns false.  Returns true if this is an exit without a matching enter.  See dkconfig_ignore_missing_enter for more info. If true is returned, this ppt should be ignored by the caller
 */
public
static
boolean
add_orig_variables
(
PptTopLevel
ppt
,
Object
[
]
vals
,
int
[
]
mods
,
Integer
nonce
)
{
VarInfo
[
]
vis
=
ppt
.
var_infos
;
String
fn_name
=
ppt
.
ppt_name
.
getNameWithoutPoint
(
)
;
String
ppt_name
=
ppt
.
name
(
)
;
if
(
ppt_name
.
endsWith
(
enter_tag
)
)
{
Invocation
invok
=
new
Invocation
(
ppt
,
vals
,
mods
)
;
if
(
nonce
==
null
)
{
call_stack
.
push
(
invok
)
;
}
else
{
call_hashmap
.
put
(
nonce
,
invok
)
;
}
return
false
;
}
if
(
ppt
.
ppt_name
.
isExitPoint
(
)
||
ppt
.
ppt_name
.
isThrowsPoint
(
)
)
{
Invocation
invoc
;
{
if
(
nonce
==
null
)
{
if
(
call_stack
.
empty
(
)
)
{
throw
new
Error
(
"Function exit without corresponding entry: "
+
ppt
.
name
(
)
)
;
}
invoc
=
call_stack
.
pop
(
)
;
while
(
invoc
.
ppt
.
ppt_name
.
getNameWithoutPoint
(
)
!=
fn_name
)
{
System
.
err
.
println
(
"Exceptional exit from function "
+
fn_name
+
", expected to first exit from "
+
invoc
.
ppt
.
ppt_name
.
getNameWithoutPoint
(
)
+
(
(
data_trace_state
.
filename
==
null
)
?
""
:
"; at "
+
data_trace_state
.
filename
+
" line "
+
data_trace_state
.
reader
.
getLineNumber
(
)
)
)
;
invoc
=
call_stack
.
pop
(
)
;
}
}
else
{
invoc
=
call_hashmap
.
get
(
nonce
)
;
if
(
dkconfig_ignore_missing_enter
&&
(
invoc
==
null
)
)
{
return
true
;
}
else
if
(
invoc
==
null
)
{
throw
new
Error
(
"Didn't find call with nonce "
+
nonce
+
" to match "
+
ppt
.
name
(
)
+
" ending at "
+
data_trace_state
.
filename
+
" line "
+
data_trace_state
.
reader
.
getLineNumber
(
)
)
;
}
invoc
=
call_hashmap
.
get
(
nonce
)
;
call_hashmap
.
remove
(
nonce
)
;
}
}
Assert
.
assertTrue
(
invoc
!=
null
)
;
int
vi_index
=
0
;
for
(
int
val_index
=
0
;
val_index
<
ppt
.
num_orig_vars
;
val_index
++
)
{
VarInfo
vi
=
vis
[
ppt
.
num_tracevars
+
ppt
.
num_static_constant_vars
+
val_index
]
;
assert
(
!
vi
.
is_static_constant
)
:
"orig constant "
+
vi
;
while
(
invoc
.
ppt
.
var_infos
[
vi_index
]
.
is_static_constant
)
vi_index
++
;
vals
[
ppt
.
num_tracevars
+
val_index
]
=
invoc
.
vals
[
val_index
]
;
int
mod
=
invoc
.
mods
[
val_index
]
;
mods
[
ppt
.
num_tracevars
+
val_index
]
=
mod
;
if
(
ValueTuple
.
modIsMissingNonsensical
(
mod
)
)
{
if
(
debug_missing
&&
!
vi
.
canBeMissing
)
{
System
.
out
.
printf
(
"add_orig: var %s missing[%d/%d]%n"
,
vi
,
val_index
,
vi_index
)
;
}
vi
.
canBeMissing
=
true
;
assert
invoc
.
vals
[
val_index
]
==
null
:
;
assert
vi
.
name
(
)
==
invoc
.
ppt
.
var_infos
[
vi_index
]
.
prestate_name
(
)
:
vi
.
name
(
)
+
" != "
+
invoc
.
ppt
.
var_infos
[
vi_index
]
;
assert
invoc
.
ppt
.
var_infos
[
vi_index
]
.
canBeMissing
:
invoc
.
ppt
.
var_infos
[
vi_index
]
;
}
vi_index
++
;
}
}
return
false
;
}
