/** 
 * Add orig() and derived variables to vt (by side effect), then supply it to the program point for flowing.
 * @param vt trace data only; modified by side effect to add derived vars
 */
public
static
void
process_sample
(
PptMap
all_ppts
,
PptTopLevel
ppt
,
ValueTuple
vt
,
Integer
nonce
)
{
boolean
ignore
=
add_orig_variables
(
ppt
,
vt
.
vals
,
vt
.
mods
,
nonce
)
;
if
(
ignore
)
return
;
if
(
Daikon
.
use_dataflow_hierarchy
)
{
if
(
ppt
.
ppt_name
.
isEnterPoint
(
)
||
ppt
.
ppt_name
.
isThrowsPoint
(
)
||
ppt
.
ppt_name
.
isObjectInstanceSynthetic
(
)
||
ppt
.
ppt_name
.
isClassStaticSynthetic
(
)
||
ppt
.
ppt_name
.
isGlobalPoint
(
)
)
{
return
;
}
if
(
ppt
.
ppt_name
.
isExitPoint
(
)
&&
ppt
.
ppt_name
.
isCombinedExitPoint
(
)
)
{
throw
new
RuntimeException
(
"Bad program point name "
+
ppt
.
name
+
" is a combined exit point name"
)
;
}
}
add_derived_variables
(
ppt
,
vt
.
vals
,
vt
.
mods
)
;
vt
=
new
ValueTuple
(
vt
.
vals
,
vt
.
mods
)
;
if
(
debugRead
.
isLoggable
(
Level
.
FINE
)
)
{
debugRead
.
fine
(
"Adding ValueTuple to "
+
ppt
.
name
(
)
)
;
debugRead
.
fine
(
"  length is "
+
vt
.
vals
.
length
)
;
}
if
(
dkconfig_read_samples_only
)
{
return
;
}
ppt
.
add_bottom_up
(
vt
,
1
)
;
if
(
debugVars
.
isLoggable
(
Level
.
FINE
)
)
debugVars
.
fine
(
ppt
.
name
(
)
+
" vars: "
+
Debug
.
int_vars
(
ppt
,
vt
)
)
;
if
(
Global
.
debugPrintDtrace
)
{
Global
.
dtraceWriter
.
close
(
)
;
}
}
