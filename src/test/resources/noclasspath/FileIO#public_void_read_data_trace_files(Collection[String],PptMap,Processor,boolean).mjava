/** 
 * Read data from .dtrace files. Calls @link{read_data_trace_file(File,PptMap,Pattern,false)} for each element of filenames.
 * @param ppts_are_new - true if declarations of ppts read from the datatrace file are new (and thus are not in all_ppts) false if the ppts may already be there.
 */
public
static
void
read_data_trace_files
(
Collection
<
String
>
files
,
PptMap
all_ppts
,
Processor
processor
,
boolean
ppts_are_new
)
throws
IOException
{
for
(
String
filename
:
files
)
{
try
{
read_data_trace_file
(
filename
,
all_ppts
,
processor
,
false
,
ppts_are_new
)
;
}
catch
(
IOException
e
)
{
if
(
e
.
getMessage
(
)
.
equals
(
"Corrupt GZIP trailer"
)
)
{
System
.
out
.
println
(
filename
+
" has a corrupt gzip trailer.  "
+
"All possible data was recovered."
)
;
}
else
{
throw
e
;
}
}
}
if
(
Daikon
.
server_dir
!=
null
)
{
while
(
true
)
{
String
[
]
dir_files
=
Daikon
.
server_dir
.
list
(
)
;
Arrays
.
sort
(
dir_files
)
;
boolean
hasEnd
=
false
;
for
(
String
f
:
dir_files
)
{
if
(
f
.
endsWith
(
".end"
)
)
hasEnd
=
true
;
if
(
f
.
endsWith
(
".end"
)
||
f
.
endsWith
(
".start"
)
)
continue
;
if
(
files
.
contains
(
f
)
)
continue
;
files
.
add
(
f
)
;
System
.
out
.
println
(
"Reading "
+
f
)
;
read_data_trace_file
(
new
File
(
Daikon
.
server_dir
,
f
)
.
toString
(
)
,
all_ppts
,
processor
,
false
,
ppts_are_new
)
;
}
if
(
hasEnd
)
break
;
try
{
Thread
.
sleep
(
1000
)
;
}
catch
(
java
.
lang
.
InterruptedException
e
)
{
}
}
}
process_unmatched_procedure_entries
(
)
;
warn_if_hierarchy_mismatch
(
all_ppts
)
;
}
