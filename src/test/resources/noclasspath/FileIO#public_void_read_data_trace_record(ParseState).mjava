public
static
void
read_data_trace_record
(
ParseState
state
)
throws
IOException
{
LineNumberReader
reader
=
state
.
reader
;
for
(
String
line_
=
reader
.
readLine
(
)
;
line_
!=
null
;
line_
=
reader
.
readLine
(
)
)
{
if
(
line_
.
equals
(
""
)
||
isComment
(
line_
)
)
{
continue
;
}
state
.
lineNum
=
reader
.
getLineNumber
(
)
;
if
(
(
dkconfig_max_line_number
>
0
)
&&
(
state
.
lineNum
>
dkconfig_max_line_number
)
)
{
state
.
status
=
ParseStatus
.
TRUNCATED
;
return
;
}
String
line
=
line_
.
intern
(
)
;
if
(
is_declaration_header
(
line
)
)
{
if
(
new_decl_format
)
state
.
ppt
=
read_ppt_decl
(
state
,
line
)
;
else
state
.
ppt
=
read_declaration
(
state
)
;
if
(
state
.
ppt
!=
null
)
{
if
(
!
state
.
all_ppts
.
containsName
(
state
.
ppt
.
name
(
)
)
)
{
state
.
all_ppts
.
add
(
state
.
ppt
)
;
Daikon
.
init_ppt
(
state
.
ppt
,
state
.
all_ppts
)
;
}
}
state
.
status
=
ParseStatus
.
DECL
;
return
;
}
if
(
line
.
equals
(
"VarComparability"
)
||
line
.
startsWith
(
"var-comparability"
)
)
{
state
.
varcomp_format
=
read_var_comparability
(
state
,
line
)
;
state
.
status
=
ParseStatus
.
COMPARABILITY
;
return
;
}
if
(
line
.
startsWith
(
"input-language"
)
)
{
String
input_language
=
read_input_language
(
state
,
line
)
;
return
;
}
if
(
line
.
startsWith
(
"decl-version"
)
)
{
read_decl_version
(
state
,
line
)
;
return
;
}
if
(
line
.
equals
(
"ListImplementors"
)
)
{
read_list_implementors
(
reader
,
state
.
file
)
;
state
.
status
=
ParseStatus
.
LIST
;
return
;
}
String
ppt_name
=
line
;
if
(
new_decl_format
)
ppt_name
=
unescape_decl
(
line
)
.
intern
(
)
;
if
(
!
ppt_included
(
ppt_name
)
)
{
while
(
(
line
!=
null
)
&&
!
line
.
equals
(
""
)
)
line
=
reader
.
readLine
(
)
;
continue
;
}
if
(
state
.
is_decl_file
)
{
if
(
debugRead
.
isLoggable
(
Level
.
FINE
)
)
debugRead
.
fine
(
"Skipping paragraph starting at line "
+
reader
.
getLineNumber
(
)
+
" of file "
+
state
.
filename
+
": "
+
line
)
;
while
(
(
line
!=
null
)
&&
(
!
line
.
equals
(
""
)
)
&&
(
!
isComment
(
line
)
)
)
{
System
.
out
.
println
(
"Unrecognized paragraph contains line = `"
+
line
+
"'"
)
;
System
.
out
.
println
(
" line: null="
+
false
+
" empty="
+
(
line
.
equals
(
""
)
)
+
" comment="
+
(
isComment
(
line
)
)
)
;
line
=
reader
.
readLine
(
)
;
}
continue
;
}
try
{
new
PptName
(
ppt_name
)
;
}
catch
(
Throwable
t
)
{
if
(
t
instanceof
Daikon
.
TerminationMessage
)
throw
new
Daikon
.
TerminationMessage
(
"%s: in %s line %d"
,
t
.
getMessage
(
)
,
state
.
filename
,
reader
.
getLineNumber
(
)
)
;
else
throw
new
Daikon
.
TerminationMessage
(
String
.
format
(
"Illegal program point name '%s' (%s) in %s line %d"
,
ppt_name
,
t
.
getMessage
(
)
,
state
.
filename
,
reader
.
getLineNumber
(
)
)
)
;
}
if
(
state
.
all_ppts
.
size
(
)
==
0
)
{
throw
new
Daikon
.
TerminationMessage
(
"No declarations were provided before the first sample.  Perhaps you did not supply the proper .decls file to Daikon.  (Or, there could be a bug in the front end that created the .dtrace file "
+
state
.
filename
+
".)"
)
;
}
PptTopLevel
ppt
=
state
.
all_ppts
.
get
(
ppt_name
)
;
if
(
ppt
==
null
)
{
throw
new
Daikon
.
TerminationMessage
(
"No declaration was provided for program point "
+
ppt_name
+
" which appears in dtrace file "
+
state
.
filename
+
" at line "
+
reader
.
getLineNumber
(
)
)
;
}
VarInfo
[
]
vis
=
ppt
.
var_infos
;
int
num_tracevars
=
ppt
.
num_tracevars
;
int
vals_array_size
=
ppt
.
var_infos
.
length
-
ppt
.
num_static_constant_vars
;
Integer
nonce
=
null
;
reader
.
mark
(
100
)
;
String
nonce_name_maybe
;
try
{
nonce_name_maybe
=
reader
.
readLine
(
)
;
}
catch
(
Exception
e
)
{
nonce_name_maybe
=
null
;
}
reader
.
reset
(
)
;
if
(
"this_invocation_nonce"
.
equals
(
nonce_name_maybe
)
)
{
String
nonce_name
=
reader
.
readLine
(
)
;
Assert
.
assertTrue
(
nonce_name
!=
null
&&
nonce_name
.
equals
(
"this_invocation_nonce"
)
)
;
String
nonce_number
=
reader
.
readLine
(
)
;
if
(
nonce_number
==
null
)
{
throw
new
Daikon
.
TerminationMessage
(
"File ended while trying to read nonce"
,
reader
,
state
.
file
)
;
}
nonce
=
new
Integer
(
nonce_number
)
;
if
(
Global
.
debugPrintDtrace
)
{
to_write_nonce
=
true
;
nonce_value
=
nonce
.
toString
(
)
;
nonce_string
=
nonce_name_maybe
;
}
}
Object
[
]
vals
=
new
Object
[
]
;
int
[
]
mods
=
new
int
[
]
;
try
{
read_vals_and_mods_from_trace_file
(
reader
,
state
.
filename
,
ppt
,
vals
,
mods
)
;
}
catch
(
IOException
e
)
{
String
nextLine
=
reader
.
readLine
(
)
;
if
(
(
e
instanceof
EOFException
)
||
(
nextLine
==
null
)
)
{
System
.
out
.
println
(
)
;
System
.
out
.
println
(
"WARNING: Unexpected EOF while processing "
+
"trace file - last record of trace file ignored"
)
;
state
.
status
=
ParseStatus
.
EOF
;
return
;
}
else
if
(
dkconfig_continue_after_file_exception
)
{
System
.
out
.
println
(
)
;
System
.
out
.
println
(
"WARNING: IOException while processing "
+
"trace file - record ignored"
)
;
System
.
out
.
print
(
"Ignored backtrace:"
)
;
e
.
printStackTrace
(
System
.
out
)
;
System
.
out
.
println
(
)
;
while
(
nextLine
!=
null
&&
!
nextLine
.
equals
(
""
)
)
{
nextLine
=
reader
.
readLine
(
)
;
}
continue
;
}
else
{
throw
e
;
}
}
state
.
ppt
=
ppt
;
state
.
nonce
=
nonce
;
state
.
vt
=
ValueTuple
.
makeUninterned
(
vals
,
mods
)
;
state
.
status
=
ParseStatus
.
SAMPLE
;
return
;
}
state
.
status
=
ParseStatus
.
EOF
;
return
;
}
