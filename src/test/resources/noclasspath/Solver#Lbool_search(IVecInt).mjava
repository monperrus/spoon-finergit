Lbool
search
(
IVecInt
assumps
)
{
assert
this
.
rootLevel
==
decisionLevel
(
)
:
;
this
.
stats
.
starts
++
;
int
backjumpLevel
;
this
.
order
.
setVarDecay
(
1
/
this
.
params
.
getVarDecay
(
)
)
;
this
.
claDecay
=
1
/
this
.
params
.
getClaDecay
(
)
;
do
{
this
.
slistener
.
beginLoop
(
)
;
Constr
confl
=
propagate
(
)
;
assert
this
.
trail
.
size
(
)
==
this
.
qhead
:
;
if
(
confl
==
null
)
{
if
(
decisionLevel
(
)
==
0
&&
this
.
isDBSimplificationAllowed
)
{
this
.
stats
.
rootSimplifications
++
;
boolean
ret
=
simplifyDB
(
)
;
assert
ret
:
;
}
assert
nAssigns
(
)
<=
this
.
voc
.
realnVars
(
)
:
;
if
(
nAssigns
(
)
==
this
.
voc
.
realnVars
(
)
)
{
modelFound
(
)
;
this
.
slistener
.
solutionFound
(
(
this
.
fullmodel
!=
null
)
?
this
.
fullmodel
:
this
.
model
,
this
)
;
if
(
this
.
sharedConflict
==
null
)
{
cancelUntil
(
this
.
rootLevel
)
;
return
Lbool
.
TRUE
;
}
else
{
confl
=
this
.
sharedConflict
;
}
}
else
{
if
(
this
.
restarter
.
shouldRestart
(
)
)
{
cancelUntil
(
this
.
rootLevel
)
;
return
Lbool
.
UNDEFINED
;
}
if
(
this
.
needToReduceDB
)
{
reduceDB
(
)
;
this
.
needToReduceDB
=
false
;
}
if
(
this
.
sharedConflict
==
null
)
{
this
.
stats
.
decisions
++
;
int
p
=
this
.
order
.
select
(
)
;
if
(
p
==
ILits
.
UNDEFINED
)
{
confl
=
preventTheSameDecisionsToBeMade
(
)
;
this
.
lastConflictMeansUnsat
=
false
;
}
else
{
assert
p
>
1
:
;
this
.
slistener
.
assuming
(
toDimacs
(
p
)
)
;
boolean
ret
=
assume
(
p
)
;
assert
ret
:
;
}
}
else
{
confl
=
this
.
sharedConflict
;
}
}
}
if
(
confl
!=
null
)
{
this
.
stats
.
conflicts
++
;
this
.
slistener
.
conflictFound
(
confl
,
decisionLevel
(
)
,
this
.
trail
.
size
(
)
)
;
this
.
conflictCount
.
newConflict
(
)
;
if
(
decisionLevel
(
)
==
this
.
rootLevel
)
{
if
(
this
.
lastConflictMeansUnsat
)
{
this
.
unsatExplanationInTermsOfAssumptions
=
analyzeFinalConflictInTermsOfAssumptions
(
confl
,
assumps
,
ILits
.
UNDEFINED
)
;
return
Lbool
.
FALSE
;
}
return
Lbool
.
UNDEFINED
;
}
int
conflictTrailLevel
=
this
.
trail
.
size
(
)
;
try
{
analyze
(
confl
,
this
.
analysisResult
)
;
}
catch
(
TimeoutException
e
)
{
return
Lbool
.
UNDEFINED
;
}
assert
this
.
analysisResult
.
backtrackLevel
<
decisionLevel
(
)
:
;
backjumpLevel
=
Math
.
max
(
this
.
analysisResult
.
backtrackLevel
,
this
.
rootLevel
)
;
this
.
slistener
.
backjump
(
backjumpLevel
)
;
cancelUntil
(
backjumpLevel
)
;
if
(
backjumpLevel
==
this
.
rootLevel
)
{
this
.
restarter
.
onBackjumpToRootLevel
(
)
;
}
if
(
confl
==
this
.
sharedConflict
)
{
this
.
sharedConflict
.
assertConstraintIfNeeded
(
this
)
;
this
.
sharedConflict
=
null
;
}
assert
decisionLevel
(
)
>=
this
.
rootLevel
&&
decisionLevel
(
)
>=
this
.
analysisResult
.
backtrackLevel
:
;
if
(
this
.
analysisResult
.
reason
==
null
)
{
return
Lbool
.
FALSE
;
}
record
(
this
.
analysisResult
.
reason
)
;
this
.
restarter
.
newLearnedClause
(
this
.
analysisResult
.
reason
,
conflictTrailLevel
)
;
this
.
analysisResult
.
reason
=
null
;
decayActivities
(
)
;
}
}
while
(
this
.
undertimeout
)
;
return
Lbool
.
UNDEFINED
;
}
