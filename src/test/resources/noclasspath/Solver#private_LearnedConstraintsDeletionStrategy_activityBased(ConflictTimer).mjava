private
LearnedConstraintsDeletionStrategy
activityBased
(
final
ConflictTimer
timer
)
{
return
new
LearnedConstraintsDeletionStrategy
(
)
{
private
static
final
long
serialVersionUID
=
1L
;
private
final
ConflictTimer
freeMem
=
timer
;
public
void
reduce
(
IVec
<
Constr
>
learnedConstrs
)
{
sortOnActivity
(
)
;
int
i
,
j
;
for
(
i
=
j
=
0
;
i
<
this
.
learnts
.
size
(
)
/
2
;
i
++
)
{
Constr
c
=
this
.
learnts
.
get
(
i
)
;
if
(
c
.
locked
(
)
||
c
.
size
(
)
==
2
)
{
this
.
learnts
.
set
(
j
++
,
this
.
learnts
.
get
(
i
)
)
;
}
else
{
c
.
remove
(
this
)
;
}
}
for
(
;
i
<
this
.
learnts
.
size
(
)
;
i
++
)
{
this
.
learnts
.
set
(
j
++
,
this
.
learnts
.
get
(
i
)
)
;
}
if
(
this
.
verbose
)
{
this
.
out
.
log
(
getLogPrefix
(
)
+
"cleaning "
+
(
this
.
learnts
.
size
(
)
-
j
)
+
" clauses out of "
+
this
.
learnts
.
size
(
)
)
;
}
this
.
learnts
.
shrinkTo
(
j
)
;
}
public
ConflictTimer
getTimer
(
)
{
return
this
.
freeMem
;
}
@Override
public
String
toString
(
)
{
return
"Memory based learned constraints deletion strategy"
;
}
public
void
init
(
)
{
}
public
void
onClauseLearning
(
Constr
constr
)
{
}
public
void
onConflictAnalysis
(
Constr
reason
)
{
if
(
reason
.
learnt
(
)
)
{
claBumpActivity
(
reason
)
;
}
}
public
void
onPropagation
(
Constr
from
)
{
}
}
;
}
