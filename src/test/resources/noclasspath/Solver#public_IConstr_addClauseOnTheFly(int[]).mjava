public
IConstr
addClauseOnTheFly
(
int
[
]
literals
)
{
List
<
Integer
>
lliterals
=
new
ArrayList
<
Integer
>
(
)
;
for
(
Integer
d
:
literals
)
{
lliterals
.
add
(
d
)
;
}
Collections
.
sort
(
lliterals
,
dimacsLevel
)
;
IVecInt
clause
=
new
VecInt
(
literals
.
length
)
;
for
(
int
d
:
lliterals
)
{
clause
.
push
(
LiteralsUtils
.
toInternal
(
d
)
)
;
}
this
.
sharedConflict
=
this
.
dsfactory
.
createUnregisteredClause
(
clause
)
;
this
.
sharedConflict
.
register
(
)
;
addConstr
(
this
.
sharedConflict
)
;
IVecInt
reason
=
new
VecInt
(
)
;
this
.
sharedConflict
.
calcReasonOnTheFly
(
ILits
.
UNDEFINED
,
trail
,
reason
)
;
Set
<
Integer
>
subset
=
fromLastDecisionLevel
(
reason
)
;
while
(
!
trail
.
isEmpty
(
)
&&
!
subset
.
contains
(
trail
.
last
(
)
)
)
{
undoOne
(
)
;
if
(
!
trailLim
.
isEmpty
(
)
&&
trailLim
.
last
(
)
==
trail
.
size
(
)
)
{
trailLim
.
pop
(
)
;
}
}
return
this
.
sharedConflict
;
}
