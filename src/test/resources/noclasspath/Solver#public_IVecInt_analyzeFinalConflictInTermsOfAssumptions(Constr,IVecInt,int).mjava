/** 
 * Derive a subset of the assumptions causing the inconistency.
 * @param confl the last conflict of the search, occuring at root level.
 * @param assumps the set of assumption literals
 * @param conflictingLiteral the literal detected conflicting while propagating assumptions.
 * @return a subset of assumps causing the inconsistency.
 * @since 2.2
 */
public
IVecInt
analyzeFinalConflictInTermsOfAssumptions
(
Constr
confl
,
IVecInt
assumps
,
int
conflictingLiteral
)
{
if
(
assumps
.
size
(
)
==
0
)
{
return
null
;
}
while
(
!
this
.
trailLim
.
isEmpty
(
)
&&
this
.
trailLim
.
last
(
)
==
this
.
trail
.
size
(
)
)
{
this
.
trailLim
.
pop
(
)
;
}
final
boolean
[
]
seen
=
this
.
mseen
;
final
IVecInt
outLearnt
=
this
.
moutLearnt
;
final
IVecInt
preason
=
this
.
mpreason
;
outLearnt
.
clear
(
)
;
if
(
this
.
trailLim
.
size
(
)
==
0
)
{
return
outLearnt
;
}
assert
outLearnt
.
size
(
)
==
0
:
;
for
(
int
i
=
0
;
i
<
seen
.
length
;
i
++
)
{
seen
[
i
]
=
false
;
}
if
(
confl
==
null
)
{
seen
[
conflictingLiteral
>>
1
]
=
true
;
}
int
p
=
ILits
.
UNDEFINED
;
while
(
confl
==
null
&&
this
.
trail
.
size
(
)
>
0
&&
this
.
trailLim
.
size
(
)
>
0
)
{
p
=
this
.
trail
.
last
(
)
;
confl
=
this
.
voc
.
getReason
(
p
)
;
undoOne
(
)
;
if
(
confl
==
null
&&
p
==
(
conflictingLiteral
^
1
)
)
{
outLearnt
.
push
(
toDimacs
(
p
)
)
;
}
if
(
this
.
trail
.
size
(
)
<=
this
.
trailLim
.
last
(
)
)
{
this
.
trailLim
.
pop
(
)
;
}
}
if
(
confl
==
null
)
{
return
outLearnt
;
}
do
{
preason
.
clear
(
)
;
confl
.
calcReason
(
p
,
preason
)
;
for
(
int
j
=
0
;
j
<
preason
.
size
(
)
;
j
++
)
{
int
q
=
preason
.
get
(
j
)
;
if
(
!
seen
[
q
>>
1
]
)
{
seen
[
q
>>
1
]
=
true
;
if
(
this
.
voc
.
getReason
(
q
)
==
null
&&
this
.
voc
.
getLevel
(
q
)
>
0
)
{
assert
assumps
.
contains
(
toDimacs
(
q
)
)
:
;
outLearnt
.
push
(
toDimacs
(
q
)
)
;
}
}
}
do
{
p
=
this
.
trail
.
last
(
)
;
confl
=
this
.
voc
.
getReason
(
p
)
;
undoOne
(
)
;
if
(
decisionLevel
(
)
>
0
&&
this
.
trail
.
size
(
)
<=
this
.
trailLim
.
last
(
)
)
{
this
.
trailLim
.
pop
(
)
;
}
}
while
(
this
.
trail
.
size
(
)
>
0
&&
decisionLevel
(
)
>
0
&&
(
!
seen
[
p
>>
1
]
||
confl
==
null
)
)
;
}
while
(
decisionLevel
(
)
>
0
)
;
return
outLearnt
;
}
