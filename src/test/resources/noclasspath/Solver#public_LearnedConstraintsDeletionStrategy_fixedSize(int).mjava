public
final
LearnedConstraintsDeletionStrategy
fixedSize
(
final
int
maxsize
)
{
return
new
LearnedConstraintsDeletionStrategy
(
)
{
private
static
final
long
serialVersionUID
=
1L
;
private
final
ConflictTimer
aTimer
=
new
ConflictTimerAdapter
(
maxsize
)
{
private
static
final
long
serialVersionUID
=
1L
;
@Override
public
void
run
(
)
{
this
.
needToReduceDB
=
true
;
}
}
;
public
void
reduce
(
IVec
<
Constr
>
learnedConstrs
)
{
int
i
,
j
,
k
;
for
(
i
=
j
=
k
=
0
;
i
<
this
.
learnts
.
size
(
)
&&
this
.
learnts
.
size
(
)
-
k
>
maxsize
;
i
++
)
{
Constr
c
=
this
.
learnts
.
get
(
i
)
;
if
(
c
.
locked
(
)
||
c
.
size
(
)
==
2
)
{
this
.
learnts
.
set
(
j
++
,
this
.
learnts
.
get
(
i
)
)
;
}
else
{
c
.
remove
(
this
)
;
k
++
;
}
}
for
(
;
i
<
this
.
learnts
.
size
(
)
;
i
++
)
{
this
.
learnts
.
set
(
j
++
,
this
.
learnts
.
get
(
i
)
)
;
}
if
(
this
.
verbose
)
{
this
.
out
.
log
(
getLogPrefix
(
)
+
"cleaning "
+
(
this
.
learnts
.
size
(
)
-
j
)
+
" clauses out of "
+
this
.
learnts
.
size
(
)
)
;
}
this
.
learnts
.
shrinkTo
(
j
)
;
}
public
void
onConflictAnalysis
(
Constr
reason
)
{
}
public
void
onClauseLearning
(
Constr
outLearnt
)
{
}
@Override
public
String
toString
(
)
{
return
"Fixed size ("
+
maxsize
+
") learned constraints deletion strategy"
;
}
public
void
init
(
)
{
}
public
ConflictTimer
getTimer
(
)
{
return
this
.
aTimer
;
}
public
void
onPropagation
(
Constr
from
)
{
}
}
;
}
