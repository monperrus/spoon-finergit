public
boolean
isSatisfiable
(
IVecInt
assumps
,
boolean
global
)
throws
TimeoutException
{
Lbool
status
=
Lbool
.
UNDEFINED
;
boolean
alreadylaunched
=
this
.
conflictCount
!=
null
;
final
int
howmany
=
this
.
voc
.
nVars
(
)
;
if
(
this
.
mseen
.
length
<=
howmany
)
{
this
.
mseen
=
new
boolean
[
]
;
}
this
.
trail
.
ensure
(
howmany
)
;
this
.
trailLim
.
ensure
(
howmany
)
;
this
.
learnedLiterals
.
ensure
(
howmany
)
;
this
.
decisions
.
clear
(
)
;
this
.
implied
.
clear
(
)
;
this
.
slistener
.
init
(
this
)
;
this
.
slistener
.
start
(
)
;
this
.
model
=
null
;
this
.
userbooleanmodel
=
null
;
this
.
prime
=
null
;
this
.
unsatExplanationInTermsOfAssumptions
=
null
;
if
(
!
alreadylaunched
||
!
this
.
keepHot
)
{
this
.
order
.
init
(
)
;
}
this
.
learnedConstraintsDeletionStrategy
.
init
(
)
;
int
learnedLiteralsLimit
=
this
.
trail
.
size
(
)
;
this
.
qhead
=
0
;
for
(
int
i
=
learnedLiteralsLimit
-
1
;
i
>=
0
;
i
--
)
{
int
p
=
this
.
trail
.
get
(
i
)
;
IVec
<
Undoable
>
undos
=
this
.
voc
.
undos
(
p
)
;
assert
undos
!=
null
:
;
for
(
int
size
=
undos
.
size
(
)
;
size
>
0
;
size
--
)
{
undos
.
last
(
)
.
undo
(
p
)
;
undos
.
pop
(
)
;
}
}
for
(
IteratorInt
iterator
=
this
.
learnedLiterals
.
iterator
(
)
;
iterator
.
hasNext
(
)
;
)
{
enqueue
(
iterator
.
next
(
)
)
;
}
Constr
confl
=
propagate
(
)
;
if
(
confl
!=
null
)
{
analyzeAtRootLevel
(
confl
)
;
this
.
slistener
.
conflictFound
(
confl
,
0
,
0
)
;
this
.
slistener
.
end
(
Lbool
.
FALSE
)
;
cancelUntil
(
0
)
;
cancelLearntLiterals
(
learnedLiteralsLimit
)
;
return
false
;
}
for
(
IteratorInt
iterator
=
assumps
.
iterator
(
)
;
iterator
.
hasNext
(
)
;
)
{
int
assump
=
iterator
.
next
(
)
;
int
p
=
this
.
voc
.
getFromPool
(
assump
)
;
if
(
!
this
.
voc
.
isSatisfied
(
p
)
&&
!
assume
(
p
)
||
(
confl
=
propagate
(
)
)
!=
null
)
{
if
(
confl
==
null
)
{
this
.
slistener
.
conflictFound
(
p
)
;
this
.
unsatExplanationInTermsOfAssumptions
=
analyzeFinalConflictInTermsOfAssumptions
(
null
,
assumps
,
p
)
;
this
.
unsatExplanationInTermsOfAssumptions
.
push
(
assump
)
;
}
else
{
this
.
slistener
.
conflictFound
(
confl
,
decisionLevel
(
)
,
this
.
trail
.
size
(
)
)
;
this
.
unsatExplanationInTermsOfAssumptions
=
analyzeFinalConflictInTermsOfAssumptions
(
confl
,
assumps
,
ILits
.
UNDEFINED
)
;
}
this
.
slistener
.
end
(
Lbool
.
FALSE
)
;
cancelUntil
(
0
)
;
cancelLearntLiterals
(
learnedLiteralsLimit
)
;
return
false
;
}
}
this
.
rootLevel
=
decisionLevel
(
)
;
if
(
!
alreadylaunched
||
!
this
.
keepHot
)
{
this
.
order
.
init
(
)
;
}
this
.
learner
.
init
(
)
;
if
(
!
alreadylaunched
)
{
this
.
conflictCount
=
new
ConflictTimerContainer
(
)
;
this
.
conflictCount
.
add
(
this
.
restarter
)
;
this
.
conflictCount
.
add
(
this
.
learnedConstraintsDeletionStrategy
.
getTimer
(
)
)
;
}
boolean
firstTimeGlobal
=
false
;
if
(
this
.
timeBasedTimeout
)
{
if
(
!
global
||
this
.
timer
==
null
)
{
firstTimeGlobal
=
true
;
this
.
undertimeout
=
true
;
TimerTask
stopMe
=
new
TimerTask
(
)
{
@Override
public
void
run
(
)
{
this
.
undertimeout
=
false
;
}
}
;
this
.
timer
=
new
Timer
(
true
)
;
this
.
timer
.
schedule
(
stopMe
,
this
.
timeout
)
;
}
}
else
{
if
(
!
global
||
!
alreadylaunched
)
{
firstTimeGlobal
=
true
;
this
.
undertimeout
=
true
;
ConflictTimer
conflictTimeout
=
new
ConflictTimerAdapter
(
(
int
)
this
.
timeout
)
{
private
static
final
long
serialVersionUID
=
1L
;
@Override
public
void
run
(
)
{
this
.
undertimeout
=
false
;
}
}
;
this
.
conflictCount
.
add
(
conflictTimeout
)
;
}
}
if
(
!
global
||
firstTimeGlobal
)
{
this
.
restarter
.
init
(
this
.
params
,
this
.
stats
)
;
this
.
timebegin
=
System
.
currentTimeMillis
(
)
;
}
this
.
needToReduceDB
=
false
;
this
.
lastConflictMeansUnsat
=
true
;
while
(
status
==
Lbool
.
UNDEFINED
&&
this
.
undertimeout
&&
this
.
lastConflictMeansUnsat
)
{
int
before
=
this
.
trail
.
size
(
)
;
unitClauseProvider
.
provideUnitClauses
(
this
)
;
this
.
stats
.
importedUnits
=
this
.
trail
.
size
(
)
-
before
;
status
=
search
(
assumps
)
;
if
(
status
==
Lbool
.
UNDEFINED
)
{
this
.
restarter
.
onRestart
(
)
;
this
.
slistener
.
restarting
(
)
;
}
}
cancelUntil
(
0
)
;
cancelLearntLiterals
(
learnedLiteralsLimit
)
;
if
(
!
global
&&
this
.
timeBasedTimeout
&&
this
.
timer
!=
null
)
{
this
.
timer
.
cancel
(
)
;
this
.
timer
=
null
;
}
this
.
slistener
.
end
(
status
)
;
if
(
!
this
.
undertimeout
)
{
String
message
=
" Timeout ("
+
this
.
timeout
+
(
this
.
timeBasedTimeout
?
"s"
:
" conflicts"
)
+
") exceeded"
;
throw
new
TimeoutException
(
message
)
;
}
if
(
status
==
Lbool
.
UNDEFINED
&&
!
this
.
lastConflictMeansUnsat
)
{
throw
new
TimeoutException
(
"Cannot decide the satisfiability"
)
;
}
return
model
!=
null
;
}
