/** 
 * @throws TimeoutException if the timeout is reached during conflict analysis.
 */
public
void
analyze
(
Constr
confl
,
Pair
results
)
throws
TimeoutException
{
assert
confl
!=
null
:
;
final
boolean
[
]
seen
=
this
.
mseen
;
final
IVecInt
outLearnt
=
this
.
moutLearnt
;
final
IVecInt
preason
=
this
.
mpreason
;
outLearnt
.
clear
(
)
;
assert
outLearnt
.
size
(
)
==
0
:
;
for
(
int
i
=
0
;
i
<
seen
.
length
;
i
++
)
{
seen
[
i
]
=
false
;
}
int
counter
=
0
;
int
p
=
ILits
.
UNDEFINED
;
outLearnt
.
push
(
ILits
.
UNDEFINED
)
;
int
outBtlevel
=
0
;
IConstr
prevConfl
=
null
;
do
{
preason
.
clear
(
)
;
assert
confl
!=
null
:
;
if
(
prevConfl
!=
confl
)
{
confl
.
calcReason
(
p
,
preason
)
;
this
.
learnedConstraintsDeletionStrategy
.
onConflictAnalysis
(
confl
)
;
for
(
int
j
=
0
;
j
<
preason
.
size
(
)
;
j
++
)
{
int
q
=
preason
.
get
(
j
)
;
this
.
order
.
updateVar
(
q
)
;
if
(
!
seen
[
q
>>
1
]
)
{
seen
[
q
>>
1
]
=
true
;
if
(
this
.
voc
.
getLevel
(
q
)
==
decisionLevel
(
)
)
{
counter
++
;
this
.
order
.
updateVarAtDecisionLevel
(
q
)
;
}
else
if
(
this
.
voc
.
getLevel
(
q
)
>
0
)
{
outLearnt
.
push
(
q
^
1
)
;
outBtlevel
=
Math
.
max
(
outBtlevel
,
this
.
voc
.
getLevel
(
q
)
)
;
}
}
}
}
prevConfl
=
confl
;
do
{
p
=
this
.
trail
.
last
(
)
;
confl
=
this
.
voc
.
getReason
(
p
)
;
undoOne
(
)
;
}
while
(
!
seen
[
p
>>
1
]
)
;
}
while
(
--
counter
>
0
)
;
outLearnt
.
set
(
0
,
p
^
1
)
;
this
.
simplifier
.
simplify
(
outLearnt
)
;
Constr
c
=
this
.
dsfactory
.
createUnregisteredClause
(
outLearnt
)
;
this
.
learnedConstraintsDeletionStrategy
.
onClauseLearning
(
c
)
;
results
.
reason
=
c
;
assert
outBtlevel
>
-
1
:
;
results
.
backtrackLevel
=
outBtlevel
;
}
