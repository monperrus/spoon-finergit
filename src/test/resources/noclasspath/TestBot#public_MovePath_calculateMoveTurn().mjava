public
MovePath
calculateMoveTurn
(
)
{
long
enter
=
System
.
currentTimeMillis
(
)
;
int
initiative
=
0
;
MoveOption
min
=
null
;
System
.
out
.
println
(
"beginning movement calculations..."
)
;
Object
[
]
enemy_array
=
this
.
getEnemyEntities
(
)
.
toArray
(
)
;
for
(
int
j
=
0
;
j
<
enemy_array
.
length
;
j
++
)
{
if
(
!
(
(
Entity
)
enemy_array
[
j
]
)
.
isSelectableThisTurn
(
)
)
{
initiative
++
;
}
}
if
(
initiative
==
enemies_moved
&&
old_moves
!=
null
)
{
min
=
this
.
old_moves
.
getResult
(
)
;
if
(
min
==
null
||
!
min
.
isMoveLegal
(
)
||
(
min
.
isPhysical
&&
centities
.
get
(
min
.
getPhysicalTargetId
(
)
)
.
isPhysicalTarget
)
)
{
this
.
old_moves
=
null
;
System
.
out
.
println
(
"recalculating moves since the old move was invalid"
)
;
return
calculateMoveTurn
(
)
;
}
}
else
{
enemies_moved
=
initiative
;
Vector
possible
=
new
Vector
(
)
;
Enumeration
e
=
game
.
getEntities
(
)
;
while
(
e
.
hasMoreElements
(
)
)
{
Entity
entity
=
(
Entity
)
e
.
nextElement
(
)
;
if
(
entity
.
getPosition
(
)
.
isValidPosition
(
)
==
false
)
{
continue
;
}
CEntity
cen
=
centities
.
get
(
entity
)
;
cen
.
refresh
(
)
;
firstPass
(
cen
)
;
}
Iterator
i
=
this
.
getEntitiesOwned
(
)
.
iterator
(
)
;
boolean
short_circuit
=
false
;
while
(
i
.
hasNext
(
)
&&
!
short_circuit
)
{
Entity
entity
=
(
Entity
)
i
.
next
(
)
;
if
(
entity
.
getPosition
(
)
.
isValidPosition
(
)
==
false
)
{
continue
;
}
if
(
!
game
.
getTurn
(
)
.
isValidEntity
(
entity
,
game
)
)
{
continue
;
}
CEntity
cen
=
centities
.
get
(
entity
)
;
System
.
out
.
println
(
"Contemplating movement of "
+
entity
.
getShortName
(
)
+
" "
+
entity
.
getId
(
)
)
;
MoveOption
[
]
result
=
calculateMove
(
entity
)
;
if
(
game
.
getOptions
(
)
.
booleanOption
(
"skip_ineligable_movement"
)
&&
cen
.
getEntity
(
)
.
isImmobile
(
)
)
{
cen
.
moved
=
true
;
}
else
if
(
!
cen
.
moved
)
{
if
(
result
.
length
<
6
)
{
min
=
result
.
length
>
0
?
(
MoveOption
)
result
[
0
]
:
null
;
short_circuit
=
true
;
}
possible
.
add
(
result
)
;
}
}
if
(
!
short_circuit
)
{
if
(
this
.
getEntitiesOwned
(
)
.
size
(
)
>
1
)
{
GALance
lance
=
new
GALance
(
this
,
possible
,
50
,
80
)
;
lance
.
evolve
(
)
;
min
=
lance
.
getResult
(
)
;
this
.
old_moves
=
lance
;
}
else
if
(
(
(
MoveOption
[
]
)
possible
.
elementAt
(
0
)
)
!=
null
&&
(
(
MoveOption
[
]
)
possible
.
elementAt
(
0
)
)
.
length
>
0
)
{
min
=
(
(
MoveOption
[
]
)
possible
.
elementAt
(
0
)
)
[
0
]
;
}
}
}
if
(
min
==
null
)
{
min
=
new
MoveOption
(
game
,
centities
.
get
(
getFirstEntityNum
(
)
)
)
;
}
for
(
int
d
=
0
;
d
<
enemy_array
.
length
;
d
++
)
{
Entity
en
=
(
Entity
)
enemy_array
[
d
]
;
if
(
en
.
getPosition
(
)
.
isValidPosition
(
)
==
false
)
{
continue
;
}
CEntity
enemy
=
centities
.
get
(
en
)
;
int
enemy_hit_arc
=
CEntity
.
getThreatHitArc
(
enemy
.
current
.
getFinalCoords
(
)
,
enemy
.
current
.
getFinalFacing
(
)
,
min
.
getFinalCoords
(
)
)
;
MoveOption
.
DamageInfo
di
=
(
MoveOption
.
DamageInfo
)
min
.
damageInfos
.
get
(
enemy
)
;
if
(
di
!=
null
)
{
enemy
.
expected_damage
[
enemy_hit_arc
]
=
di
.
min_damage
;
}
if
(
enemy
.
expected_damage
[
enemy_hit_arc
]
>
0
)
{
enemy
.
hasTakenDamage
=
true
;
}
}
if
(
min
.
isPhysical
)
{
centities
.
get
(
min
.
getPhysicalTargetId
(
)
)
.
isPhysicalTarget
=
true
;
}
System
.
out
.
println
(
min
)
;
min
.
getCEntity
(
)
.
current
=
min
;
min
.
getCEntity
(
)
.
last
=
min
;
this
.
my_mechs_moved
++
;
min
.
getCEntity
(
)
.
moved
=
true
;
long
exit
=
System
.
currentTimeMillis
(
)
;
System
.
out
.
println
(
"move turn took "
+
(
exit
-
enter
)
+
" ms"
)
;
return
min
;
}
